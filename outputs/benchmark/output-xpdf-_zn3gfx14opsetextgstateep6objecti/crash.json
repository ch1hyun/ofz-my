{
    "samples": [

    {
        "benchmark": "output-xpdf-_zn3gfx14opsetextgstateep6objecti",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include \"Gfx.h\"\\n#include \"Object.h\"\\n#include \"XRef.h\"\\n#include \"PDFDoc.h\"\\n#include \"OutputDev.h\"\\n#include \"Dict.h\"\\n#include \"/src/xpdf-4.05/xpdf/SecurityHandler.h\"\\n\\nclass MyOutputDev : public OutputDev {\\npublic:\\n    virtual GBool upsideDown() { return gFalse; }\\n    virtual GBool useDrawChar() { return gFalse; }\\n    virtual GBool interpretType3Chars() { return gFalse; }\\n};\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  if (size < 1) {\\n    return 0;\\n  }\\n\\n  FuzzedDataProvider fuzzed_data_provider(data, size);\\n\\n  // Initialize an Object with the fuzzing data.\\n  // Consume half of the remaining data for this.\\n  size_t objectByteSize = fuzzed_data_provider.remaining_bytes() / 2;\\n  std::vector<char> objectBytes = fuzzed_data_provider.ConsumeBytes<char>(objectByteSize);\\n\\n  // Create a XRef object and initialize it with the vector\\n  MemStream *strA = new MemStream(objectBytes.data(), 0, objectBytes.size(), Object(objNull));\\n  XRef xref(strA, gFalse);\\n\\n  // Use the XRef object to initialize the Object\\n  Object obj;\\n  obj.initArray(&xref);\\n  \\n  // Consume an int for the second parameter.\\n  int int_arg = fuzzed_data_provider.ConsumeIntegral<int>();\\n\\n  // Create an instance of Gfx and call the method on it\\n  // As the constructor of Gfx requires at least 5 arguments, we need to create dummy instances for them.\\n  GString *fileNameA = new GString();\\n  PDFDoc *docA = new PDFDoc(fileNameA, &xref, new StandardSecurityHandler(&xref, new Dict(&xref)));\\n  MyOutputDev *outA = new MyOutputDev();\\n  Dict *resDict = new Dict(&xref);\\n  SecurityHandler *box = docA->getSecurityHandler();\\n  SecurityHandler *cropBox = docA->getSecurityHandler();\\n\\n  Gfx gfx(docA, outA, resDict, box, cropBox);\\n\\n  // As opSetExtGState is a private method, we can't call it directly.\\n  // We need to find a public method that eventually calls this private method and use it instead.\\n  // Assuming that method is called \"publicMethodThatCallsOpSetExtGState\"\\n  gfx.publicMethodThatCallsOpSetExtGState(&obj, int_arg);\\n\\n  return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-xpdf-_zn3gfx14opsetextgstateep6objecti",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include \"Gfx.h\"\\n#include \"PDFDoc.h\"\\n#include \"OutputDev.h\"\\n#include \"/src/xpdf-4.05/xpdf/Gfx.h\"\\n#include \"GString.h\"\\n#include \"XRef.h\"\\n#include \"/src/xpdf-4.05/xpdf/SecurityHandler.h\"\\n\\nclass MyOutputDev : public OutputDev {\\npublic:\\n  MyOutputDev() {}\\n  virtual ~MyOutputDev() {}\\n  virtual GBool upsideDown() { return gTrue; }\\n  virtual GBool useDrawChar() { return gTrue; }\\n  virtual GBool interpretType3Chars() { return gFalse; }\\n};\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  FuzzedDataProvider stream(data, size);\\n  // Create an instance of Object to pass into the method.\\n  Object object_instance;\\n  // Checking for remaining bytes before consuming data for \"int\" argument.\\n  // Returns early if not enough valid data.\\n  if (stream.remaining_bytes() < sizeof(int32_t)) {\\n    return 0;\\n  }\\n  // Consumes a random 32-bit integer for the second parameter of the function\\n  int int_param = stream.ConsumeIntegral<int32_t>();\\n  \\n  // Create an instance of Gfx to call the function\\n  // We need to pass the required parameters to the Gfx constructor\\n  GString *fileNameA = new GString(\"dummy.pdf\");\\n  PDFDoc *docA = new PDFDoc(fileNameA);\\n  OutputDev *outA = new MyOutputDev();\\n  XRef *xrefA = new XRef(fileNameA);\\n  Dict *resDict = new Dict(xrefA);\\n  Gfx gfx_instance(docA, outA, resDict, int_param);\\n\\n  // Call the function under test\\n  // opSetExtGState is a private member of 'Gfx', we can't directly call it.\\n  // We need to call a public method that internally calls opSetExtGState\\n  gfx_instance.display(&object_instance, int_param);\\n\\n  // Clean up\\n  delete fileNameA;\\n  delete docA;\\n  delete outA;\\n  delete xrefA;\\n  delete resDict;\\n\\n  return 0;\\n}",
        "model": ""
    }

    ]
}