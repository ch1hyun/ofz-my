<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-libraw-_zn6libraw14crxdecodeplaneepvj / 02</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>

</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; 4) {
        return 0;  // Not enough data for fuzzing
    }

    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4096]; // Increase the size of the array to prevent stack-buffer-overflow
    // Copy 4 bytes from the input data to the array
    memcpy(arr, stream.ConsumeBytes&lt;uint8_t&gt;(4).data(), 4);
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &lt;libraw/libraw.h&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

static LibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  FuzzedDataProvider stream(data, size);

  // Generate an array with enough size
  uint8_t arr[4];
  // Decode the plane
  int result = processor.crxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
/src/libraw_fuzzer.cc:3:10: fatal error: &#39;libraw/libraw.h&#39; file not found
    3 | #include &lt;libraw/libraw.h&gt;
      |          ^~~~~~~~~~~~~~~~~
&lt;/error&gt;


Below are instructions to assist you in fixing the error.
&lt;instruction&gt;
IMPORTANT: DO NOT include the header file libraw/libraw.h in the generated fuzz target again, the file does not exist in the project-under-test.
Replace the non-existent &lt;filepath&gt;libraw/libraw.h&lt;/filepath&gt; with the following statement, which share the same file name but exists under the correct path in the project-under-test:
&lt;code&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
&lt;/code&gt;

&lt;/instruction&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

static LibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  FuzzedDataProvider stream(data, size);

  // Generate an array with enough size
  uint8_t arr[4];
  // Decode the plane
  int result = processor.crxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
  return 0;
}
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

static LibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  FuzzedDataProvider stream(data, size);

  // Generate an array with enough size
  uint8_t arr[4];
  // Decode the plane
  int result = processor.crxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
/src/libraw_fuzzer.cc:14:26: error: &#39;crxDecodePlane&#39; is a protected member of &#39;LibRaw&#39;
   14 |   int result = processor.crxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
      |                          ^
/src/libraw/libraw/libraw.h:374:7: note: declared protected here
  374 |   int crxDecodePlane(void *, uint32_t planeNumber);
      |       ^
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
The error indicates that the method &#39;crxDecodePlane&#39; is a protected member of &#39;LibRaw&#39;. This means it can&#39;t be accessed directly from outside the class. 

To fix this, we can create a derived class from LibRaw, which will have access to its protected members. Then we can create a public method in this derived class that will call the protected method &#39;crxDecodePlane&#39;.

Here is the fixed code:

```cpp
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4];
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
```

This solution maintains the original intent of the code while fixing the build error.
</pre>


<h3>Fixer prompt #3</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4];
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fbc2dc4182d at pc 0x5595ee1cf4d0 bp 0x7fffffcd82b0 sp 0x7fffffcd82a8), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x5595ee1cf4cf in LibRaw::crxDecodePlane(void*, unsigned int) /src/libraw/src/decoders/crx.cpp:1895:34
#1 0x5595ee17fdd0 in callCrxDecodePlane /src/libraw_fuzzer.cc:9:16
#2 0x5595ee17fdd0 in LLVMFuzzerTestOneInput /src/libraw_fuzzer.cc:21:28
#3 0x5595ee032650 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#4 0x5595ee033b51 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
#5 0x5595ee034137 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#6 0x5595ee022746 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#7 0x5595ee04ec72 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#8 0x7fbc2e1d6082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#9 0x5595ee0138bd in _start (/out/libraw_cr2_fuzzer+0xd78bd)
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #3</h3>

<pre>
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; 4) {
        return 0;  // Not enough data for fuzzing
    }

    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4];
    // Copy 4 bytes from the input data to the array
    memcpy(arr, stream.ConsumeBytes&lt;uint8_t&gt;(4).data(), 4);
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
&lt;/code&gt;
&lt;/solution&gt;
</pre>


<h3>Fixer prompt #4</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; 4) {
        return 0;  // Not enough data for fuzzing
    }

    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4];
    // Copy 4 bytes from the input data to the array
    memcpy(arr, stream.ConsumeBytes&lt;uint8_t&gt;(4).data(), 4);
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f85d205f8ad at pc 0x55b08bd8a620 bp 0x7ffcd1f10970 sp 0x7ffcd1f10968), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x55b08bd8a61f in LibRaw::crxDecodePlane(void*, unsigned int) /src/libraw/src/decoders/crx.cpp:1895:34
#1 0x55b08bd39f6b in callCrxDecodePlane /src/libraw_fuzzer.cc:9:16
#2 0x55b08bd39f6b in LLVMFuzzerTestOneInput /src/libraw_fuzzer.cc:27:28
#3 0x55b08bbec650 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#4 0x55b08bbebe75 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
#5 0x55b08bbede02 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:829:7
#6 0x55b08bbee137 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#7 0x55b08bbdc746 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#8 0x55b08bc08c72 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#9 0x7f85d286d082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#10 0x55b08bbcd8bd in _start (/out/libraw_cr2_fuzzer+0xd78bd)
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #4</h3>

<pre>
&lt;code&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &#34;/src/libraw/libraw/libraw.h&#34;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

class FuzzLibRaw : public LibRaw {
public:
    int callCrxDecodePlane(void *arr, uint32_t planeNumber) {
        return crxDecodePlane(arr, planeNumber);
    }
};

static FuzzLibRaw processor;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; 4) {
        return 0;  // Not enough data for fuzzing
    }

    FuzzedDataProvider stream(data, size);

    // Generate an array with enough size
    uint8_t arr[4096]; // Increase the size of the array to prevent stack-buffer-overflow
    // Copy 4 bytes from the input data to the array
    memcpy(arr, stream.ConsumeBytes&lt;uint8_t&gt;(4).data(), 4);
    // Decode the plane
    int result = processor.callCrxDecodePlane(static_cast&lt;void *&gt;(arr), stream.ConsumeIntegral&lt;uint32_t&gt;());
  
    return 0;
}
&lt;/code&gt;
&lt;solution&gt;
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4, attempt 1.
Fixing /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4, attempt 2.
Fixing /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4, attempt 3.
Fixing /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4, attempt 4.
Successfully built /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4 in 4 iterations of fixing.
Triaging the crash related to /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/fixed_targets/02.cc with gpt-4.
Warning: no crash info in libraw-zn6libraw14crxdecodeplaneepvj-02.
Warning: No cov info in run result of libraw-zn6libraw14crxdecodeplaneepvj-02.

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/chyun/oss-fuzz-gen/results/output-libraw-_zn6libraw14crxdecodeplaneepvj/corpora/02.cc:/tmp/libraw_cr2_fuzzer_corpus -v /tmp/tmpz20745pu/build/out/libraw-zn6libraw14crxdecodeplaneepvj-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer libraw_cr2_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/libraw_cr2_fuzzer_corpus&#39;: Device or resource busy
Using seed corpus: libraw_cr2_fuzzer_seed_corpus.zip
/out/libraw_cr2_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/libraw_cr2_fuzzer_corpus &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 4269863213
INFO: Loaded 1 modules   (17669 inline 8-bit counters): 17669 [0x558bbb1d93c8, 0x558bbb1dd8cd), 
INFO: Loaded 1 PC tables (17669 PCs): 17669 [0x558bbb1dd8d0,0x558bbb222920), 
INFO:        3 files found in /tmp/libraw_cr2_fuzzer_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes
INFO: seed corpus: files: 3 min: 6884212b max: 12304199b total: 27614165b rss: 33Mb
#4	INITED cov: 18 ft: 19 corp: 1/1024Kb exec/s: 0 rss: 43Mb
#12	REDUCE cov: 18 ft: 19 corp: 1/372Kb lim: 1048576 exec/s: 0 rss: 47Mb L: 381205/381205 MS: 3 CopyPart-ChangeByte-CrossOver-
#33	REDUCE cov: 18 ft: 19 corp: 1/312Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 319688/319688 MS: 1 EraseBytes-
#34	REDUCE cov: 18 ft: 19 corp: 1/300Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 307513/307513 MS: 1 CrossOver-
#46	REDUCE cov: 18 ft: 19 corp: 1/156Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 159902/159902 MS: 2 ChangeASCIIInt-EraseBytes-
#61	REDUCE cov: 18 ft: 19 corp: 1/90Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 92264/92264 MS: 5 CrossOver-InsertRepeatedBytes-CopyPart-ChangeBinInt-EraseBytes-
#70	REDUCE cov: 18 ft: 19 corp: 1/81Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 83633/83633 MS: 4 ChangeBinInt-ChangeASCIIInt-ChangeASCIIInt-EraseBytes-
#80	REDUCE cov: 18 ft: 19 corp: 1/47Kb lim: 1048576 exec/s: 0 rss: 49Mb L: 48487/48487 MS: 5 ChangeBit-InsertByte-InsertRepeatedBytes-ChangeBinInt-EraseBytes-
#90	REDUCE cov: 18 ft: 19 corp: 1/3270b lim: 1048576 exec/s: 0 rss: 49Mb L: 3270/3270 MS: 5 ShuffleBytes-ChangeBit-ShuffleBytes-ChangeBit-CrossOver-
#122	REDUCE cov: 18 ft: 19 corp: 1/3186b lim: 1048576 exec/s: 0 rss: 49Mb L: 3186/3186 MS: 2 ChangeASCIIInt-EraseBytes-
#135	REDUCE cov: 18 ft: 19 corp: 1/2342b lim: 1048576 exec/s: 0 rss: 49Mb L: 2342/2342 MS: 3 ChangeASCIIInt-InsertRepeatedBytes-EraseBytes-
#162	REDUCE cov: 18 ft: 19 corp: 1/2211b lim: 1048576 exec/s: 0 rss: 49Mb L: 2211/2211 MS: 2 ShuffleBytes-EraseBytes-
#168	REDUCE cov: 18 ft: 19 corp: 1/1973b lim: 1048576 exec/s: 0 rss: 49Mb L: 1973/1973 MS: 1 EraseBytes-
#194	REDUCE cov: 18 ft: 19 corp: 1/1851b lim: 1048576 exec/s: 0 rss: 49Mb L: 1851/1851 MS: 1 EraseBytes-
#200	REDUCE cov: 18 ft: 19 corp: 1/1647b lim: 1048576 exec/s: 0 rss: 49Mb L: 1647/1647 MS: 1 EraseBytes-
#213	REDUCE cov: 18 ft: 19 corp: 1/1151b lim: 1048576 exec/s: 0 rss: 49Mb L: 1151/1151 MS: 3 InsertRepeatedBytes-CopyPart-EraseBytes-
#229	REDUCE cov: 18 ft: 19 corp: 1/995b lim: 1048576 exec/s: 0 rss: 49Mb L: 995/995 MS: 1 EraseBytes-
#256	REDUCE cov: 18 ft: 19 corp: 1/975b lim: 1048576 exec/s: 0 rss: 49Mb L: 975/975 MS: 2 InsertByte-EraseBytes-
#284	REDUCE cov: 18 ft: 19 corp: 1/793b lim: 1048576 exec/s: 0 rss: 49Mb L: 793/793 MS: 3 ChangeBit-ChangeBit-EraseBytes-
#287	REDUCE cov: 18 ft: 19 corp: 1/672b lim: 1048576 exec/s: 0 rss: 49Mb L: 672/672 MS: 3 ChangeByte-InsertByte-EraseBytes-
#330	REDUCE cov: 18 ft: 19 corp: 1/403b lim: 1048576 exec/s: 0 rss: 49Mb L: 403/403 MS: 3 InsertByte-ChangeByte-EraseBytes-
#348	REDUCE cov: 18 ft: 19 corp: 1/224b lim: 1048576 exec/s: 0 rss: 49Mb L: 224/224 MS: 3 InsertByte-CMP-EraseBytes- DE: &#34;\377\377\377\377\377\377\377\377&#34;-
#350	REDUCE cov: 18 ft: 19 corp: 1/216b lim: 1048576 exec/s: 0 rss: 49Mb L: 216/216 MS: 2 ChangeBit-EraseBytes-
#353	REDUCE cov: 18 ft: 19 corp: 1/134b lim: 1048576 exec/s: 0 rss: 49Mb L: 134/134 MS: 3 ChangeBinInt-ChangeByte-EraseBytes-
#376	REDUCE cov: 18 ft: 19 corp: 1/82b lim: 1048576 exec/s: 0 rss: 49Mb L: 82/82 MS: 3 ChangeBit-InsertByte-EraseBytes-
#384	REDUCE cov: 18 ft: 19 corp: 1/51b lim: 1048576 exec/s: 0 rss: 49Mb L: 51/51 MS: 3 InsertByte-CMP-EraseBytes- DE: &#34;\001\000\000\000&#34;-
#392	REDUCE cov: 18 ft: 19 corp: 1/38b lim: 1048576 exec/s: 0 rss: 49Mb L: 38/38 MS: 3 ChangeByte-PersAutoDict-EraseBytes- DE: &#34;\001\000\000\000&#34;-
#394	REDUCE cov: 18 ft: 19 corp: 1/30b lim: 1048576 exec/s: 0 rss: 49Mb L: 30/30 MS: 2 PersAutoDict-EraseBytes- DE: &#34;\377\377\377\377\377\377\377\377&#34;-
#400	REDUCE cov: 18 ft: 19 corp: 1/17b lim: 1048576 exec/s: 0 rss: 49Mb L: 17/17 MS: 1 EraseBytes-
#417	REDUCE cov: 18 ft: 19 corp: 1/10b lim: 1048576 exec/s: 0 rss: 49Mb L: 10/10 MS: 2 ChangeBinInt-EraseBytes-
#420	REDUCE cov: 18 ft: 21 corp: 2/15b lim: 1048576 exec/s: 0 rss: 49Mb L: 5/10 MS: 3 PersAutoDict-ChangeByte-EraseBytes- DE: &#34;\377\377\377\377\377\377\377\377&#34;-
#439	NEW    cov: 19 ft: 22 corp: 3/18b lim: 1048576 exec/s: 0 rss: 49Mb L: 3/10 MS: 4 PersAutoDict-ShuffleBytes-CopyPart-EraseBytes- DE: &#34;\001\000\000\000&#34;-
#445	REDUCE cov: 19 ft: 22 corp: 3/17b lim: 1048576 exec/s: 0 rss: 49Mb L: 2/10 MS: 1 EraseBytes-
#446	REDUCE cov: 19 ft: 22 corp: 3/15b lim: 1048576 exec/s: 0 rss: 49Mb L: 8/8 MS: 1 EraseBytes-
#458	NEW    cov: 19 ft: 24 corp: 4/21b lim: 1048576 exec/s: 0 rss: 49Mb L: 6/8 MS: 2 ChangeBit-CrossOver-
#478	REDUCE cov: 19 ft: 25 corp: 5/28b lim: 1048576 exec/s: 0 rss: 49Mb L: 7/8 MS: 5 ChangeBinInt-CrossOver-PersAutoDict-CMP-EraseBytes- DE: &#34;\377\377\377\377\377\377\377\377&#34;-&#34;D\000\000\000\000\000\000\000&#34;-
#493	NEW    cov: 19 ft: 26 corp: 6/32b lim: 1048576 exec/s: 0 rss: 49Mb L: 4/8 MS: 5 ChangeBit-CopyPart-EraseBytes-EraseBytes-CopyPart-
#543	REDUCE cov: 19 ft: 26 corp: 6/31b lim: 1048576 exec/s: 0 rss: 49Mb L: 1/8 MS: 5 ShuffleBytes-ShuffleBytes-ShuffleBytes-CrossOver-EraseBytes-
#190612	RELOAD cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 190612 rss: 66Mb
#524288	pulse  cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 262144 rss: 71Mb
#1048576	pulse  cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 262144 rss: 71Mb
#2097152	pulse  cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 262144 rss: 71Mb
#4194304	pulse  cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 262144 rss: 71Mb
#8060292	DONE   cov: 19 ft: 27 corp: 7/3301b lim: 1048576 exec/s: 260009 rss: 71Mb
###### Recommended dictionary. ######
&#34;\377\377\377\377\377\377\377\377&#34; # Uses: 196115
&#34;\001\000\000\000&#34; # Uses: 249946
&#34;D\000\000\000\000\000\000\000&#34; # Uses: 196530
###### End of recommended dictionary. ######
Done 8060292 runs in 31 second(s)
stat::number_of_executed_units: 8060292
stat::average_exec_per_sec:     260009
stat::new_units_added:          37
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              71

</pre>


</body>