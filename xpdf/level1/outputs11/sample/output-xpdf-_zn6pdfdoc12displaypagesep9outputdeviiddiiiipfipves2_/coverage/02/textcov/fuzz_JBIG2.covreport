LLVMFuzzerTestOneInput:
   27|    129|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   28|    129|  FuzzedDataProvider fdp(data, size);
   29|    129|  double hdpi = fdp.ConsumeFloatingPoint<double>();
   30|    129|  double vdpi = fdp.ConsumeFloatingPoint<double>();
   31|    129|  int rotate = fdp.ConsumeIntegral<int>();
   32|    129|  bool useMediaBox = fdp.ConsumeBool();
   33|    129|  bool crop = fdp.ConsumeBool();
   34|    129|  bool printing = fdp.ConsumeBool();
   35|    129|  std::vector<char> payload = fdp.ConsumeRemainingBytes<char>();
   36|       |
   37|    129|  Object xpdf_obj;
   38|    129|  xpdf_obj.initNull();
   39|    129|  BaseStream *stream = new MemStream(payload.data(), 0, payload.size(), &xpdf_obj);
   40|       |
   41|    129|  Object info, xfa;
   42|    129|  Object *acroForm;
   43|    129|  GlobalParams *globalParams = new GlobalParams(NULL);
   44|    129|  globalParams->setErrQuiet(1);
   45|    129|  globalParams->setupBaseFonts(NULL);
   46|    129|  char yes[] = "yes";
   47|    129|  globalParams->setEnableFreeType(yes); // Yes, it's a string and not a bool.
   48|    129|  globalParams->setErrQuiet(1);
   49|       |
   50|    129|  PDFDoc *doc = NULL;
   51|    129|  try {
   52|    129|    doc = new PDFDoc(stream); // Fixed: Allocate memory for PDFDoc object
   53|    129|    if (doc->isOk() == gTrue) {
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  |  Branch (53:9): [True: 0, False: 129]
  ------------------
   54|      0|      doc->getNumPages();
   55|      0|      doc->getOutline();
   56|      0|      doc->getStructTreeRoot();
   57|      0|      doc->getXRef();
   58|      0|      doc->okToPrint(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   59|      0|      doc->okToCopy(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   60|      0|      doc->okToChange(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   61|      0|      doc->okToAddNotes(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   62|      0|      doc->isLinearized();
   63|      0|      doc->getPDFVersion();
   64|       |
   65|      0|      GString *metadata;
   66|      0|      if ((metadata = doc->readMetadata())) {
  ------------------
  |  Branch (66:11): [True: 0, False: 0]
  ------------------
   67|      0|        (void)metadata->getCString();
   68|      0|      }
   69|      0|      delete metadata;
   70|       |
   71|      0|      Object info;
   72|      0|      doc->getDocInfo(&info);
   73|      0|      if (info.isDict()) {
  ------------------
  |  Branch (73:11): [True: 0, False: 0]
  ------------------
   74|      0|        info.getDict();
   75|      0|      }
   76|      0|      info.free();
   77|       |
   78|      0|      if ((acroForm = doc->getCatalog()->getAcroForm())->isDict()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|        acroForm->dictLookup("XFA", &xfa);
   80|      0|        xfa.free();
   81|      0|      }
   82|       |
   83|      0|      SplashColor paperColor = {0xff, 0xff, 0xff};
   84|      0|      SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 1, gFalse, paperColor);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   85|      0|      splashOut->setNoComposite(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   86|      0|      splashOut->startDoc(doc->getXRef());
   87|      0|      doc->displayPages(splashOut, 1, doc->getNumPages(), hdpi, vdpi, rotate, useMediaBox, crop, printing, nullptr, nullptr);
   88|      0|      (void)splashOut->getBitmap();
   89|       |
   90|      0|      delete splashOut;
   91|      0|    }
   92|    129|  } catch (...) {
   93|      0|  }
   94|       |
   95|    129|  delete doc; // Fixed: Free the allocated memory for PDFDoc object
   96|    129|  delete globalParams;
   97|       |
   98|    129|  return 0;
   99|    129|}

_ZN5GHashC2Ei:
   34|  1.41k|GHash::GHash(GBool deleteKeysA) {
   35|  1.41k|  int h;
   36|       |
   37|  1.41k|  deleteKeys = deleteKeysA;
   38|  1.41k|  size = 7;
   39|  1.41k|  tab = (GHashBucket **)gmallocn(size, sizeof(GHashBucket *));
   40|  11.3k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (40:15): [True: 9.93k, False: 1.41k]
  ------------------
   41|  9.93k|    tab[h] = NULL;
   42|  9.93k|  }
   43|  1.41k|  len = 0;
   44|  1.41k|}
_ZN5GHashD2Ev:
   46|  1.41k|GHash::~GHash() {
   47|  1.41k|  GHashBucket *p;
   48|  1.41k|  int h;
   49|       |
   50|  11.3k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (50:15): [True: 9.93k, False: 1.41k]
  ------------------
   51|  10.8k|    while (tab[h]) {
  ------------------
  |  Branch (51:12): [True: 903, False: 9.93k]
  ------------------
   52|    903|      p = tab[h];
   53|    903|      tab[h] = p->next;
   54|    903|      if (deleteKeys) {
  ------------------
  |  Branch (54:11): [True: 129, False: 774]
  ------------------
   55|    129|	delete p->key;
   56|    129|      }
   57|    903|      delete p;
   58|    903|    }
   59|  9.93k|  }
   60|  1.41k|  gfree(tab);
   61|  1.41k|}
_ZN5GHash3addEP7GStringPv:
   63|    903|void GHash::add(GString *key, void *val) {
   64|    903|  GHashBucket *p;
   65|    903|  int h;
   66|       |
   67|       |  // expand the table if necessary
   68|    903|  if (len >= size) {
  ------------------
  |  Branch (68:7): [True: 0, False: 903]
  ------------------
   69|      0|    expand();
   70|      0|  }
   71|       |
   72|       |  // add the new symbol
   73|    903|  p = new GHashBucket;
   74|    903|  p->key = key;
   75|    903|  p->val.p = val;
   76|    903|  h = hash(key);
   77|    903|  p->next = tab[h];
   78|    903|  tab[h] = p;
   79|    903|  ++len;
   80|    903|}
_ZN5GHash6lookupEPKc:
  149|  5.93k|void *GHash::lookup(const char *key) {
  150|  5.93k|  GHashBucket *p;
  151|  5.93k|  int h;
  152|       |
  153|  5.93k|  if (!(p = find(key, &h))) {
  ------------------
  |  Branch (153:7): [True: 5.93k, False: 0]
  ------------------
  154|  5.93k|    return NULL;
  155|  5.93k|  }
  156|      0|  return p->val.p;
  157|  5.93k|}
_ZN5GHash9startIterEPP9GHashIter:
  261|  1.29k|void GHash::startIter(GHashIter **iter) {
  262|  1.29k|  *iter = new GHashIter;
  263|  1.29k|  (*iter)->h = -1;
  264|  1.29k|  (*iter)->p = NULL;
  265|  1.29k|}
_ZN5GHash7getNextEPP9GHashIterPP7GStringPPv:
  267|  2.19k|GBool GHash::getNext(GHashIter **iter, GString **key, void **val) {
  268|  2.19k|  if (!*iter) {
  ------------------
  |  Branch (268:7): [True: 0, False: 2.19k]
  ------------------
  269|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  270|      0|  }
  271|  2.19k|  if ((*iter)->p) {
  ------------------
  |  Branch (271:7): [True: 903, False: 1.29k]
  ------------------
  272|    903|    (*iter)->p = (*iter)->p->next;
  273|    903|  }
  274|  11.2k|  while (!(*iter)->p) {
  ------------------
  |  Branch (274:10): [True: 10.3k, False: 903]
  ------------------
  275|  10.3k|    if (++(*iter)->h == size) {
  ------------------
  |  Branch (275:9): [True: 1.29k, False: 9.03k]
  ------------------
  276|  1.29k|      delete *iter;
  277|  1.29k|      *iter = NULL;
  278|  1.29k|      return gFalse;
  ------------------
  |  |   18|  1.29k|#define gFalse 0
  ------------------
  279|  1.29k|    }
  280|  9.03k|    (*iter)->p = tab[(*iter)->h];
  281|  9.03k|  }
  282|    903|  *key = (*iter)->p->key;
  283|    903|  *val = (*iter)->p->val.p;
  284|    903|  return gTrue;
  ------------------
  |  |   17|    903|#define gTrue 1
  ------------------
  285|  2.19k|}
_ZN5GHash4findEPKcPi:
  348|  5.93k|GHashBucket *GHash::find(const char *key, int *h) {
  349|  5.93k|  GHashBucket *p;
  350|       |
  351|  5.93k|  *h = hash(key);
  352|  5.93k|  for (p = tab[*h]; p; p = p->next) {
  ------------------
  |  Branch (352:21): [True: 0, False: 5.93k]
  ------------------
  353|      0|    if (!p->key->cmp(key)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 0]
  ------------------
  354|      0|      return p;
  355|      0|    }
  356|      0|  }
  357|  5.93k|  return NULL;
  358|  5.93k|}
_ZN5GHash4hashEP7GString:
  360|    903|int GHash::hash(GString *key) {
  361|    903|  const char *p;
  362|    903|  unsigned int h;
  363|    903|  int i;
  364|       |
  365|    903|  h = 0;
  366|  6.96k|  for (p = key->getCString(), i = 0; i < key->getLength(); ++p, ++i) {
  ------------------
  |  Branch (366:38): [True: 6.06k, False: 903]
  ------------------
  367|  6.06k|    h = 17 * h + (int)(*p & 0xff);
  368|  6.06k|  }
  369|    903|  return (int)(h % size);
  370|    903|}
_ZN5GHash4hashEPKc:
  372|  5.93k|int GHash::hash(const char *key) {
  373|  5.93k|  const char *p;
  374|  5.93k|  unsigned int h;
  375|       |
  376|  5.93k|  h = 0;
  377|  81.3k|  for (p = key; *p; ++p) {
  ------------------
  |  Branch (377:17): [True: 75.4k, False: 5.93k]
  ------------------
  378|  75.4k|    h = 17 * h + (int)(*p & 0xff);
  379|  75.4k|  }
  380|  5.93k|  return (int)(h % size);
  381|  5.93k|}

_ZN5GListC2Ev:
   21|  8.90k|GList::GList() {
   22|  8.90k|  size = 8;
   23|  8.90k|  data = (void **)gmallocn(size, sizeof(void*));
   24|  8.90k|  length = 0;
   25|  8.90k|  inc = 0;
   26|  8.90k|}
_ZN5GListD2Ev:
   35|  8.90k|GList::~GList() {
   36|  8.90k|  gfree(data);
   37|  8.90k|}
_ZN5GList6appendEPv:
   49|  17.4k|void GList::append(void *p) {
   50|  17.4k|  if (length >= size) {
  ------------------
  |  Branch (50:7): [True: 516, False: 16.8k]
  ------------------
   51|    516|    expand();
   52|    516|  }
   53|  17.4k|  data[length++] = p;
   54|  17.4k|}
_ZN5GList6expandEv:
  116|    516|void GList::expand() {
  117|    516|  size += (inc > 0) ? inc : size;
  ------------------
  |  Branch (117:11): [True: 0, False: 516]
  ------------------
  118|    516|  data = (void **)greallocn(data, size, sizeof(void*));
  119|    516|}

_ZN5GList9getLengthEv:
   35|  26.3k|  int getLength() { return length; }
_ZN5GList3getEi:
   44|  17.4k|  void *get(int i) { return data[i]; }

_ZN7GStringC2Ev:
  129|  4.90k|GString::GString() {
  130|  4.90k|  s = NULL;
  131|  4.90k|  resize(length = 0);
  132|  4.90k|  s[0] = '\0';
  133|  4.90k|}
_ZN7GStringC2EPKc:
  135|  23.2k|GString::GString(const char *sA) {
  136|  23.2k|  int n = (int)strlen(sA);
  137|       |
  138|  23.2k|  s = NULL;
  139|  23.2k|  resize(length = n);
  140|  23.2k|  memcpy(s, sA, n + 1);
  141|  23.2k|}
_ZN7GString7formatvEPKcP13__va_list_tag:
  196|  2.45k|GString *GString::formatv(const char *fmt, va_list argList) {
  197|  2.45k|  GString *s;
  198|       |
  199|  2.45k|  s = new GString();
  200|  2.45k|  s->appendfv(fmt, argList);
  201|  2.45k|  return s;
  202|  2.45k|}
_ZN7GStringD2Ev:
  204|  28.1k|GString::~GString() {
  205|  28.1k|  delete[] s;
  206|  28.1k|}
_ZN7GString6appendEc:
  214|  96.6k|GString *GString::append(char c) {
  215|  96.6k|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 96.6k]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|  96.6k|  resize(length + 1);
  219|  96.6k|  s[length++] = c;
  220|  96.6k|  s[length] = '\0';
  221|  96.6k|  return this;
  222|  96.6k|}
_ZN7GString6appendEPKc:
  236|  9.67k|GString *GString::append(const char *str) {
  237|  9.67k|  int n = (int)strlen(str);
  238|       |
  239|  9.67k|  if (length > INT_MAX - n) {
  ------------------
  |  Branch (239:7): [True: 0, False: 9.67k]
  ------------------
  240|      0|    gMemError("Integer overflow in GString::append()");
  241|      0|  }
  242|  9.67k|  resize(length + n);
  243|  9.67k|  memcpy(s + length, str, n + 1);
  244|  9.67k|  length += n;
  245|  9.67k|  return this;
  246|  9.67k|}
_ZN7GString6appendEPKci:
  248|  6.78k|GString *GString::append(const char *str, int lengthA) {
  249|  6.78k|  if (lengthA < 0 || length > INT_MAX - lengthA) {
  ------------------
  |  Branch (249:7): [True: 0, False: 6.78k]
  |  Branch (249:22): [True: 0, False: 6.78k]
  ------------------
  250|      0|    gMemError("Integer overflow in GString::append()");
  251|      0|  }
  252|  6.78k|  resize(length + lengthA);
  253|  6.78k|  memcpy(s + length, str, lengthA);
  254|  6.78k|  length += lengthA;
  255|  6.78k|  s[length] = '\0';
  256|  6.78k|  return this;
  257|  6.78k|}
_ZN7GString7appendfEPKcz:
  259|    221|GString *GString::appendf(const char *fmt, ...) {
  260|    221|  va_list argList;
  261|       |
  262|    221|  va_start(argList, fmt);
  263|    221|  appendfv(fmt, argList);
  264|    221|  va_end(argList);
  265|    221|  return this;
  266|    221|}
_ZN7GString8appendfvEPKcP13__va_list_tag:
  268|  2.67k|GString *GString::appendfv(const char *fmt, va_list argList) {
  269|  2.67k|  GStringFormatArg *args;
  270|  2.67k|  int argsLen, argsSize;
  271|  2.67k|  GStringFormatArg arg;
  272|  2.67k|  int idx, width, prec;
  273|  2.67k|  GBool reverseAlign, zeroFill;
  274|  2.67k|  GStringFormatType ft;
  275|  2.67k|  char buf[65];
  276|  2.67k|  int len, i;
  277|  2.67k|  const char *p0, *p1;
  278|  2.67k|  const char *str;
  279|       |
  280|  2.67k|  argsLen = 0;
  281|  2.67k|  argsSize = 8;
  282|  2.67k|  args = (GStringFormatArg *)gmallocn(argsSize, sizeof(GStringFormatArg));
  283|       |
  284|  2.67k|  p0 = fmt;
  285|  9.45k|  while (*p0) {
  ------------------
  |  Branch (285:10): [True: 6.78k, False: 2.67k]
  ------------------
  286|  6.78k|    if (*p0 == '{') {
  ------------------
  |  Branch (286:9): [True: 2.05k, False: 4.72k]
  ------------------
  287|  2.05k|      ++p0;
  288|  2.05k|      if (*p0 == '{') {
  ------------------
  |  Branch (288:11): [True: 0, False: 2.05k]
  ------------------
  289|      0|	++p0;
  290|      0|	append('{');
  291|  2.05k|      } else {
  292|       |
  293|       |	// parse the format string
  294|  2.05k|	if (!(*p0 >= '0' && *p0 <= '9')) {
  ------------------
  |  Branch (294:8): [True: 2.05k, False: 0]
  |  Branch (294:22): [True: 2.05k, False: 0]
  ------------------
  295|      0|	  break;
  296|      0|	}
  297|  2.05k|	idx = *p0 - '0';
  298|  2.05k|	for (++p0; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (298:13): [True: 2.05k, False: 0]
  |  Branch (298:27): [True: 0, False: 2.05k]
  ------------------
  299|      0|	  idx = 10 * idx + (*p0 - '0');
  300|      0|	}
  301|  2.05k|	if (*p0 != ':') {
  ------------------
  |  Branch (301:6): [True: 0, False: 2.05k]
  ------------------
  302|      0|	  break;
  303|      0|	}
  304|  2.05k|	++p0;
  305|  2.05k|	if (*p0 == '-') {
  ------------------
  |  Branch (305:6): [True: 0, False: 2.05k]
  ------------------
  306|      0|	  reverseAlign = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  307|      0|	  ++p0;
  308|  2.05k|	} else {
  309|  2.05k|	  reverseAlign = gFalse;
  ------------------
  |  |   18|  2.05k|#define gFalse 0
  ------------------
  310|  2.05k|	}
  311|  2.05k|	width = 0;
  312|  2.05k|	zeroFill = *p0 == '0';
  313|  2.49k|	for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (313:9): [True: 2.49k, False: 0]
  |  Branch (313:23): [True: 442, False: 2.05k]
  ------------------
  314|    442|	  width = 10 * width + (*p0 - '0');
  315|    442|	}
  316|  2.05k|	if (width < 0) {
  ------------------
  |  Branch (316:6): [True: 0, False: 2.05k]
  ------------------
  317|      0|	  width = 0;
  318|      0|	}
  319|  2.05k|	if (*p0 == '.') {
  ------------------
  |  Branch (319:6): [True: 0, False: 2.05k]
  ------------------
  320|      0|	  ++p0;
  321|      0|	  prec = 0;
  322|      0|	  for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  |  Branch (322:25): [True: 0, False: 0]
  ------------------
  323|      0|	    prec = 10 * prec + (*p0 - '0');
  324|      0|	  }
  325|  2.05k|	} else {
  326|  2.05k|	  prec = 0;
  327|  2.05k|	}
  328|  2.05k|	for (ft = (GStringFormatType)0;
  329|  51.7k|	     formatStrings[ft];
  ------------------
  |  Branch (329:7): [True: 51.7k, False: 0]
  ------------------
  330|  51.7k|	     ft = (GStringFormatType)(ft + 1)) {
  331|  51.7k|	  if (!strncmp(p0, formatStrings[ft], strlen(formatStrings[ft]))) {
  ------------------
  |  Branch (331:8): [True: 2.05k, False: 49.7k]
  ------------------
  332|  2.05k|	    break;
  333|  2.05k|	  }
  334|  51.7k|	}
  335|  2.05k|	if (!formatStrings[ft]) {
  ------------------
  |  Branch (335:6): [True: 0, False: 2.05k]
  ------------------
  336|      0|	  break;
  337|      0|	}
  338|  2.05k|	p0 += strlen(formatStrings[ft]);
  339|  2.05k|	if (*p0 != '}') {
  ------------------
  |  Branch (339:6): [True: 0, False: 2.05k]
  ------------------
  340|      0|	  break;
  341|      0|	}
  342|  2.05k|	++p0;
  343|       |
  344|       |	// fetch the argument
  345|  2.05k|	if (idx > argsLen) {
  ------------------
  |  Branch (345:6): [True: 0, False: 2.05k]
  ------------------
  346|      0|	  break;
  347|      0|	}
  348|  2.05k|	if (idx == argsLen) {
  ------------------
  |  Branch (348:6): [True: 2.05k, False: 0]
  ------------------
  349|  2.05k|	  if (argsLen == argsSize) {
  ------------------
  |  Branch (349:8): [True: 0, False: 2.05k]
  ------------------
  350|      0|	    argsSize *= 2;
  351|      0|	    args = (GStringFormatArg *)greallocn(args, argsSize,
  352|      0|						 sizeof(GStringFormatArg));
  353|      0|	  }
  354|  2.05k|	  switch (ft) {
  ------------------
  |  Branch (354:12): [True: 0, False: 2.05k]
  ------------------
  355|      0|	  case fmtIntDecimal:
  ------------------
  |  Branch (355:4): [True: 0, False: 2.05k]
  ------------------
  356|    221|	  case fmtIntHex:
  ------------------
  |  Branch (356:4): [True: 221, False: 1.83k]
  ------------------
  357|    221|	  case fmtIntOctal:
  ------------------
  |  Branch (357:4): [True: 0, False: 2.05k]
  ------------------
  358|    221|	  case fmtIntBinary:
  ------------------
  |  Branch (358:4): [True: 0, False: 2.05k]
  ------------------
  359|    221|	  case fmtSpace:
  ------------------
  |  Branch (359:4): [True: 0, False: 2.05k]
  ------------------
  360|    221|	    args[argsLen].i = va_arg(argList, int);
  361|    221|	    break;
  362|      0|	  case fmtUIntDecimal:
  ------------------
  |  Branch (362:4): [True: 0, False: 2.05k]
  ------------------
  363|      0|	  case fmtUIntHex:
  ------------------
  |  Branch (363:4): [True: 0, False: 2.05k]
  ------------------
  364|      0|	  case fmtUIntOctal:
  ------------------
  |  Branch (364:4): [True: 0, False: 2.05k]
  ------------------
  365|      0|	  case fmtUIntBinary:
  ------------------
  |  Branch (365:4): [True: 0, False: 2.05k]
  ------------------
  366|      0|	    args[argsLen].ui = va_arg(argList, Guint);
  367|      0|	    break;
  368|      0|	  case fmtLongDecimal:
  ------------------
  |  Branch (368:4): [True: 0, False: 2.05k]
  ------------------
  369|      0|	  case fmtLongHex:
  ------------------
  |  Branch (369:4): [True: 0, False: 2.05k]
  ------------------
  370|      0|	  case fmtLongOctal:
  ------------------
  |  Branch (370:4): [True: 0, False: 2.05k]
  ------------------
  371|      0|	  case fmtLongBinary:
  ------------------
  |  Branch (371:4): [True: 0, False: 2.05k]
  ------------------
  372|      0|	    args[argsLen].l = va_arg(argList, long);
  373|      0|	    break;
  374|      0|	  case fmtULongDecimal:
  ------------------
  |  Branch (374:4): [True: 0, False: 2.05k]
  ------------------
  375|      0|	  case fmtULongHex:
  ------------------
  |  Branch (375:4): [True: 0, False: 2.05k]
  ------------------
  376|      0|	  case fmtULongOctal:
  ------------------
  |  Branch (376:4): [True: 0, False: 2.05k]
  ------------------
  377|      0|	  case fmtULongBinary:
  ------------------
  |  Branch (377:4): [True: 0, False: 2.05k]
  ------------------
  378|      0|	    args[argsLen].ul = va_arg(argList, Gulong);
  379|      0|	    break;
  380|      0|#ifdef LLONG_MAX
  381|      0|	  case fmtLongLongDecimal:
  ------------------
  |  Branch (381:4): [True: 0, False: 2.05k]
  ------------------
  382|      0|	  case fmtLongLongHex:
  ------------------
  |  Branch (382:4): [True: 0, False: 2.05k]
  ------------------
  383|      0|	  case fmtLongLongOctal:
  ------------------
  |  Branch (383:4): [True: 0, False: 2.05k]
  ------------------
  384|      0|	  case fmtLongLongBinary:
  ------------------
  |  Branch (384:4): [True: 0, False: 2.05k]
  ------------------
  385|      0|	    args[argsLen].ll = va_arg(argList, long long);
  386|      0|	    break;
  387|      0|#endif
  388|      0|#ifdef ULLONG_MAX
  389|      0|	  case fmtULongLongDecimal:
  ------------------
  |  Branch (389:4): [True: 0, False: 2.05k]
  ------------------
  390|      0|	  case fmtULongLongHex:
  ------------------
  |  Branch (390:4): [True: 0, False: 2.05k]
  ------------------
  391|      0|	  case fmtULongLongOctal:
  ------------------
  |  Branch (391:4): [True: 0, False: 2.05k]
  ------------------
  392|      0|	  case fmtULongLongBinary:
  ------------------
  |  Branch (392:4): [True: 0, False: 2.05k]
  ------------------
  393|      0|	    args[argsLen].ull = va_arg(argList, unsigned long long);
  394|      0|	    break;
  395|      0|#endif
  396|      0|	  case fmtDouble:
  ------------------
  |  Branch (396:4): [True: 0, False: 2.05k]
  ------------------
  397|      0|	  case fmtDoubleTrim:
  ------------------
  |  Branch (397:4): [True: 0, False: 2.05k]
  ------------------
  398|      0|	    args[argsLen].f = va_arg(argList, double);
  399|      0|	    break;
  400|      0|	  case fmtChar:
  ------------------
  |  Branch (400:4): [True: 0, False: 2.05k]
  ------------------
  401|      0|	    args[argsLen].c = (char)va_arg(argList, int);
  402|      0|	    break;
  403|  1.83k|	  case fmtString:
  ------------------
  |  Branch (403:4): [True: 1.83k, False: 221]
  ------------------
  404|  1.83k|	    args[argsLen].s = va_arg(argList, char *);
  405|  1.83k|	    break;
  406|      0|	  case fmtGString:
  ------------------
  |  Branch (406:4): [True: 0, False: 2.05k]
  ------------------
  407|      0|	    args[argsLen].gs = va_arg(argList, GString *);
  408|      0|	    break;
  409|  2.05k|	  }
  410|  2.05k|	  ++argsLen;
  411|  2.05k|	}
  412|       |
  413|       |	// format the argument
  414|  2.05k|	arg = args[idx];
  415|  2.05k|	str = NULL;
  416|  2.05k|	len = 0;
  417|  2.05k|	switch (ft) {
  ------------------
  |  Branch (417:10): [True: 0, False: 2.05k]
  ------------------
  418|      0|	case fmtIntDecimal:
  ------------------
  |  Branch (418:2): [True: 0, False: 2.05k]
  ------------------
  419|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  420|      0|	  break;
  421|    221|	case fmtIntHex:
  ------------------
  |  Branch (421:2): [True: 221, False: 1.83k]
  ------------------
  422|    221|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  423|    221|	  break;
  424|      0|	case fmtIntOctal:
  ------------------
  |  Branch (424:2): [True: 0, False: 2.05k]
  ------------------
  425|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  426|      0|	  break;
  427|      0|	case fmtIntBinary:
  ------------------
  |  Branch (427:2): [True: 0, False: 2.05k]
  ------------------
  428|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  429|      0|	  break;
  430|      0|	case fmtUIntDecimal:
  ------------------
  |  Branch (430:2): [True: 0, False: 2.05k]
  ------------------
  431|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 10,
  432|      0|		     &str, &len);
  433|      0|	  break;
  434|      0|	case fmtUIntHex:
  ------------------
  |  Branch (434:2): [True: 0, False: 2.05k]
  ------------------
  435|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 16,
  436|      0|		     &str, &len);
  437|      0|	  break;
  438|      0|	case fmtUIntOctal:
  ------------------
  |  Branch (438:2): [True: 0, False: 2.05k]
  ------------------
  439|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  440|      0|	  break;
  441|      0|	case fmtUIntBinary:
  ------------------
  |  Branch (441:2): [True: 0, False: 2.05k]
  ------------------
  442|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  443|      0|	  break;
  444|      0|	case fmtLongDecimal:
  ------------------
  |  Branch (444:2): [True: 0, False: 2.05k]
  ------------------
  445|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  446|      0|	  break;
  447|      0|	case fmtLongHex:
  ------------------
  |  Branch (447:2): [True: 0, False: 2.05k]
  ------------------
  448|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  449|      0|	  break;
  450|      0|	case fmtLongOctal:
  ------------------
  |  Branch (450:2): [True: 0, False: 2.05k]
  ------------------
  451|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  452|      0|	  break;
  453|      0|	case fmtLongBinary:
  ------------------
  |  Branch (453:2): [True: 0, False: 2.05k]
  ------------------
  454|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  455|      0|	  break;
  456|      0|	case fmtULongDecimal:
  ------------------
  |  Branch (456:2): [True: 0, False: 2.05k]
  ------------------
  457|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 10,
  458|      0|		     &str, &len);
  459|      0|	  break;
  460|      0|	case fmtULongHex:
  ------------------
  |  Branch (460:2): [True: 0, False: 2.05k]
  ------------------
  461|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 16,
  462|      0|		     &str, &len);
  463|      0|	  break;
  464|      0|	case fmtULongOctal:
  ------------------
  |  Branch (464:2): [True: 0, False: 2.05k]
  ------------------
  465|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  466|      0|	  break;
  467|      0|	case fmtULongBinary:
  ------------------
  |  Branch (467:2): [True: 0, False: 2.05k]
  ------------------
  468|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  469|      0|	  break;
  470|      0|#ifdef LLONG_MAX
  471|      0|	case fmtLongLongDecimal:
  ------------------
  |  Branch (471:2): [True: 0, False: 2.05k]
  ------------------
  472|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  473|      0|	  break;
  474|      0|	case fmtLongLongHex:
  ------------------
  |  Branch (474:2): [True: 0, False: 2.05k]
  ------------------
  475|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  476|      0|	  break;
  477|      0|	case fmtLongLongOctal:
  ------------------
  |  Branch (477:2): [True: 0, False: 2.05k]
  ------------------
  478|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  479|      0|	  break;
  480|      0|	case fmtLongLongBinary:
  ------------------
  |  Branch (480:2): [True: 0, False: 2.05k]
  ------------------
  481|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  482|      0|	  break;
  483|      0|#endif
  484|      0|#ifdef ULLONG_MAX
  485|      0|	case fmtULongLongDecimal:
  ------------------
  |  Branch (485:2): [True: 0, False: 2.05k]
  ------------------
  486|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 10,
  487|      0|		     &str, &len);
  488|      0|	  break;
  489|      0|	case fmtULongLongHex:
  ------------------
  |  Branch (489:2): [True: 0, False: 2.05k]
  ------------------
  490|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 16,
  491|      0|		     &str, &len);
  492|      0|	  break;
  493|      0|	case fmtULongLongOctal:
  ------------------
  |  Branch (493:2): [True: 0, False: 2.05k]
  ------------------
  494|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 8,
  495|      0|		     &str, &len);
  496|      0|	  break;
  497|      0|	case fmtULongLongBinary:
  ------------------
  |  Branch (497:2): [True: 0, False: 2.05k]
  ------------------
  498|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 2,
  499|      0|		     &str, &len);
  500|      0|	  break;
  501|      0|#endif
  502|      0|	case fmtDouble:
  ------------------
  |  Branch (502:2): [True: 0, False: 2.05k]
  ------------------
  503|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gFalse, &str, &len);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  504|      0|	  break;
  505|      0|	case fmtDoubleTrim:
  ------------------
  |  Branch (505:2): [True: 0, False: 2.05k]
  ------------------
  506|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gTrue, &str, &len);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  507|      0|	  break;
  508|      0|	case fmtChar:
  ------------------
  |  Branch (508:2): [True: 0, False: 2.05k]
  ------------------
  509|      0|	  buf[0] = arg.c;
  510|      0|	  str = buf;
  511|      0|	  len = 1;
  512|      0|	  reverseAlign = !reverseAlign;
  513|      0|	  break;
  514|  1.83k|	case fmtString:
  ------------------
  |  Branch (514:2): [True: 1.83k, False: 221]
  ------------------
  515|  1.83k|	  if (arg.s) {
  ------------------
  |  Branch (515:8): [True: 1.83k, False: 0]
  ------------------
  516|  1.83k|	    str = arg.s;
  517|  1.83k|	    len = (int)strlen(str);
  518|  1.83k|	  } else {
  519|      0|	    str = "(null)";
  520|      0|	    len = 6;
  521|      0|	  }
  522|  1.83k|	  reverseAlign = !reverseAlign;
  523|  1.83k|	  break;
  524|      0|	case fmtGString:
  ------------------
  |  Branch (524:2): [True: 0, False: 2.05k]
  ------------------
  525|      0|	  if (arg.gs) {
  ------------------
  |  Branch (525:8): [True: 0, False: 0]
  ------------------
  526|      0|	    str = arg.gs->getCString();
  527|      0|	    len = arg.gs->getLength();
  528|      0|	  } else {
  529|      0|	    str = "(null)";
  530|      0|	    len = 6;
  531|      0|	  }
  532|      0|	  reverseAlign = !reverseAlign;
  533|      0|	  break;
  534|      0|	case fmtSpace:
  ------------------
  |  Branch (534:2): [True: 0, False: 2.05k]
  ------------------
  535|      0|	  str = buf;
  536|      0|	  len = 0;
  537|      0|	  width = arg.i;
  538|      0|	  break;
  539|  2.05k|	}
  540|       |
  541|       |	// append the formatted arg, handling width and alignment
  542|  2.05k|	if (!reverseAlign && len < width) {
  ------------------
  |  Branch (542:6): [True: 221, False: 1.83k]
  |  Branch (542:23): [True: 0, False: 221]
  ------------------
  543|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (543:18): [True: 0, False: 0]
  ------------------
  544|      0|	    append(' ');
  545|      0|	  }
  546|      0|	}
  547|  2.05k|	append(str, len);
  548|  2.05k|	if (reverseAlign && len < width) {
  ------------------
  |  Branch (548:6): [True: 1.83k, False: 221]
  |  Branch (548:22): [True: 0, False: 1.83k]
  ------------------
  549|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (549:18): [True: 0, False: 0]
  ------------------
  550|      0|	    append(' ');
  551|      0|	  }
  552|      0|	}
  553|  2.05k|      }
  554|       |
  555|  4.72k|    } else if (*p0 == '}') {
  ------------------
  |  Branch (555:16): [True: 0, False: 4.72k]
  ------------------
  556|      0|      ++p0;
  557|      0|      if (*p0 == '}') {
  ------------------
  |  Branch (557:11): [True: 0, False: 0]
  ------------------
  558|      0|	++p0;
  559|      0|      }
  560|      0|      append('}');
  561|       |      
  562|  4.72k|    } else {
  563|  63.8k|      for (p1 = p0 + 1; *p1 && *p1 != '{' && *p1 != '}'; ++p1) ;
  ------------------
  |  Branch (563:25): [True: 61.2k, False: 2.67k]
  |  Branch (563:32): [True: 59.1k, False: 2.05k]
  |  Branch (563:46): [True: 59.1k, False: 0]
  ------------------
  564|  4.72k|      append(p0, (int)(p1 - p0));
  565|  4.72k|      p0 = p1;
  566|  4.72k|    }
  567|  6.78k|  }
  568|       |
  569|  2.67k|  gfree(args);
  570|  2.67k|  return this;
  571|  2.67k|}
_ZN7GString9formatIntExPciiiiPPKcPi:
  576|    221|			const char **p, int *len) {
  577|       |#else
  578|       |void GString::formatInt(long x, char *buf, int bufSize,
  579|       |			GBool zeroFill, int width, int base,
  580|       |			const char **p, int *len) {
  581|       |#endif
  582|    221|  static char vals[17] = "0123456789abcdef";
  583|    221|  GBool neg;
  584|    221|  int start, i, j;
  585|       |
  586|    221|  i = bufSize;
  587|    221|  if ((neg = x < 0)) {
  ------------------
  |  Branch (587:7): [True: 0, False: 221]
  ------------------
  588|      0|    x = -x;
  589|      0|  }
  590|    221|  start = neg ? 1 : 0;
  ------------------
  |  Branch (590:11): [True: 0, False: 221]
  ------------------
  591|    221|  if (x == 0) {
  ------------------
  |  Branch (591:7): [True: 0, False: 221]
  ------------------
  592|      0|    buf[--i] = '0';
  593|    221|  } else {
  594|    661|    while (i > start && x) {
  ------------------
  |  Branch (594:12): [True: 661, False: 0]
  |  Branch (594:25): [True: 440, False: 221]
  ------------------
  595|    440|      buf[--i] = vals[x % base];
  596|    440|      x /= base;
  597|    440|    }
  598|    221|  }
  599|    221|  if (zeroFill) {
  ------------------
  |  Branch (599:7): [True: 221, False: 0]
  ------------------
  600|    223|    for (j = bufSize - i; i > start && j < width - start; ++j) {
  ------------------
  |  Branch (600:27): [True: 223, False: 0]
  |  Branch (600:40): [True: 2, False: 221]
  ------------------
  601|      2|      buf[--i] = '0';
  602|      2|    }
  603|    221|  }
  604|    221|  if (neg) {
  ------------------
  |  Branch (604:7): [True: 0, False: 221]
  ------------------
  605|      0|    buf[--i] = '-';
  606|      0|  }
  607|    221|  *p = buf + i;
  608|    221|  *len = bufSize - i;
  609|    221|}
_ZN7GString6resizeEi:
  108|   141k|inline void GString::resize(int length1) {
  109|   141k|  char *s1;
  110|       |
  111|   141k|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 141k]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|   141k|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 28.1k, False: 113k]
  ------------------
  115|  28.1k|    s = new char[size(length1)];
  116|   113k|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 16.6k, False: 96.3k]
  ------------------
  117|  16.6k|    s1 = new char[size(length1)];
  118|  16.6k|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 16.6k]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|  16.6k|    } else {
  122|  16.6k|      memcpy(s1, s, length + 1);
  123|  16.6k|    }
  124|  16.6k|    delete[] s;
  125|  16.6k|    s = s1;
  126|  16.6k|  }
  127|   141k|}
GString.cc:_ZL4sizei:
   98|   270k|static inline int size(int len) {
   99|   270k|  int delta;
  100|   703k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 432k, False: 270k]
  |  Branch (100:34): [True: 432k, False: 0]
  ------------------
  101|   270k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 270k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|   270k|  return (len + delta) & ~(delta - 1);
  106|   270k|}

_ZN7GString10getCStringEv:
   79|  12.6k|  char *getCString() { return s; }
_ZN7GString9getLengthEv:
   76|   115k|  int getLength() { return length; }
_ZN7GString7getCharEi:
   82|  96.8k|  char getChar(int i) { return s[i]; }

_Z10getHomeDirv:
   49|    645|GString *getHomeDir() {
   50|       |#ifdef VMS
   51|       |  //---------- VMS ----------
   52|       |  return new GString("SYS$LOGIN:");
   53|       |
   54|       |#elif defined(_WIN32)
   55|       |  //---------- Win32 ----------
   56|       |  char *s;
   57|       |  GString *ret;
   58|       |
   59|       |  if ((s = getenv("USERPROFILE")))
   60|       |    ret = new GString(s);
   61|       |  else
   62|       |    ret = new GString(".");
   63|       |  return ret;
   64|       |
   65|       |#elif defined(__EMX__)
   66|       |  //---------- OS/2+EMX ----------
   67|       |  char *s;
   68|       |  GString *ret;
   69|       |
   70|       |  if ((s = getenv("HOME")))
   71|       |    ret = new GString(s);
   72|       |  else
   73|       |    ret = new GString(".");
   74|       |  return ret;
   75|       |
   76|       |#elif defined(ACORN)
   77|       |  //---------- RISCOS ----------
   78|       |  return new GString("@");
   79|       |
   80|       |#else
   81|       |  //---------- Unix ----------
   82|    645|  char *s;
   83|    645|  struct passwd *pw;
   84|    645|  GString *ret;
   85|       |
   86|    645|  if ((s = getenv("HOME"))) {
  ------------------
  |  Branch (86:7): [True: 645, False: 0]
  ------------------
   87|    645|    ret = new GString(s);
   88|    645|  } else {
   89|      0|    if ((s = getenv("USER")))
  ------------------
  |  Branch (89:9): [True: 0, False: 0]
  ------------------
   90|      0|      pw = getpwnam(s);
   91|      0|    else
   92|      0|      pw = getpwuid(getuid());
   93|      0|    if (pw)
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      ret = new GString(pw->pw_dir);
   95|      0|    else
   96|      0|      ret = new GString(".");
   97|      0|  }
   98|    645|  return ret;
   99|    645|#endif
  100|    645|}
_Z12appendToPathP7GStringPKc:
  118|  9.67k|GString *appendToPath(GString *path, const char *fileName) {
  119|       |#if defined(VMS)
  120|       |  //---------- VMS ----------
  121|       |  //~ this should handle everything necessary for file
  122|       |  //~ requesters, but it's certainly not complete
  123|       |  char *p0, *p1, *p2;
  124|       |  char *q1;
  125|       |
  126|       |  p0 = path->getCString();
  127|       |  p1 = p0 + path->getLength() - 1;
  128|       |  if (!strcmp(fileName, "-")) {
  129|       |    if (*p1 == ']') {
  130|       |      for (p2 = p1; p2 > p0 && *p2 != '.' && *p2 != '['; --p2) ;
  131|       |      if (*p2 == '[')
  132|       |	++p2;
  133|       |      path->del(p2 - p0, p1 - p2);
  134|       |    } else if (*p1 == ':') {
  135|       |      path->append("[-]");
  136|       |    } else {
  137|       |      path->clear();
  138|       |      path->append("[-]");
  139|       |    }
  140|       |  } else if ((q1 = strrchr(fileName, '.')) && !strncmp(q1, ".DIR;", 5)) {
  141|       |    if (*p1 == ']') {
  142|       |      path->insert(p1 - p0, '.');
  143|       |      path->insert(p1 - p0 + 1, fileName, q1 - fileName);
  144|       |    } else if (*p1 == ':') {
  145|       |      path->append('[');
  146|       |      path->append(']');
  147|       |      path->append(fileName, q1 - fileName);
  148|       |    } else {
  149|       |      path->clear();
  150|       |      path->append(fileName, q1 - fileName);
  151|       |    }
  152|       |  } else {
  153|       |    if (*p1 != ']' && *p1 != ':')
  154|       |      path->clear();
  155|       |    path->append(fileName);
  156|       |  }
  157|       |  return path;
  158|       |
  159|       |#elif defined(_WIN32)
  160|       |  //---------- Win32 ----------
  161|       |  GString *tmp;
  162|       |  char buf[256];
  163|       |  char *fp;
  164|       |
  165|       |  tmp = new GString(path);
  166|       |  tmp->append('/');
  167|       |  tmp->append(fileName);
  168|       |  GetFullPathNameA(tmp->getCString(), sizeof(buf), buf, &fp);
  169|       |  delete tmp;
  170|       |  path->clear();
  171|       |  path->append(buf);
  172|       |  return path;
  173|       |
  174|       |#elif defined(ACORN)
  175|       |  //---------- RISCOS ----------
  176|       |  char *p;
  177|       |  int i;
  178|       |
  179|       |  path->append(".");
  180|       |  i = path->getLength();
  181|       |  path->append(fileName);
  182|       |  for (p = path->getCString() + i; *p; ++p) {
  183|       |    if (*p == '/') {
  184|       |      *p = '.';
  185|       |    } else if (*p == '.') {
  186|       |      *p = '/';
  187|       |    }
  188|       |  }
  189|       |  return path;
  190|       |
  191|       |#elif defined(__EMX__)
  192|       |  //---------- OS/2+EMX ----------
  193|       |  int i;
  194|       |
  195|       |  // appending "." does nothing
  196|       |  if (!strcmp(fileName, "."))
  197|       |    return path;
  198|       |
  199|       |  // appending ".." goes up one directory
  200|       |  if (!strcmp(fileName, "..")) {
  201|       |    for (i = path->getLength() - 2; i >= 0; --i) {
  202|       |      if (path->getChar(i) == '/' || path->getChar(i) == '\\' ||
  203|       |	  path->getChar(i) == ':')
  204|       |	break;
  205|       |    }
  206|       |    if (i <= 0) {
  207|       |      if (path->getChar(0) == '/' || path->getChar(0) == '\\') {
  208|       |	path->del(1, path->getLength() - 1);
  209|       |      } else if (path->getLength() >= 2 && path->getChar(1) == ':') {
  210|       |	path->del(2, path->getLength() - 2);
  211|       |      } else {
  212|       |	path->clear();
  213|       |	path->append("..");
  214|       |      }
  215|       |    } else {
  216|       |      if (path->getChar(i-1) == ':')
  217|       |	++i;
  218|       |      path->del(i, path->getLength() - i);
  219|       |    }
  220|       |    return path;
  221|       |  }
  222|       |
  223|       |  // otherwise, append "/" and new path component
  224|       |  if (path->getLength() > 0 &&
  225|       |      path->getChar(path->getLength() - 1) != '/' &&
  226|       |      path->getChar(path->getLength() - 1) != '\\')
  227|       |    path->append('/');
  228|       |  path->append(fileName);
  229|       |  return path;
  230|       |
  231|       |#else
  232|       |  //---------- Unix ----------
  233|  9.67k|  int i;
  234|       |
  235|       |  // appending "." does nothing
  236|  9.67k|  if (!strcmp(fileName, "."))
  ------------------
  |  Branch (236:7): [True: 0, False: 9.67k]
  ------------------
  237|      0|    return path;
  238|       |
  239|       |  // appending ".." goes up one directory
  240|  9.67k|  if (!strcmp(fileName, "..")) {
  ------------------
  |  Branch (240:7): [True: 0, False: 9.67k]
  ------------------
  241|      0|    for (i = path->getLength() - 2; i >= 0; --i) {
  ------------------
  |  Branch (241:37): [True: 0, False: 0]
  ------------------
  242|      0|      if (path->getChar(i) == '/')
  ------------------
  |  Branch (242:11): [True: 0, False: 0]
  ------------------
  243|      0|	break;
  244|      0|    }
  245|      0|    if (i <= 0) {
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|      if (path->getChar(0) == '/') {
  ------------------
  |  Branch (246:11): [True: 0, False: 0]
  ------------------
  247|      0|	path->del(1, path->getLength() - 1);
  248|      0|      } else {
  249|      0|	path->clear();
  250|      0|	path->append("..");
  251|      0|      }
  252|      0|    } else {
  253|      0|      path->del(i, path->getLength() - i);
  254|      0|    }
  255|      0|    return path;
  256|      0|  }
  257|       |
  258|       |  // otherwise, append "/" and new path component
  259|  9.67k|  if (path->getLength() > 0 &&
  ------------------
  |  Branch (259:7): [True: 9.67k, False: 0]
  ------------------
  260|  9.67k|      path->getChar(path->getLength() - 1) != '/')
  ------------------
  |  Branch (260:7): [True: 9.67k, False: 0]
  ------------------
  261|  9.67k|    path->append('/');
  262|  9.67k|  path->append(fileName);
  263|  9.67k|  return path;
  264|  9.67k|#endif
  265|  9.67k|}

_Z7gmalloci:
  139|   592k|void *gmalloc(int size) GMEM_EXCEP {
  140|   592k|  void *p;
  141|       |
  142|   592k|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 592k]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|   592k|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 592k]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|   592k|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 592k]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|   592k|  return p;
  152|   592k|}
_Z8greallocPvi:
  155|    526|void *grealloc(void *p, int size) GMEM_EXCEP {
  156|       |#ifdef DEBUG_MEM
  157|       |  GMemHdr *hdr;
  158|       |  void *q;
  159|       |  int oldSize;
  160|       |
  161|       |  if (size < 0) {
  162|       |    gMemError("Invalid memory allocation size");
  163|       |  }
  164|       |  if (size == 0) {
  165|       |    if (p) {
  166|       |      gfree(p);
  167|       |    }
  168|       |    return NULL;
  169|       |  }
  170|       |  if (p) {
  171|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  172|       |    oldSize = (int)hdr->size;
  173|       |    q = gmalloc(size);
  174|       |    memcpy(q, p, size < oldSize ? size : oldSize);
  175|       |    gfree(p);
  176|       |  } else {
  177|       |    q = gmalloc(size);
  178|       |  }
  179|       |  return q;
  180|       |#else
  181|    526|  void *q;
  182|       |
  183|    526|  if (size < 0) {
  ------------------
  |  Branch (183:7): [True: 0, False: 526]
  ------------------
  184|      0|    gMemError("Invalid memory allocation size");
  185|      0|  }
  186|    526|  if (size == 0) {
  ------------------
  |  Branch (186:7): [True: 0, False: 526]
  ------------------
  187|      0|    if (p) {
  ------------------
  |  Branch (187:9): [True: 0, False: 0]
  ------------------
  188|      0|      free(p);
  189|      0|    }
  190|      0|    return NULL;
  191|      0|  }
  192|    526|  if (p) {
  ------------------
  |  Branch (192:7): [True: 516, False: 10]
  ------------------
  193|    516|    q = realloc(p, size);
  194|    516|  } else {
  195|     10|    q = malloc(size);
  196|     10|  }
  197|    526|  if (!q) {
  ------------------
  |  Branch (197:7): [True: 0, False: 526]
  ------------------
  198|      0|    gMemError("Out of memory");
  199|      0|  }
  200|    526|  return q;
  201|    526|#endif
  202|    526|}
_Z8gmallocnii:
  204|  17.0k|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|  17.0k|  int n;
  206|       |
  207|  17.0k|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 17.0k]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|  17.0k|  n = nObjs * objSize;
  211|  17.0k|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 17.0k]
  |  Branch (211:23): [True: 0, False: 17.0k]
  |  Branch (211:36): [True: 0, False: 17.0k]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|  17.0k|  return gmalloc(n);
  215|  17.0k|}
_Z9greallocnPvii:
  291|    526|void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
  292|    526|  int n;
  293|       |
  294|    526|  if (nObjs == 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 526]
  ------------------
  295|      0|    if (p) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      gfree(p);
  297|      0|    }
  298|      0|    return NULL;
  299|      0|  }
  300|    526|  n = nObjs * objSize;
  301|    526|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (301:7): [True: 0, False: 526]
  |  Branch (301:23): [True: 0, False: 526]
  |  Branch (301:36): [True: 0, False: 526]
  ------------------
  302|      0|    gMemError("Bogus memory allocation size");
  303|      0|  }
  304|    526|  return grealloc(p, n);
  305|    526|}
_Z5gfreePv:
  307|   593k|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|   593k|  if (p) {
  ------------------
  |  Branch (348:7): [True: 593k, False: 516]
  ------------------
  349|   593k|    free(p);
  350|   593k|  }
  351|   593k|#endif
  352|   593k|}
_Z10copyStringPKc:
  390|   575k|char *copyString(const char *s) {
  391|   575k|  char *s1;
  392|       |
  393|   575k|  s1 = (char *)gmalloc((int)strlen(s) + 1);
  394|   575k|  strcpy(s1, s);
  395|   575k|  return s1;
  396|   575k|}

_ZN5ArrayC2EP4XRef:
   22|     10|Array::Array(XRef *xrefA) {
   23|     10|  xref = xrefA;
   24|     10|  elems = NULL;
   25|     10|  size = length = 0;
   26|     10|  ref = 1;
   27|     10|}
_ZN5ArrayD2Ev:
   29|     10|Array::~Array() {
   30|     10|  int i;
   31|       |
   32|     20|  for (i = 0; i < length; ++i)
  ------------------
  |  Branch (32:15): [True: 10, False: 10]
  ------------------
   33|     10|    elems[i].free();
   34|     10|  gfree(elems);
   35|     10|}
_ZN5Array3addEP6Object:
   37|     10|void Array::add(Object *elem) {
   38|     10|  if (length == size) {
  ------------------
  |  Branch (38:7): [True: 10, False: 0]
  ------------------
   39|     10|    if (length == 0) {
  ------------------
  |  Branch (39:9): [True: 10, False: 0]
  ------------------
   40|     10|      size = 8;
   41|     10|    } else {
   42|      0|      size *= 2;
   43|      0|    }
   44|     10|    elems = (Object *)greallocn(elems, size, sizeof(Object));
   45|     10|  }
   46|     10|  elems[length] = *elem;
   47|     10|  ++length;
   48|     10|}

_ZN5Array9getLengthEv:
   44|     10|  int getLength() { return length; }

_ZN17BuiltinFontWidthsC2EP16BuiltinFontWidthi:
   20|  1.80k|BuiltinFontWidths::BuiltinFontWidths(BuiltinFontWidth *widths, int sizeA) {
   21|  1.80k|  int i, h;
   22|       |
   23|  1.80k|  size = sizeA;
   24|  1.80k|  tab = (BuiltinFontWidth **)gmallocn(size, sizeof(BuiltinFontWidth *));
   25|   540k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (25:15): [True: 538k, False: 1.80k]
  ------------------
   26|   538k|    tab[i] = NULL;
   27|   538k|  }
   28|   540k|  for (i = 0; i < sizeA; ++i) {
  ------------------
  |  Branch (28:15): [True: 538k, False: 1.80k]
  ------------------
   29|   538k|    h = hash(widths[i].name);
   30|   538k|    widths[i].next = tab[h];
   31|   538k|    tab[h] = &widths[i];
   32|   538k|  }
   33|  1.80k|}
_ZN17BuiltinFontWidthsD2Ev:
   35|  1.80k|BuiltinFontWidths::~BuiltinFontWidths() {
   36|  1.80k|  gfree(tab);
   37|  1.80k|}
_ZN17BuiltinFontWidths4hashEPKc:
   54|   538k|int BuiltinFontWidths::hash(const char *name) {
   55|   538k|  const char *p;
   56|   538k|  unsigned int h;
   57|       |
   58|   538k|  h = 0;
   59|  4.00M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (59:18): [True: 3.46M, False: 538k]
  ------------------
   60|  3.46M|    h = 17 * h + (int)(*p & 0xff);
   61|  3.46M|  }
   62|   538k|  return (int)(h % size);
   63|   538k|}

_Z21initBuiltinFontTablesv:
 4262|    129|void initBuiltinFontTables() {
 4263|    129|  builtinFonts[0].widths = new BuiltinFontWidths(courierWidthsTab, 315);
 4264|    129|  builtinFonts[1].widths = new BuiltinFontWidths(courierBoldWidthsTab, 315);
 4265|    129|  builtinFonts[2].widths = new BuiltinFontWidths(courierBoldObliqueWidthsTab, 315);
 4266|    129|  builtinFonts[3].widths = new BuiltinFontWidths(courierObliqueWidthsTab, 315);
 4267|    129|  builtinFonts[4].widths = new BuiltinFontWidths(helveticaWidthsTab, 315);
 4268|    129|  builtinFonts[5].widths = new BuiltinFontWidths(helveticaBoldWidthsTab, 316);
 4269|    129|  builtinFonts[6].widths = new BuiltinFontWidths(helveticaBoldObliqueWidthsTab, 315);
 4270|    129|  builtinFonts[7].widths = new BuiltinFontWidths(helveticaObliqueWidthsTab, 315);
 4271|    129|  builtinFonts[8].widths = new BuiltinFontWidths(symbolWidthsTab, 190);
 4272|    129|  builtinFonts[9].widths = new BuiltinFontWidths(timesBoldWidthsTab, 315);
 4273|    129|  builtinFonts[10].widths = new BuiltinFontWidths(timesBoldItalicWidthsTab, 315);
 4274|    129|  builtinFonts[11].widths = new BuiltinFontWidths(timesItalicWidthsTab, 315);
 4275|    129|  builtinFonts[12].widths = new BuiltinFontWidths(timesRomanWidthsTab, 315);
 4276|    129|  builtinFonts[13].widths = new BuiltinFontWidths(zapfDingbatsWidthsTab, 202);
 4277|    129|}
_Z21freeBuiltinFontTablesv:
 4279|    129|void freeBuiltinFontTables() {
 4280|    129|  int i;
 4281|       |
 4282|  1.93k|  for (i = 0; i < 14; ++i) {
  ------------------
  |  Branch (4282:15): [True: 1.80k, False: 129]
  ------------------
 4283|  1.80k|    delete builtinFonts[i].widths;
 4284|  1.80k|  }
 4285|    129|}

_ZN9CMapCacheC2Ev:
  387|    129|CMapCache::CMapCache() {
  388|    129|  int i;
  389|       |
  390|    645|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    645|#define cMapCacheSize 4
  ------------------
  |  Branch (390:15): [True: 516, False: 129]
  ------------------
  391|    516|    cache[i] = NULL;
  392|    516|  }
  393|    129|}
_ZN9CMapCacheD2Ev:
  395|    129|CMapCache::~CMapCache() {
  396|    129|  int i;
  397|       |
  398|    645|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    645|#define cMapCacheSize 4
  ------------------
  |  Branch (398:15): [True: 516, False: 129]
  ------------------
  399|    516|    if (cache[i]) {
  ------------------
  |  Branch (399:9): [True: 0, False: 516]
  ------------------
  400|      0|      cache[i]->decRefCnt();
  401|      0|    }
  402|    516|  }
  403|    129|}

_ZN22CharCodeToUnicodeCacheC2Ei:
  709|    258|CharCodeToUnicodeCache::CharCodeToUnicodeCache(int sizeA) {
  710|    258|  int i;
  711|       |
  712|    258|  size = sizeA;
  713|    258|  cache = (CharCodeToUnicode **)gmallocn(size, sizeof(CharCodeToUnicode *));
  714|  1.29k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (714:15): [True: 1.03k, False: 258]
  ------------------
  715|  1.03k|    cache[i] = NULL;
  716|  1.03k|  }
  717|    258|}
_ZN22CharCodeToUnicodeCacheD2Ev:
  719|    258|CharCodeToUnicodeCache::~CharCodeToUnicodeCache() {
  720|    258|  int i;
  721|       |
  722|  1.29k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (722:15): [True: 1.03k, False: 258]
  ------------------
  723|  1.03k|    if (cache[i]) {
  ------------------
  |  Branch (723:9): [True: 0, False: 1.03k]
  ------------------
  724|      0|      cache[i]->decRefCnt();
  725|      0|    }
  726|  1.03k|  }
  727|    258|  gfree(cache);
  728|    258|}

_Z5error13ErrorCategorylPKcz:
   46|  2.45k|		 const char *msg, ...) {
   47|  2.45k|  va_list args;
   48|  2.45k|  GString *s, *sanitized;
   49|  2.45k|  char c;
   50|  2.45k|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|  2.45k|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 2.45k, False: 0]
  |  Branch (53:20): [True: 0, False: 2.45k]
  |  Branch (53:36): [True: 0, False: 0]
  ------------------
   54|      0|    return;
   55|      0|  }
   56|  2.45k|  va_start(args, msg);
   57|  2.45k|  s = GString::formatv(msg, args);
   58|  2.45k|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|  2.45k|  sanitized = new GString();
   63|  89.6k|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 87.1k, False: 2.45k]
  ------------------
   64|  87.1k|    c = s->getChar(i);
   65|  87.1k|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 86.9k, False: 221]
  |  Branch (65:22): [True: 86.9k, False: 0]
  ------------------
   66|  86.9k|      sanitized->append(c);
   67|  86.9k|    } else {
   68|    221|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|    221|    }
   70|  87.1k|  }
   71|       |
   72|  2.45k|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 2.45k]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|  2.45k|  } else {
   75|  2.45k|    fflush(stdout);
   76|  2.45k|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 2.45k]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|  2.45k|    } else {
   80|  2.45k|      fprintf(stderr, "%s: %s\n",
   81|  2.45k|	      errorCategoryNames[category], sanitized->getCString());
   82|  2.45k|    }
   83|  2.45k|    fflush(stderr);
   84|  2.45k|  }
   85|       |
   86|  2.45k|  delete s;
   87|  2.45k|  delete sanitized;
   88|  2.45k|}

_ZN11SysFontListC2Ev:
  374|    129|SysFontList::SysFontList() {
  375|    129|  fonts = new GList();
  376|    129|}
_ZN11SysFontListD2Ev:
  378|    129|SysFontList::~SysFontList() {
  379|    129|  deleteGList(fonts, SysFontInfo);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  380|    129|}
_ZN10KeyBindingC2EiiiPKc:
  560|  7.86k|KeyBinding::KeyBinding(int codeA, int modsA, int contextA, const char *cmd0) {
  561|  7.86k|  code = codeA;
  562|  7.86k|  mods = modsA;
  563|  7.86k|  context = contextA;
  564|  7.86k|  cmds = new GList();
  565|  7.86k|  cmds->append(new GString(cmd0));
  566|  7.86k|}
_ZN10KeyBindingD2Ev:
  585|  7.86k|KeyBinding::~KeyBinding() {
  586|  7.86k|  deleteGList(cmds, GString);
  ------------------
  |  |   94|  7.86k|  do {                                              \
  |  |   95|  7.86k|    GList *_list = (list);                          \
  |  |   96|  7.86k|    {                                               \
  |  |   97|  7.86k|      int _i;                                       \
  |  |   98|  15.7k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 7.86k, False: 7.86k]
  |  |  ------------------
  |  |   99|  7.86k|        delete (T*)_list->get(_i);                  \
  |  |  100|  7.86k|      }                                             \
  |  |  101|  7.86k|      delete _list;                                 \
  |  |  102|  7.86k|    }                                               \
  |  |  103|  7.86k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  587|  7.86k|}
_ZN12GlobalParamsC2EPKc:
  607|    129|GlobalParams::GlobalParams(const char *cfgFileName) {
  608|    129|  UnicodeMap *map;
  609|    129|  GString *fileName;
  610|    129|  FILE *f;
  611|    129|  int i;
  612|       |
  613|    129|#if MULTITHREADED
  614|    129|  gInitMutex(&mutex);
  ------------------
  |  |   51|    129|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  615|    129|  gInitMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   51|    129|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  616|    129|  gInitMutex(&cMapCacheMutex);
  ------------------
  |  |   51|    129|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  617|    129|#endif
  618|       |
  619|       |#ifdef _WIN32
  620|       |  tlsWin32ErrorInfo = TlsAlloc();
  621|       |#endif
  622|       |
  623|    129|  initBuiltinFontTables();
  624|       |
  625|       |  // scan the encoding in reverse because we want the lowest-numbered
  626|       |  // index for each char name ('space' is encoded twice)
  627|    129|  macRomanReverseMap = new NameToCharCode();
  628|  33.1k|  for (i = 255; i >= 0; --i) {
  ------------------
  |  Branch (628:17): [True: 33.0k, False: 129]
  ------------------
  629|  33.0k|    if (macRomanEncoding[i]) {
  ------------------
  |  Branch (629:9): [True: 28.7k, False: 4.25k]
  ------------------
  630|  28.7k|      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);
  631|  28.7k|    }
  632|  33.0k|  }
  633|       |
  634|       |#ifdef _WIN32
  635|       |  // baseDir will be set by a call to setBaseDir
  636|       |  baseDir = new GString();
  637|       |#else
  638|    129|  baseDir = appendToPath(getHomeDir(), ".xpdf");
  639|    129|#endif
  640|    129|  configFileVars = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  641|    129|  setDataDirVar();
  642|    129|  nameToUnicode = new NameToCharCode();
  643|    129|  cidToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  644|    129|  unicodeToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  645|    129|  residentUnicodeMaps = new GHash();
  646|    129|  unicodeMaps = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  647|    129|  cMapDirs = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  648|    129|  toUnicodeDirs = new GList();
  649|    129|  unicodeRemapping = new UnicodeRemapping();
  650|    129|  fontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  651|    129|  fontDirs = new GList();
  652|    129|  ccFontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  653|    129|  base14SysFonts = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  654|    129|  sysFonts = new SysFontList();
  655|       |#if HAVE_PAPER_H
  656|       |  const char *paperName;
  657|       |  const struct paper *paperType;
  658|       |  paperinit();
  659|       |  if ((paperName = systempapername())) {
  660|       |    paperType = paperinfo(paperName);
  661|       |    psPaperWidth = (int)paperpswidth(paperType);
  662|       |    psPaperHeight = (int)paperpsheight(paperType);
  663|       |  } else {
  664|       |    error(errConfig, -1, "No paper information available - using defaults");
  665|       |    psPaperWidth = defPaperWidth;
  666|       |    psPaperHeight = defPaperHeight;
  667|       |  }
  668|       |  paperdone();
  669|       |#else
  670|    129|  psPaperWidth = defPaperWidth;
  ------------------
  |  |   46|    129|#define defPaperWidth  612    // American letter (8.5x11")
  ------------------
  671|    129|  psPaperHeight = defPaperHeight;
  ------------------
  |  |   47|    129|#define defPaperHeight 792
  ------------------
  672|    129|#endif
  673|    129|  psImageableLLX = psImageableLLY = 0;
  674|    129|  psImageableURX = psPaperWidth;
  675|    129|  psImageableURY = psPaperHeight;
  676|    129|  psCrop = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  677|    129|  psUseCropBoxAsPage = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  678|    129|  psExpandSmaller = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  679|    129|  psShrinkLarger = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  680|    129|  psCenter = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  681|    129|  psDuplex = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  682|    129|  psLevel = psLevel2;
  683|    129|  psResidentFonts = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  684|    129|  psResidentFonts16 = new GList();
  685|    129|  psResidentFontsCC = new GList();
  686|    129|  psEmbedType1 = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  687|    129|  psEmbedTrueType = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  688|    129|  psEmbedCIDPostScript = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  689|    129|  psEmbedCIDTrueType = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  690|    129|  psFontPassthrough = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  691|    129|  psPreload = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  692|    129|  psOPI = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  693|    129|  psASCIIHex = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  694|    129|  psLZW = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  695|    129|  psUncompressPreloadedImages = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  696|    129|  psMinLineWidth = 0;
  697|    129|  psRasterResolution = 300;
  698|    129|  psRasterMono = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  699|    129|  psRasterSliceSize = 20000000;
  700|    129|  psAlwaysRasterize = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  701|    129|  psNeverRasterize = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  702|    129|  textEncoding = new GString(defaultTextEncoding);
  703|       |#if defined(_WIN32)
  704|       |  textEOL = eolDOS;
  705|       |#else
  706|    129|  textEOL = eolUnix;
  707|    129|#endif
  708|    129|  textPageBreaks = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  709|    129|  textKeepTinyChars = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  710|    129|  initialZoom = new GString("125");
  711|    129|  defaultFitZoom = 0;
  712|    129|  zoomScaleFactor = 1;
  713|    129|  zoomValues = new GList();
  714|    129|  zoomValues->append(new GString("25"));
  715|    129|  zoomValues->append(new GString("50"));
  716|    129|  zoomValues->append(new GString("75"));
  717|    129|  zoomValues->append(new GString("100"));
  718|    129|  zoomValues->append(new GString("110"));
  719|    129|  zoomValues->append(new GString("125"));
  720|    129|  zoomValues->append(new GString("150"));
  721|    129|  zoomValues->append(new GString("175"));
  722|    129|  zoomValues->append(new GString("200"));
  723|    129|  zoomValues->append(new GString("300"));
  724|    129|  zoomValues->append(new GString("400"));
  725|    129|  zoomValues->append(new GString("600"));
  726|    129|  zoomValues->append(new GString("800"));
  727|    129|  initialDisplayMode = new GString("continuous");
  728|    129|  initialToolbarState = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  729|    129|  initialSidebarState = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  730|    129|  initialSidebarWidth = 0;
  731|    129|  initialSelectMode = new GString("linear");
  732|    129|  maxTileWidth = 1500;
  733|    129|  maxTileHeight = 1500;
  734|    129|  tileCacheSize = 10;
  735|    129|  workerThreads = 1;
  736|    129|  enableFreeType = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  737|    129|  disableFreeTypeHinting = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  738|    129|  antialias = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  739|    129|  vectorAntialias = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  740|    129|  imageMaskAntialias = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  741|    129|  antialiasPrinting = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  742|    129|  strokeAdjust = strokeAdjustNormal;
  743|    129|  screenType = screenUnset;
  744|    129|  screenSize = -1;
  745|    129|  screenDotRadius = -1;
  746|    129|  screenGamma = 1.0;
  747|    129|  screenBlackThreshold = 0.0;
  748|    129|  screenWhiteThreshold = 1.0;
  749|    129|  minLineWidth = 0.0;
  750|    129|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  751|    129|  drawAnnotations = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  752|    129|  drawFormFields = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  753|    129|  enableXFA = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  754|    129|  overprintPreview = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  755|    129|  paperColor = new GString("#ffffff");
  756|    129|  matteColor = new GString("#808080");
  757|    129|  fullScreenMatteColor = new GString("#000000");
  758|    129|  selectionColor = new GString("#8080ff");
  759|    129|  reverseVideoInvertImages = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  760|    129|  allowLinksToChangeZoom = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  761|    129|  launchCommand = NULL;
  762|    129|  movieCommand = NULL;
  763|    129|  defaultPrinter = NULL;
  764|    129|  mapNumericCharNames = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  765|    129|  mapUnknownCharNames = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  766|    129|  mapExtTrueTypeFontsViaUnicode = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  767|    129|  useTrueTypeUnicodeMapping = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  768|    129|  ignoreWrongSizeToUnicode = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  769|    129|  droppedFonts = new GHash(gTrue);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  770|    129|  separateRotatedText = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  771|    129|  createDefaultKeyBindings();
  772|    129|  popupMenuCmds = new GList();
  773|    129|  initStateFilePaths();
  774|    129|  saveSessionOnQuit = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  775|    129|  savePageNumbers = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  776|    129|  printCommands = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  777|    129|  printStatusInfo = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  778|    129|  errQuiet = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  779|    129|  debugLogFile = NULL;
  780|       |
  781|    129|  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);
  ------------------
  |  |   71|    129|#define cidToUnicodeCacheSize     4
  ------------------
  782|    129|  unicodeToUnicodeCache =
  783|    129|      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);
  ------------------
  |  |   72|    129|#define unicodeToUnicodeCacheSize 4
  ------------------
  784|    129|  unicodeMapCache = new UnicodeMapCache();
  785|    129|  cMapCache = new CMapCache();
  786|       |
  787|       |  // set up the initial nameToUnicode table
  788|   547k|  for (i = 0; nameToUnicodeTab[i].name; ++i) {
  ------------------
  |  Branch (788:15): [True: 547k, False: 129]
  ------------------
  789|   547k|    nameToUnicode->add(nameToUnicodeTab[i].name, nameToUnicodeTab[i].u);
  790|   547k|  }
  791|       |
  792|       |  // set up the residentUnicodeMaps table
  793|    129|  map = new UnicodeMap("Latin1", gFalse,
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  794|    129|		       latin1UnicodeMapRanges, latin1UnicodeMapLen);
  ------------------
  |  |   71|    129|#define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  795|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  796|    129|  map = new UnicodeMap("ASCII7", gFalse,
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  797|    129|		       ascii7UnicodeMapRanges, ascii7UnicodeMapLen);
  ------------------
  |  |  207|    129|#define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  798|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  799|    129|  map = new UnicodeMap("Symbol", gFalse,
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  800|    129|		       symbolUnicodeMapRanges, symbolUnicodeMapLen);
  ------------------
  |  |  332|    129|#define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  801|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  802|    129|  map = new UnicodeMap("ZapfDingbats", gFalse, zapfDingbatsUnicodeMapRanges,
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  803|    129|		       zapfDingbatsUnicodeMapLen);
  ------------------
  |  |  366|    129|#define zapfDingbatsUnicodeMapLen (sizeof(zapfDingbatsUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  804|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  805|    129|  map = new UnicodeMap("UTF-8", gTrue, &mapUTF8);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  806|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  807|    129|  map = new UnicodeMap("UCS-2", gTrue, &mapUCS2);
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  808|    129|  residentUnicodeMaps->add(map->getEncodingName(), map);
  809|       |
  810|       |  // look for a user config file, then a system-wide config file
  811|    129|  f = NULL;
  812|    129|  fileName = NULL;
  813|    129|  if (cfgFileName && cfgFileName[0]) {
  ------------------
  |  Branch (813:7): [True: 0, False: 129]
  |  Branch (813:22): [True: 0, False: 0]
  ------------------
  814|      0|    fileName = new GString(cfgFileName);
  815|      0|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (815:9): [True: 0, False: 0]
  ------------------
  816|      0|      delete fileName;
  817|      0|    }
  818|      0|  }
  819|    129|  if (!f) {
  ------------------
  |  Branch (819:7): [True: 129, False: 0]
  ------------------
  820|    129|    fileName = appendToPath(getHomeDir(), xpdfUserConfigFile);
  ------------------
  |  |   58|    129|#define xpdfUserConfigFile ".xpdfrc"
  ------------------
  821|    129|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (821:9): [True: 129, False: 0]
  ------------------
  822|    129|      delete fileName;
  823|    129|    }
  824|    129|  }
  825|    129|  if (!f) {
  ------------------
  |  Branch (825:7): [True: 129, False: 0]
  ------------------
  826|       |#ifdef _WIN32
  827|       |    char buf[512];
  828|       |    i = GetModuleFileNameA(NULL, buf, sizeof(buf));
  829|       |    if (i <= 0 || i >= sizeof(buf)) {
  830|       |      // error or path too long for buffer - just use the current dir
  831|       |      buf[0] = '\0';
  832|       |    }
  833|       |    fileName = grabPath(buf);
  834|       |    appendToPath(fileName, xpdfSysConfigFile);
  835|       |#else
  836|    129|    fileName = new GString(xpdfSysConfigFile);
  ------------------
  |  |   69|    129|#define xpdfSysConfigFile "/etc/xpdfrc"
  ------------------
  837|    129|#endif
  838|    129|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (838:9): [True: 129, False: 0]
  ------------------
  839|    129|      delete fileName;
  840|    129|    }
  841|    129|  }
  842|    129|  if (f) {
  ------------------
  |  Branch (842:7): [True: 0, False: 129]
  ------------------
  843|      0|    parseFile(fileName, f);
  844|      0|    delete fileName;
  845|      0|    fclose(f);
  846|      0|  }
  847|    129|}
_ZN12GlobalParams13setDataDirVarEv:
  849|    129|void GlobalParams::setDataDirVar() {
  850|    129|  GString *dir;
  851|       |
  852|       |#if defined(XPDFRC_DATADIR)
  853|       |  dir = new GString(XPDFRC_DATADIR);
  854|       |#elif defined(_WIN32)
  855|       |  wchar_t buf[512];
  856|       |  DWORD n = GetModuleFileNameW(NULL, buf, sizeof(buf) / sizeof(wchar_t));
  857|       |  if (n <= 0 || n >= sizeof(buf)) {
  858|       |    // error or path too long for buffer - just use the current dir
  859|       |    buf[0] = L'\0';
  860|       |  }
  861|       |  GString *path = fileNameToUTF8(buf);
  862|       |  dir = grabPath(path->getCString());
  863|       |  delete path;
  864|       |  appendToPath(dir, "data");
  865|       |#else
  866|       |  //~ may be useful to allow the options of using the install dir
  867|       |  //~   and/or the user's home dir (?)
  868|    129|  dir = new GString("./data");
  869|    129|#endif
  870|       |
  871|    129|  configFileVars->add(new GString("DATADIR"), dir);
  872|    129|}
_ZN12GlobalParams24createDefaultKeyBindingsEv:
  874|    129|void GlobalParams::createDefaultKeyBindings() {
  875|    129|  keyBindings = new GList();
  876|       |
  877|       |  //----- mouse buttons
  878|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  147|    129|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  879|    129|				     xpdfKeyContextAny, "startSelection"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  880|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  147|    129|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  193|    129|#define xpdfKeyModShift           (1 << 0)
  ------------------
  881|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  882|    129|				     "startExtendedSelection"));
  883|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  156|    129|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  884|    129|				     xpdfKeyContextAny, "endSelection"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  885|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  156|    129|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  193|    129|#define xpdfKeyModShift           (1 << 0)
  ------------------
  886|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  887|    129|				     "endSelection"));
  888|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseDoubleClick1,
  ------------------
  |  |  174|    129|#define xpdfKeyCodeMouseDoubleClick1  0x2301
  ------------------
  889|    129|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  890|    129|				     "selectWord"));
  891|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseTripleClick1,
  ------------------
  |  |  183|    129|#define xpdfKeyCodeMouseTripleClick1  0x2401
  ------------------
  892|    129|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  893|    129|				     "selectLine"));
  894|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  165|    129|#define xpdfKeyCodeMouseClick1        0x2201
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  895|    129|				     xpdfKeyContextAny, "followLinkNoSel"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  896|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  166|    129|#define xpdfKeyCodeMouseClick2        0x2202
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  897|    129|				     xpdfKeyContextOverLink,
  ------------------
  |  |  201|    129|#define xpdfKeyContextOverLink    (1 << 4)
  ------------------
  898|    129|				     "followLinkInNewTab"));
  899|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  148|    129|#define xpdfKeyCodeMousePress2        0x2002
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  900|    129|				     xpdfKeyContextAny, "startPan"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  901|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  157|    129|#define xpdfKeyCodeMouseRelease2      0x2102
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  902|    129|				     xpdfKeyContextAny, "endPan"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  903|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  149|    129|#define xpdfKeyCodeMousePress3        0x2003
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  904|    129|				     xpdfKeyContextAny, "postPopupMenu"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  905|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  150|    129|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  906|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  907|    129|				     "scrollUpPrevPage(16)"));
  908|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  151|    129|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  909|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  910|    129|				     "scrollDownNextPage(16)"));
  911|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  152|    129|#define xpdfKeyCodeMousePress6        0x2006
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  912|    129|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  913|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  153|    129|#define xpdfKeyCodeMousePress7        0x2007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  914|    129|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  915|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  150|    129|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  916|    129|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  917|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  151|    129|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  918|    129|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  919|       |
  920|       |  //----- control keys
  921|    129|  keyBindings->append(new KeyBinding('o', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  922|    129|				     xpdfKeyContextAny, "open"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  923|    129|  keyBindings->append(new KeyBinding('r', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  924|    129|				     xpdfKeyContextAny, "reload"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  925|    129|  keyBindings->append(new KeyBinding('f', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  926|    129|				     xpdfKeyContextAny, "find"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  927|    129|  keyBindings->append(new KeyBinding('g', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  928|    129|				     xpdfKeyContextAny, "findNext"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  929|    129|  keyBindings->append(new KeyBinding('c', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  930|    129|				     xpdfKeyContextAny, "copy"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  931|    129|  keyBindings->append(new KeyBinding('p', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  932|    129|				     xpdfKeyContextAny, "print"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  933|    129|  keyBindings->append(new KeyBinding('0', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  934|    129|				     xpdfKeyContextAny, "zoomPercent(125)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  935|    129|  keyBindings->append(new KeyBinding('+', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  936|    129|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  937|    129|  keyBindings->append(new KeyBinding('=', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  938|    129|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  939|    129|  keyBindings->append(new KeyBinding('-', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  940|    129|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  941|    129|  keyBindings->append(new KeyBinding('s', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  942|    129|				     xpdfKeyContextAny, "saveAs"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  943|    129|  keyBindings->append(new KeyBinding('t', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  944|    129|				     xpdfKeyContextAny, "newTab"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  945|    129|  keyBindings->append(new KeyBinding('n', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  946|    129|				     xpdfKeyContextAny, "newWindow"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  947|    129|  keyBindings->append(new KeyBinding('w', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  948|    129|				     xpdfKeyContextAny, "closeTabOrQuit"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  949|    129|  keyBindings->append(new KeyBinding('l', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  950|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  951|    129|				     "toggleFullScreenMode"));
  952|    129|  keyBindings->append(new KeyBinding('q', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  953|    129|				     xpdfKeyContextAny, "quit"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  954|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  130|    129|#define xpdfKeyCodeTab                0x1000
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  955|    129|				     xpdfKeyContextAny, "nextTab"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  956|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab,
  ------------------
  |  |  130|    129|#define xpdfKeyCodeTab                0x1000
  ------------------
  957|    129|				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  193|    129|#define xpdfKeyModShift           (1 << 0)
  ------------------
              				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  958|    129|				     xpdfKeyContextAny, "prevTab"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  959|    129|  keyBindings->append(new KeyBinding('?', xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  960|    129|				     xpdfKeyContextAny, "help"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  961|       |
  962|       |  //----- alt keys
  963|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  141|    129|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  195|    129|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  964|    129|				     xpdfKeyContextAny, "goBackward"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  965|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  142|    129|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  195|    129|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  966|    129|				     xpdfKeyContextAny, "goForward"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  967|       |
  968|       |  //----- home/end keys
  969|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  137|    129|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  970|    129|				     xpdfKeyContextAny, "gotoPage(1)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  971|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  137|    129|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  972|    129|				     xpdfKeyContextAny, "scrollToTopLeft"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  973|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  138|    129|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  974|    129|				     xpdfKeyContextAny, "gotoLastPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  975|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  138|    129|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  976|    129|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  977|    129|				     "scrollToBottomRight"));
  978|       |
  979|       |  //----- pgup/pgdn keys
  980|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  139|    129|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  981|    129|				     xpdfKeyContextAny, "pageUp"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  982|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  140|    129|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  983|    129|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  984|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    129|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  985|    129|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  986|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    129|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  987|    129|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
  988|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    129|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  989|    129|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    129|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  990|    129|				     "prevPageNoScroll"));
  991|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    129|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  992|    129|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    129|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  993|    129|				     "nextPageNoScroll"));
  994|       |
  995|       |  //----- esc key
  996|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  134|    129|#define xpdfKeyCodeEsc                0x1004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
  997|    129|				     xpdfKeyContextFullScreen,
  ------------------
  |  |  197|    129|#define xpdfKeyContextFullScreen  (1 << 0)
  ------------------
  998|    129|				     "windowMode"));
  999|       |
 1000|       |  //----- arrow keys
 1001|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  141|    129|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1002|    129|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1003|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  142|    129|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1004|    129|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1005|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  143|    129|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1006|    129|				     xpdfKeyContextAny, "scrollUp(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1007|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  144|    129|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1008|    129|				     xpdfKeyContextAny, "scrollDown(16)"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1009|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    129|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1010|    129|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1011|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    129|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1012|    129|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1013|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    129|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1014|    129|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    129|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1015|    129|				     "prevPageNoScroll"));
 1016|    129|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    129|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    129|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1017|    129|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    129|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1018|    129|				     "nextPageNoScroll"));
 1019|       |
 1020|       |  //----- letter keys
 1021|    129|  keyBindings->append(new KeyBinding(' ', xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1022|    129|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1023|    129|  keyBindings->append(new KeyBinding('g', xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1024|    129|				     xpdfKeyContextAny, "focusToPageNum"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1025|    129|  keyBindings->append(new KeyBinding('z', xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1026|    129|				     xpdfKeyContextAny, "zoomFitPage"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1027|    129|  keyBindings->append(new KeyBinding('w', xpdfKeyModNone,
  ------------------
  |  |  192|    129|#define xpdfKeyModNone            0
  ------------------
 1028|    129|				     xpdfKeyContextAny, "zoomFitWidth"));
  ------------------
  |  |  196|    129|#define xpdfKeyContextAny         0
  ------------------
 1029|    129|}
_ZN12GlobalParams18initStateFilePathsEv:
 1031|    129|void GlobalParams::initStateFilePaths() {
 1032|       |#ifdef _WIN32
 1033|       |  char path[MAX_PATH];
 1034|       |  if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL,
 1035|       |		       SHGFP_TYPE_CURRENT, path) != S_OK) {
 1036|       |    return;
 1037|       |  }
 1038|       |  GString *dir = appendToPath(new GString(path), "xpdf");
 1039|       |  CreateDirectoryA(dir->getCString(), NULL);
 1040|       |  pagesFile = appendToPath(dir->copy(), "xpdf.pages");
 1041|       |  tabStateFile = appendToPath(dir->copy(), "xpdf.tab-state");
 1042|       |  sessionFile = appendToPath(dir, "xpdf.session");
 1043|       |#else
 1044|    129|  pagesFile = appendToPath(getHomeDir(), ".xpdf.pages");
 1045|    129|  tabStateFile = appendToPath(getHomeDir(), ".xpdf.tab-state");
 1046|    129|  sessionFile = appendToPath(getHomeDir(), ".xpdf.session");
 1047|    129|#endif
 1048|    129|}
_ZN12GlobalParams11parseYesNo2EPcPi:
 2092|    129|GBool GlobalParams::parseYesNo2(char *token, GBool *flag) {
 2093|    129|  if (!strcmp(token, "yes")) {
  ------------------
  |  Branch (2093:7): [True: 129, False: 0]
  ------------------
 2094|    129|    *flag = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
 2095|    129|  } else if (!strcmp(token, "no")) {
  ------------------
  |  Branch (2095:14): [True: 0, False: 0]
  ------------------
 2096|      0|    *flag = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2097|      0|  } else {
 2098|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2099|      0|  }
 2100|    129|  return gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
 2101|    129|}
_ZN12GlobalParamsD2Ev:
 2179|    129|GlobalParams::~GlobalParams() {
 2180|    129|  GHashIter *iter;
 2181|    129|  GString *key;
 2182|    129|  GList *list;
 2183|       |
 2184|    129|  freeBuiltinFontTables();
 2185|       |
 2186|    129|  delete macRomanReverseMap;
 2187|       |
 2188|    129|  delete baseDir;
 2189|    129|  deleteGHash(configFileVars, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    258|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 129, False: 129]
  |  |  ------------------
  |  |   68|    129|        delete (T*)_p;                             \
  |  |   69|    129|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2190|    129|  delete nameToUnicode;
 2191|    129|  deleteGHash(cidToUnicodes, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2192|    129|  deleteGHash(unicodeToUnicodes, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2193|    129|  deleteGHash(residentUnicodeMaps, UnicodeMap);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    903|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 774, False: 129]
  |  |  ------------------
  |  |   68|    774|        delete (T*)_p;                             \
  |  |   69|    774|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2194|    129|  deleteGHash(unicodeMaps, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2195|    129|  deleteGList(toUnicodeDirs, GString);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2196|    129|  delete unicodeRemapping;
 2197|    129|  deleteGHash(fontFiles, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2198|    129|  deleteGList(fontDirs, GString);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2199|    129|  deleteGHash(ccFontFiles, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2200|    129|  deleteGHash(base14SysFonts, Base14FontInfo);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2201|    129|  delete sysFonts;
 2202|    129|  deleteGHash(psResidentFonts, GString);
  ------------------
  |  |   60|    129|  do {                                             \
  |  |   61|    129|    GHash *_hash = (hash);                         \
  |  |   62|    129|    {                                              \
  |  |   63|    129|      GHashIter *_iter;                            \
  |  |   64|    129|      GString *_key;                               \
  |  |   65|    129|      void *_p;                                    \
  |  |   66|    129|      _hash->startIter(&_iter);                    \
  |  |   67|    129|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 129]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    129|      delete _hash;                                \
  |  |   71|    129|    }                                              \
  |  |   72|    129|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2203|    129|  deleteGList(psResidentFonts16, PSFontParam16);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2204|    129|  deleteGList(psResidentFontsCC, PSFontParam16);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2205|    129|  delete textEncoding;
 2206|    129|  delete initialZoom;
 2207|    129|  deleteGList(zoomValues, GString);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|  1.80k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 1.67k, False: 129]
  |  |  ------------------
  |  |   99|  1.67k|        delete (T*)_list->get(_i);                  \
  |  |  100|  1.67k|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2208|    129|  delete initialDisplayMode;
 2209|    129|  delete initialSelectMode;
 2210|    129|  if (paperColor) {
  ------------------
  |  Branch (2210:7): [True: 129, False: 0]
  ------------------
 2211|    129|    delete paperColor;
 2212|    129|  }
 2213|    129|  if (matteColor) {
  ------------------
  |  Branch (2213:7): [True: 129, False: 0]
  ------------------
 2214|    129|    delete matteColor;
 2215|    129|  }
 2216|    129|  if (fullScreenMatteColor) {
  ------------------
  |  Branch (2216:7): [True: 129, False: 0]
  ------------------
 2217|    129|    delete fullScreenMatteColor;
 2218|    129|  }
 2219|    129|  if (selectionColor) {
  ------------------
  |  Branch (2219:7): [True: 129, False: 0]
  ------------------
 2220|    129|    delete selectionColor;
 2221|    129|  }
 2222|    129|  if (launchCommand) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 129]
  ------------------
 2223|      0|    delete launchCommand;
 2224|      0|  }
 2225|    129|  if (movieCommand) {
  ------------------
  |  Branch (2225:7): [True: 0, False: 129]
  ------------------
 2226|      0|    delete movieCommand;
 2227|      0|  }
 2228|    129|  if (defaultPrinter) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 129]
  ------------------
 2229|      0|    delete defaultPrinter;
 2230|      0|  }
 2231|    129|  delete droppedFonts;
 2232|    129|  deleteGList(keyBindings, KeyBinding);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|  7.99k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 7.86k, False: 129]
  |  |  ------------------
  |  |   99|  7.86k|        delete (T*)_list->get(_i);                  \
  |  |  100|  7.86k|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2233|    129|  deleteGList(popupMenuCmds, PopupMenuCmd);
  ------------------
  |  |   94|    129|  do {                                              \
  |  |   95|    129|    GList *_list = (list);                          \
  |  |   96|    129|    {                                               \
  |  |   97|    129|      int _i;                                       \
  |  |   98|    129|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 129]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    129|      delete _list;                                 \
  |  |  102|    129|    }                                               \
  |  |  103|    129|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2234|    129|  delete pagesFile;
 2235|    129|  delete tabStateFile;
 2236|    129|  delete sessionFile;
 2237|    129|  delete debugLogFile;
 2238|       |
 2239|    129|  cMapDirs->startIter(&iter);
 2240|    129|  while (cMapDirs->getNext(&iter, &key, (void **)&list)) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 129]
  ------------------
 2241|      0|    deleteGList(list, GString);
  ------------------
  |  |   94|      0|  do {                                              \
  |  |   95|      0|    GList *_list = (list);                          \
  |  |   96|      0|    {                                               \
  |  |   97|      0|      int _i;                                       \
  |  |   98|      0|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 0]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|      0|      delete _list;                                 \
  |  |  102|      0|    }                                               \
  |  |  103|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2242|      0|  }
 2243|    129|  delete cMapDirs;
 2244|       |
 2245|    129|  delete cidToUnicodeCache;
 2246|    129|  delete unicodeToUnicodeCache;
 2247|    129|  delete unicodeMapCache;
 2248|    129|  delete cMapCache;
 2249|       |
 2250|    129|#if MULTITHREADED
 2251|    129|  gDestroyMutex(&mutex);
  ------------------
  |  |   52|    129|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2252|    129|  gDestroyMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   52|    129|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2253|    129|  gDestroyMutex(&cMapCacheMutex);
  ------------------
  |  |   52|    129|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2254|    129|#endif
 2255|    129|}
_ZN12GlobalParams14setupBaseFontsEPKc:
 2347|    129|void GlobalParams::setupBaseFonts(const char *dir) {
 2348|    129|  GString *fontName;
 2349|    129|  GString *fileName;
 2350|    129|  int fontNum;
 2351|    129|  const char *s;
 2352|    129|  Base14FontInfo *base14;
 2353|       |#ifdef _WIN32
 2354|       |  char winFontDir[MAX_PATH];
 2355|       |#endif
 2356|       |#ifdef __APPLE__
 2357|       |  static const char *macFontExts[3] = { "dfont", "ttc", "ttf" };
 2358|       |  GList *dfontFontNames;
 2359|       |  GBool found;
 2360|       |  int k;
 2361|       |#endif
 2362|    129|  FILE *f;
 2363|    129|  int i, j;
 2364|       |
 2365|       |#ifdef _WIN32
 2366|       |  getWinFontDir(winFontDir);
 2367|       |#endif
 2368|       |#ifdef __APPLE__
 2369|       |  dfontFontNames = NULL;
 2370|       |#endif
 2371|  1.93k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2371:15): [True: 1.80k, False: 129]
  ------------------
 2372|  1.80k|    if (fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 1.80k]
  ------------------
 2373|      0|      continue;
 2374|      0|    }
 2375|  1.80k|    fontName = new GString(displayFontTab[i].name);
 2376|  1.80k|    fileName = NULL;
 2377|  1.80k|    fontNum = 0;
 2378|  1.80k|    if (dir) {
  ------------------
  |  Branch (2378:9): [True: 0, False: 1.80k]
  ------------------
 2379|      0|      fileName = appendToPath(new GString(dir), displayFontTab[i].t1FileName);
 2380|      0|      if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2380:11): [True: 0, False: 0]
  ------------------
 2381|      0|	fclose(f);
 2382|      0|      } else {
 2383|      0|	delete fileName;
 2384|      0|	fileName = NULL;
 2385|      0|      }
 2386|      0|    }
 2387|       |#ifdef _WIN32
 2388|       |    if (!fileName && winFontDir[0] && displayFontTab[i].ttFileName) {
 2389|       |      fileName = appendToPath(new GString(winFontDir),
 2390|       |			      displayFontTab[i].ttFileName);
 2391|       |      if ((f = fopen(fileName->getCString(), "rb"))) {
 2392|       |	fclose(f);
 2393|       |      } else {
 2394|       |	delete fileName;
 2395|       |	fileName = NULL;
 2396|       |      }
 2397|       |    }
 2398|       |#endif
 2399|       |#ifdef __APPLE__
 2400|       |    // Check for Mac OS X system fonts.
 2401|       |    s = displayFontTab[i].macFileName;
 2402|       |    if (dfontFontNames && i > 0 &&
 2403|       |	(!s || strcmp(s, displayFontTab[i-1].macFileName))) {
 2404|       |      deleteGList(dfontFontNames, GString);
 2405|       |      dfontFontNames = NULL;
 2406|       |    }
 2407|       |    if (!fileName && s) {
 2408|       |      for (j = 0; j < 3; ++j) {
 2409|       |	fileName = GString::format("{0:s}/{1:s}.{2:s}",
 2410|       |				   macSystemFontPath, s, macFontExts[j]);
 2411|       |	if (!(f = fopen(fileName->getCString(), "rb"))) {
 2412|       |	  delete fileName;
 2413|       |	  fileName = NULL;
 2414|       |	} else {
 2415|       |	  fclose(f);
 2416|       |	  found = gFalse;
 2417|       |	  // for .dfont or .ttc, we need to scan the font list
 2418|       |	  if (j < 2) {
 2419|       |	    if (!dfontFontNames) {
 2420|       |	      dfontFontNames =
 2421|       |	          FoFiIdentifier::getFontList(fileName->getCString());
 2422|       |	    }
 2423|       |	    if (dfontFontNames) {
 2424|       |	      for (k = 0; k < dfontFontNames->getLength(); ++k) {
 2425|       |		if (macFontNameMatches((GString *)dfontFontNames->get(k),
 2426|       |				       displayFontTab[i].macFontName)) {
 2427|       |		  fontNum = k;
 2428|       |		  found = gTrue;
 2429|       |		  break;
 2430|       |		}
 2431|       |	      }
 2432|       |	    }
 2433|       |	  // for .ttf, we just use the font
 2434|       |	  } else {
 2435|       |	    found = gTrue;
 2436|       |	  }
 2437|       |	  if (!found) {
 2438|       |	    delete fileName;
 2439|       |	    fileName = NULL;
 2440|       |	  }
 2441|       |	  break;
 2442|       |	}
 2443|       |      }
 2444|       |    }
 2445|       |#endif // __APPLE__
 2446|       |    // On Linux, this checks the "standard" ghostscript font
 2447|       |    // directories.  On Windows, it checks the "standard" system font
 2448|       |    // directories (because SHGetSpecialFolderPath(CSIDL_FONTS)
 2449|       |    // doesn't work on Win 2k Server or Win2003 Server, or with older
 2450|       |    // versions of shell32.dll).
 2451|       |#ifdef _WIN32
 2452|       |    s = displayFontTab[i].ttFileName;
 2453|       |#else
 2454|  1.80k|    s = displayFontTab[i].t1FileName;
 2455|  1.80k|#endif
 2456|  1.80k|    if (!fileName && s) {
  ------------------
  |  Branch (2456:9): [True: 1.80k, False: 0]
  |  Branch (2456:22): [True: 1.80k, False: 0]
  ------------------
 2457|  10.8k|      for (j = 0; !fileName && displayFontDirs[j]; ++j) {
  ------------------
  |  Branch (2457:19): [True: 10.8k, False: 0]
  |  Branch (2457:32): [True: 9.03k, False: 1.80k]
  ------------------
 2458|  9.03k|	fileName = appendToPath(new GString(displayFontDirs[j]), s);
 2459|  9.03k|	if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2459:6): [True: 0, False: 9.03k]
  ------------------
 2460|      0|	  fclose(f);
 2461|  9.03k|	} else {
 2462|  9.03k|	  delete fileName;
 2463|  9.03k|	  fileName = NULL;
 2464|  9.03k|	}
 2465|  9.03k|      }
 2466|  1.80k|    }
 2467|  1.80k|    if (!fileName) {
  ------------------
  |  Branch (2467:9): [True: 1.80k, False: 0]
  ------------------
 2468|  1.80k|      delete fontName;
 2469|  1.80k|      continue;
 2470|  1.80k|    }
 2471|      0|    base14SysFonts->add(fontName, new Base14FontInfo(fileName, fontNum, 0));
 2472|      0|  }
 2473|       |#ifdef __APPLE__
 2474|       |  if (dfontFontNames) {
 2475|       |    deleteGList(dfontFontNames, GString);
 2476|       |  }
 2477|       |#endif
 2478|  1.93k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2478:15): [True: 1.80k, False: 129]
  ------------------
 2479|  1.80k|    if (!base14SysFonts->lookup(displayFontTab[i].name) &&
  ------------------
  |  Branch (2479:9): [True: 1.80k, False: 0]
  ------------------
 2480|  1.80k|	!fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2480:2): [True: 1.80k, False: 0]
  ------------------
 2481|  1.80k|      if (displayFontTab[i].obliqueFont &&
  ------------------
  |  Branch (2481:11): [True: 516, False: 1.29k]
  ------------------
 2482|  1.80k|	  ((base14 = (Base14FontInfo *)base14SysFonts
  ------------------
  |  Branch (2482:4): [True: 0, False: 516]
  ------------------
 2483|    516|	                 ->lookup(displayFontTab[i].obliqueFont)))) {
 2484|      0|	base14SysFonts->add(
 2485|      0|	        new GString(displayFontTab[i].name),
 2486|      0|		new Base14FontInfo(base14->fileName->copy(),
 2487|      0|				   base14->fontNum,
 2488|      0|				   displayFontTab[i].obliqueFactor));
 2489|  1.80k|      } else {
 2490|  1.80k|	error(errConfig, -1, "No display font for '{0:s}'",
 2491|  1.80k|	      displayFontTab[i].name);
 2492|  1.80k|      }
 2493|  1.80k|    }
 2494|  1.80k|  }
 2495|       |#ifdef _WIN32
 2496|       |  if (winFontDir[0]) {
 2497|       |    sysFonts->scanWindowsFonts(winFontDir);
 2498|       |  }
 2499|       |#endif
 2500|       |#if HAVE_FONTCONFIG
 2501|       |  sysFonts->scanFontconfigFonts();
 2502|       |#endif
 2503|    129|}
_ZN12GlobalParams17setEnableFreeTypeEPc:
 3888|    129|GBool GlobalParams::setEnableFreeType(char *s) {
 3889|    129|  GBool ok;
 3890|       |
 3891|    129|  lockGlobalParams;
  ------------------
  |  |   50|    129|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    129|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3892|    129|  ok = parseYesNo2(s, &enableFreeType);
 3893|    129|  unlockGlobalParams;
  ------------------
  |  |   53|    129|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    129|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3894|    129|  return ok;
 3895|    129|}
_ZN12GlobalParams11setErrQuietEi:
 4010|    258|void GlobalParams::setErrQuiet(GBool errQuietA) {
 4011|    258|  lockGlobalParams;
  ------------------
  |  |   50|    258|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    258|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 4012|    258|  errQuiet = errQuietA;
 4013|    258|  unlockGlobalParams;
  ------------------
  |  |   53|    258|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    258|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 4014|    258|}

_ZN5LexerC2EP4XRefP6Stream:
   46|     10|Lexer::Lexer(XRef *xref, Stream *str) {
   47|     10|  Object obj;
   48|       |
   49|     10|  curStr.initStream(str);
   50|     10|  streams = new Array(xref);
   51|     10|  streams->add(curStr.copy(&obj));
   52|     10|  strPtr = 0;
   53|     10|  freeArray = gTrue;
  ------------------
  |  |   17|     10|#define gTrue 1
  ------------------
   54|     10|  curStr.streamReset();
   55|     10|}
_ZN5LexerD2Ev:
   75|     10|Lexer::~Lexer() {
   76|     10|  if (!curStr.isNone()) {
  ------------------
  |  Branch (76:7): [True: 0, False: 10]
  ------------------
   77|      0|    curStr.streamClose();
   78|      0|    curStr.free();
   79|      0|  }
   80|     10|  if (freeArray) {
  ------------------
  |  Branch (80:7): [True: 10, False: 0]
  ------------------
   81|     10|    delete streams;
   82|     10|  }
   83|     10|}
_ZN5Lexer7getCharEv:
   85|     30|int Lexer::getChar() {
   86|     30|  int c;
   87|       |
   88|     30|  c = EOF;
   89|     40|  while (!curStr.isNone() && (c = curStr.streamGetChar()) == EOF) {
  ------------------
  |  Branch (89:10): [True: 10, False: 30]
  |  Branch (89:30): [True: 10, False: 0]
  ------------------
   90|     10|    curStr.streamClose();
   91|     10|    curStr.free();
   92|     10|    ++strPtr;
   93|     10|    if (strPtr < streams->getLength()) {
  ------------------
  |  Branch (93:9): [True: 0, False: 10]
  ------------------
   94|      0|      streams->get(strPtr, &curStr);
   95|      0|      curStr.streamReset();
   96|      0|    }
   97|     10|  }
   98|     30|  return c;
   99|     30|}
_ZN5Lexer6getObjEP6Object:
  108|     30|Object *Lexer::getObj(Object *obj) {
  109|     30|  char *p;
  110|     30|  int c, c2;
  111|     30|  GBool comment, neg, doubleMinus, done, invalid;
  112|     30|  int numParen, nErrors;
  113|     30|  int xi;
  114|     30|  double xf, scale;
  115|     30|  GString *s;
  116|     30|  int n, m;
  117|       |
  118|       |  // skip whitespace and comments
  119|     30|  comment = gFalse;
  ------------------
  |  |   18|     30|#define gFalse 0
  ------------------
  120|     30|  while (1) {
  ------------------
  |  Branch (120:10): [Folded - Ignored]
  ------------------
  121|     30|    if ((c = getChar()) == EOF) {
  ------------------
  |  Branch (121:9): [True: 30, False: 0]
  ------------------
  122|     30|      return obj->initEOF();
  123|     30|    }
  124|      0|    if (comment) {
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|      if (c == '\r' || c == '\n')
  ------------------
  |  Branch (125:11): [True: 0, False: 0]
  |  Branch (125:24): [True: 0, False: 0]
  ------------------
  126|      0|	comment = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  127|      0|    } else if (c == '%') {
  ------------------
  |  Branch (127:16): [True: 0, False: 0]
  ------------------
  128|      0|      comment = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  129|      0|    } else if (specialChars[c] != 1) {
  ------------------
  |  Branch (129:16): [True: 0, False: 0]
  ------------------
  130|      0|      break;
  131|      0|    }
  132|      0|  }
  133|       |
  134|       |  // start reading token
  135|      0|  switch (c) {
  136|       |
  137|       |  // number
  138|      0|  case '0': case '1': case '2': case '3': case '4':
  ------------------
  |  Branch (138:3): [True: 0, False: 0]
  |  Branch (138:13): [True: 0, False: 0]
  |  Branch (138:23): [True: 0, False: 0]
  |  Branch (138:33): [True: 0, False: 0]
  |  Branch (138:43): [True: 0, False: 0]
  ------------------
  139|      0|  case '5': case '6': case '7': case '8': case '9':
  ------------------
  |  Branch (139:3): [True: 0, False: 0]
  |  Branch (139:13): [True: 0, False: 0]
  |  Branch (139:23): [True: 0, False: 0]
  |  Branch (139:33): [True: 0, False: 0]
  |  Branch (139:43): [True: 0, False: 0]
  ------------------
  140|      0|  case '+': case '-': case '.':
  ------------------
  |  Branch (140:3): [True: 0, False: 0]
  |  Branch (140:13): [True: 0, False: 0]
  |  Branch (140:23): [True: 0, False: 0]
  ------------------
  141|       |    // Adobe's number lexer has some "interesting" behavior:
  142|       |    // "--123" is interpreted as 0
  143|       |    // "--123.4" is interpreted as -123.4 [I've seen this in the wild]
  144|       |    // "50-100" is interpreted as 50 [I've seen this in the wild]
  145|       |    // "50--100" is interpreted as 50
  146|       |    // "50-100.0" is an error -- but older versions of Acrobat may
  147|       |    //   have interpreted it as 50100.0 (?)
  148|       |    // "50--100.0" is an error -- but older versions of Acrobat may
  149|       |    //   have interpreted it as 50100.0 (?)
  150|       |    // "50.0-100" is interpreted as 50.0 (or maybe 50.0100?)
  151|       |    // "50.0--100" is interpreted as 50.0 (or maybe 50.0100?)
  152|       |    // "-50-100" is interpreted as -50
  153|       |    // "-" is interpreted as 0
  154|       |    // "-." is interpreted as 0.0
  155|      0|    neg = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  156|      0|    doubleMinus = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  157|      0|    xf = xi = 0;
  158|      0|    if (c == '+') {
  ------------------
  |  Branch (158:9): [True: 0, False: 0]
  ------------------
  159|       |      // just ignore it
  160|      0|    } else if (c == '-') {
  ------------------
  |  Branch (160:16): [True: 0, False: 0]
  ------------------
  161|      0|      neg = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  162|      0|      if (lookChar() == '-') {
  ------------------
  |  Branch (162:11): [True: 0, False: 0]
  ------------------
  163|      0|	doubleMinus = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  164|      0|	do {
  165|      0|	  getChar();
  166|      0|	} while (lookChar() == '-');
  ------------------
  |  Branch (166:11): [True: 0, False: 0]
  ------------------
  167|      0|      }
  168|      0|    } else if (c == '.') {
  ------------------
  |  Branch (168:16): [True: 0, False: 0]
  ------------------
  169|      0|      goto doReal;
  170|      0|    } else {
  171|      0|      xf = xi = c - '0';
  172|      0|    }
  173|      0|    while (1) {
  ------------------
  |  Branch (173:12): [Folded - Ignored]
  ------------------
  174|      0|      c = lookChar();
  175|      0|      if (isdigit(c)) {
  ------------------
  |  Branch (175:11): [True: 0, False: 0]
  ------------------
  176|      0|	getChar();
  177|      0|	xi = xi * 10 + (c - '0');
  178|      0|	if (xf < 1e20) {
  ------------------
  |  Branch (178:6): [True: 0, False: 0]
  ------------------
  179|      0|	  xf = xf * 10 + (c - '0');
  180|      0|	}
  181|      0|      } else if (c == '.') {
  ------------------
  |  Branch (181:18): [True: 0, False: 0]
  ------------------
  182|      0|	getChar();
  183|      0|	goto doReal;
  184|      0|      } else {
  185|      0|	break;
  186|      0|      }
  187|      0|    }
  188|      0|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (188:12): [True: 0, False: 0]
  |  Branch (188:39): [True: 0, False: 0]
  ------------------
  189|      0|      getChar();
  190|      0|    }
  191|      0|    if (neg) {
  ------------------
  |  Branch (191:9): [True: 0, False: 0]
  ------------------
  192|      0|      xi = -xi;
  193|      0|    }
  194|      0|    if (doubleMinus) {
  ------------------
  |  Branch (194:9): [True: 0, False: 0]
  ------------------
  195|      0|      xi = 0;
  196|      0|    }
  197|      0|    obj->initInt(xi);
  198|      0|    break;
  199|      0|  doReal:
  200|      0|    scale = 0.1;
  201|      0|    while (1) {
  ------------------
  |  Branch (201:12): [Folded - Ignored]
  ------------------
  202|      0|      c = lookChar();
  203|      0|      if (c == '-') {
  ------------------
  |  Branch (203:11): [True: 0, False: 0]
  ------------------
  204|      0|	error(errSyntaxWarning, getPos(), "Badly formatted number");
  205|      0|	getChar();
  206|      0|	continue;
  207|      0|      }
  208|      0|      if (!isdigit(c)) {
  ------------------
  |  Branch (208:11): [True: 0, False: 0]
  ------------------
  209|      0|	break;
  210|      0|      }
  211|      0|      getChar();
  212|      0|      xf = xf + scale * (c - '0');
  213|      0|      scale *= 0.1;
  214|      0|    }
  215|      0|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (215:12): [True: 0, False: 0]
  |  Branch (215:39): [True: 0, False: 0]
  ------------------
  216|      0|      getChar();
  217|      0|    }
  218|      0|    if (neg) {
  ------------------
  |  Branch (218:9): [True: 0, False: 0]
  ------------------
  219|      0|      xf = -xf;
  220|      0|    }
  221|      0|    obj->initReal(xf);
  222|      0|    break;
  223|       |
  224|       |  // string
  225|      0|  case '(':
  ------------------
  |  Branch (225:3): [True: 0, False: 0]
  ------------------
  226|      0|    p = tokBuf;
  227|      0|    n = 0;
  228|      0|    numParen = 1;
  229|      0|    done = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  230|      0|    s = NULL;
  231|      0|    do {
  232|      0|      c2 = EOF;
  233|      0|      switch (c = getChar()) {
  234|       |
  235|      0|      case EOF:
  ------------------
  |  Branch (235:7): [True: 0, False: 0]
  ------------------
  236|      0|	error(errSyntaxError, getPos(), "Unterminated string");
  237|      0|	done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  238|      0|	break;
  239|       |
  240|      0|      case '(':
  ------------------
  |  Branch (240:7): [True: 0, False: 0]
  ------------------
  241|      0|	++numParen;
  242|      0|	c2 = c;
  243|      0|	break;
  244|       |
  245|      0|      case ')':
  ------------------
  |  Branch (245:7): [True: 0, False: 0]
  ------------------
  246|      0|	if (--numParen == 0) {
  ------------------
  |  Branch (246:6): [True: 0, False: 0]
  ------------------
  247|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  248|      0|	} else {
  249|      0|	  c2 = c;
  250|      0|	}
  251|      0|	break;
  252|       |
  253|      0|      case '\r':
  ------------------
  |  Branch (253:7): [True: 0, False: 0]
  ------------------
  254|       |	// The PDF spec says that any literal end-of-line sequence
  255|       |	// (LF, CR, CR+LF) is translated to a single LF char.
  256|      0|	c = lookChar();
  257|      0|	if (c == '\n') {
  ------------------
  |  Branch (257:6): [True: 0, False: 0]
  ------------------
  258|      0|	  getChar();
  259|      0|	}
  260|      0|	c2 = '\n';
  261|      0|	break;
  262|       |
  263|      0|      case '\\':
  ------------------
  |  Branch (263:7): [True: 0, False: 0]
  ------------------
  264|      0|	switch (c = getChar()) {
  265|      0|	case 'n':
  ------------------
  |  Branch (265:2): [True: 0, False: 0]
  ------------------
  266|      0|	  c2 = '\n';
  267|      0|	  break;
  268|      0|	case 'r':
  ------------------
  |  Branch (268:2): [True: 0, False: 0]
  ------------------
  269|      0|	  c2 = '\r';
  270|      0|	  break;
  271|      0|	case 't':
  ------------------
  |  Branch (271:2): [True: 0, False: 0]
  ------------------
  272|      0|	  c2 = '\t';
  273|      0|	  break;
  274|      0|	case 'b':
  ------------------
  |  Branch (274:2): [True: 0, False: 0]
  ------------------
  275|      0|	  c2 = '\b';
  276|      0|	  break;
  277|      0|	case 'f':
  ------------------
  |  Branch (277:2): [True: 0, False: 0]
  ------------------
  278|      0|	  c2 = '\f';
  279|      0|	  break;
  280|      0|	case '\\':
  ------------------
  |  Branch (280:2): [True: 0, False: 0]
  ------------------
  281|      0|	case '(':
  ------------------
  |  Branch (281:2): [True: 0, False: 0]
  ------------------
  282|      0|	case ')':
  ------------------
  |  Branch (282:2): [True: 0, False: 0]
  ------------------
  283|      0|	  c2 = c;
  284|      0|	  break;
  285|      0|	case '0': case '1': case '2': case '3':
  ------------------
  |  Branch (285:2): [True: 0, False: 0]
  |  Branch (285:12): [True: 0, False: 0]
  |  Branch (285:22): [True: 0, False: 0]
  |  Branch (285:32): [True: 0, False: 0]
  ------------------
  286|      0|	case '4': case '5': case '6': case '7':
  ------------------
  |  Branch (286:2): [True: 0, False: 0]
  |  Branch (286:12): [True: 0, False: 0]
  |  Branch (286:22): [True: 0, False: 0]
  |  Branch (286:32): [True: 0, False: 0]
  ------------------
  287|      0|	  c2 = c - '0';
  288|      0|	  c = lookChar();
  289|      0|	  if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (289:8): [True: 0, False: 0]
  |  Branch (289:20): [True: 0, False: 0]
  ------------------
  290|      0|	    getChar();
  291|      0|	    c2 = (c2 << 3) + (c - '0');
  292|      0|	    c = lookChar();
  293|      0|	    if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (293:10): [True: 0, False: 0]
  |  Branch (293:22): [True: 0, False: 0]
  ------------------
  294|      0|	      getChar();
  295|      0|	      c2 = (c2 << 3) + (c - '0');
  296|      0|	    }
  297|      0|	  }
  298|      0|	  break;
  299|      0|	case '\r':
  ------------------
  |  Branch (299:2): [True: 0, False: 0]
  ------------------
  300|      0|	  c = lookChar();
  301|      0|	  if (c == '\n') {
  ------------------
  |  Branch (301:8): [True: 0, False: 0]
  ------------------
  302|      0|	    getChar();
  303|      0|	  }
  304|      0|	  break;
  305|      0|	case '\n':
  ------------------
  |  Branch (305:2): [True: 0, False: 0]
  ------------------
  306|      0|	  break;
  307|      0|	case EOF:
  ------------------
  |  Branch (307:2): [True: 0, False: 0]
  ------------------
  308|      0|	  error(errSyntaxError, getPos(), "Unterminated string");
  309|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  310|      0|	  break;
  311|      0|	default:
  ------------------
  |  Branch (311:2): [True: 0, False: 0]
  ------------------
  312|      0|	  c2 = c;
  313|      0|	  break;
  314|      0|	}
  315|      0|	break;
  316|       |
  317|      0|      default:
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|	c2 = c;
  319|      0|	break;
  320|      0|      }
  321|       |
  322|      0|      if (c2 != EOF) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  ------------------
  323|      0|	if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (323:6): [True: 0, False: 0]
  ------------------
  324|      0|	  if (!s)
  ------------------
  |  Branch (324:8): [True: 0, False: 0]
  ------------------
  325|      0|	    s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  326|      0|	  else
  327|      0|	    s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  328|      0|	  p = tokBuf;
  329|      0|	  n = 0;
  330|      0|	}
  331|      0|	*p++ = (char)c2;
  332|      0|	++n;
  333|      0|      }
  334|      0|    } while (!done);
  ------------------
  |  Branch (334:14): [True: 0, False: 0]
  ------------------
  335|      0|    if (!s)
  ------------------
  |  Branch (335:9): [True: 0, False: 0]
  ------------------
  336|      0|      s = new GString(tokBuf, n);
  337|      0|    else
  338|      0|      s->append(tokBuf, n);
  339|      0|    obj->initString(s);
  340|      0|    break;
  341|       |
  342|       |  // name
  343|      0|  case '/':
  ------------------
  |  Branch (343:3): [True: 0, False: 0]
  ------------------
  344|      0|    p = tokBuf;
  345|      0|    n = 0;
  346|      0|    s = NULL;
  347|      0|    invalid = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  348|      0|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (348:12): [True: 0, False: 0]
  |  Branch (348:39): [True: 0, False: 0]
  ------------------
  349|      0|      getChar();
  350|      0|      if (c == '#') {
  ------------------
  |  Branch (350:11): [True: 0, False: 0]
  ------------------
  351|      0|	c2 = lookChar();
  352|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (352:6): [True: 0, False: 0]
  |  Branch (352:19): [True: 0, False: 0]
  ------------------
  353|      0|	  c = c2 - '0';
  354|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (354:13): [True: 0, False: 0]
  |  Branch (354:26): [True: 0, False: 0]
  ------------------
  355|      0|	  c = c2 - 'A' + 10;
  356|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (356:13): [True: 0, False: 0]
  |  Branch (356:26): [True: 0, False: 0]
  ------------------
  357|      0|	  c = c2 - 'a' + 10;
  358|      0|	} else {
  359|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  360|      0|	  goto notEscChar;
  361|      0|	}
  362|      0|	getChar();
  363|      0|	c2 = lookChar();
  364|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (364:6): [True: 0, False: 0]
  |  Branch (364:19): [True: 0, False: 0]
  ------------------
  365|      0|	  c = (c << 4) + (c2 - '0');
  366|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (366:13): [True: 0, False: 0]
  |  Branch (366:26): [True: 0, False: 0]
  ------------------
  367|      0|	  c = (c << 4) + (c2 - 'A' + 10);
  368|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (368:13): [True: 0, False: 0]
  |  Branch (368:26): [True: 0, False: 0]
  ------------------
  369|      0|	  c = (c << 4) + (c2 - 'a' + 10);
  370|      0|	} else {
  371|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  372|      0|	  goto notEscChar;
  373|      0|	}
  374|      0|	getChar();
  375|      0|	if (c == 0) {
  ------------------
  |  Branch (375:6): [True: 0, False: 0]
  ------------------
  376|      0|	  invalid = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  377|      0|	}
  378|      0|      }
  379|      0|     notEscChar:
  380|       |      // the PDF spec claims that names are limited to 127 chars, but
  381|       |      // Distiller 8 will produce longer names, and Acrobat 8 will
  382|       |      // accept longer names
  383|      0|      ++n;
  384|      0|      if (n < tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (384:11): [True: 0, False: 0]
  ------------------
  385|      0|	*p++ = (char)c;
  386|      0|      } else if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (386:18): [True: 0, False: 0]
  ------------------
  387|      0|	*p = (char)c;
  388|      0|	s = new GString(tokBuf, n);
  389|      0|      } else {
  390|      0|	s->append((char)c);
  391|      0|      }
  392|      0|    }
  393|      0|    if (invalid) {
  ------------------
  |  Branch (393:9): [True: 0, False: 0]
  ------------------
  394|      0|      error(errSyntaxError, getPos(), "Null character in name");
  395|      0|      obj->initError();
  396|      0|      if (s) {
  ------------------
  |  Branch (396:11): [True: 0, False: 0]
  ------------------
  397|      0|	delete s;
  398|      0|      }
  399|      0|    } else if (n < tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (399:16): [True: 0, False: 0]
  ------------------
  400|      0|      *p = '\0';
  401|      0|      obj->initName(tokBuf);
  402|      0|    } else {
  403|      0|      obj->initName(s->getCString());
  404|      0|      delete s;
  405|      0|    }
  406|      0|    break;
  407|       |
  408|       |  // array punctuation
  409|      0|  case '[':
  ------------------
  |  Branch (409:3): [True: 0, False: 0]
  ------------------
  410|      0|  case ']':
  ------------------
  |  Branch (410:3): [True: 0, False: 0]
  ------------------
  411|      0|    tokBuf[0] = (char)c;
  412|      0|    tokBuf[1] = '\0';
  413|      0|    obj->initCmd(tokBuf);
  414|      0|    break;
  415|       |
  416|       |  // hex string or dict punctuation
  417|      0|  case '<':
  ------------------
  |  Branch (417:3): [True: 0, False: 0]
  ------------------
  418|      0|    c = lookChar();
  419|       |
  420|       |    // dict punctuation
  421|      0|    if (c == '<') {
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|      getChar();
  423|      0|      tokBuf[0] = tokBuf[1] = '<';
  424|      0|      tokBuf[2] = '\0';
  425|      0|      obj->initCmd(tokBuf);
  426|       |
  427|       |    // hex string
  428|      0|    } else {
  429|      0|      p = tokBuf;
  430|      0|      m = n = 0;
  431|      0|      c2 = 0;
  432|      0|      s = NULL;
  433|      0|      nErrors = 0;
  434|      0|      while (nErrors < 100) {
  ------------------
  |  Branch (434:14): [True: 0, False: 0]
  ------------------
  435|      0|	c = getChar();
  436|      0|	if (c == '>') {
  ------------------
  |  Branch (436:6): [True: 0, False: 0]
  ------------------
  437|      0|	  break;
  438|      0|	} else if (c == EOF) {
  ------------------
  |  Branch (438:13): [True: 0, False: 0]
  ------------------
  439|      0|	  error(errSyntaxError, getPos(), "Unterminated hex string");
  440|      0|	  break;
  441|      0|	} else if (specialChars[c] != 1) {
  ------------------
  |  Branch (441:13): [True: 0, False: 0]
  ------------------
  442|      0|	  c2 = c2 << 4;
  443|      0|	  if (c >= '0' && c <= '9') {
  ------------------
  |  Branch (443:8): [True: 0, False: 0]
  |  Branch (443:20): [True: 0, False: 0]
  ------------------
  444|      0|	    c2 += c - '0';
  445|      0|	  } else if (c >= 'A' && c <= 'F') {
  ------------------
  |  Branch (445:15): [True: 0, False: 0]
  |  Branch (445:27): [True: 0, False: 0]
  ------------------
  446|      0|	    c2 += c - 'A' + 10;
  447|      0|	  } else if (c >= 'a' && c <= 'f') {
  ------------------
  |  Branch (447:15): [True: 0, False: 0]
  |  Branch (447:27): [True: 0, False: 0]
  ------------------
  448|      0|	    c2 += c - 'a' + 10;
  449|      0|	  } else {
  450|      0|	    error(errSyntaxError, getPos(),
  451|      0|		  "Illegal character <{0:02x}> in hex string", c);
  452|      0|	    ++nErrors;
  453|      0|	  }
  454|      0|	  if (++m == 2) {
  ------------------
  |  Branch (454:8): [True: 0, False: 0]
  ------------------
  455|      0|	    if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (455:10): [True: 0, False: 0]
  ------------------
  456|      0|	      if (!s)
  ------------------
  |  Branch (456:12): [True: 0, False: 0]
  ------------------
  457|      0|		s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  458|      0|	      else
  459|      0|		s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  460|      0|	      p = tokBuf;
  461|      0|	      n = 0;
  462|      0|	    }
  463|      0|	    *p++ = (char)c2;
  464|      0|	    ++n;
  465|      0|	    c2 = 0;
  466|      0|	    m = 0;
  467|      0|	  }
  468|      0|	}
  469|      0|      }
  470|      0|      if (!s)
  ------------------
  |  Branch (470:11): [True: 0, False: 0]
  ------------------
  471|      0|	s = new GString(tokBuf, n);
  472|      0|      else
  473|      0|	s->append(tokBuf, n);
  474|      0|      if (m == 1)
  ------------------
  |  Branch (474:11): [True: 0, False: 0]
  ------------------
  475|      0|	s->append((char)(c2 << 4));
  476|      0|      obj->initString(s);
  477|      0|    }
  478|      0|    break;
  479|       |
  480|       |  // dict punctuation
  481|      0|  case '>':
  ------------------
  |  Branch (481:3): [True: 0, False: 0]
  ------------------
  482|      0|    c = lookChar();
  483|      0|    if (c == '>') {
  ------------------
  |  Branch (483:9): [True: 0, False: 0]
  ------------------
  484|      0|      getChar();
  485|      0|      tokBuf[0] = tokBuf[1] = '>';
  486|      0|      tokBuf[2] = '\0';
  487|      0|      obj->initCmd(tokBuf);
  488|      0|    } else {
  489|      0|      error(errSyntaxError, getPos(), "Illegal character '>'");
  490|      0|      obj->initError();
  491|      0|    }
  492|      0|    break;
  493|       |
  494|       |  // error
  495|      0|  case ')':
  ------------------
  |  Branch (495:3): [True: 0, False: 0]
  ------------------
  496|      0|  case '{':
  ------------------
  |  Branch (496:3): [True: 0, False: 0]
  ------------------
  497|      0|  case '}':
  ------------------
  |  Branch (497:3): [True: 0, False: 0]
  ------------------
  498|      0|    error(errSyntaxError, getPos(), "Illegal character '{0:c}'", c);
  499|      0|    obj->initError();
  500|      0|    break;
  501|       |
  502|       |  // command
  503|      0|  default:
  ------------------
  |  Branch (503:3): [True: 0, False: 0]
  ------------------
  504|      0|    p = tokBuf;
  505|      0|    *p++ = (char)c;
  506|      0|    n = 1;
  507|      0|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (507:12): [True: 0, False: 0]
  |  Branch (507:39): [True: 0, False: 0]
  ------------------
  508|      0|      getChar();
  509|      0|      if (++n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (509:11): [True: 0, False: 0]
  ------------------
  510|      0|	error(errSyntaxError, getPos(), "Command token too long");
  511|      0|	break;
  512|      0|      }
  513|      0|      *p++ = (char)c;
  514|      0|    }
  515|      0|    *p = '\0';
  516|      0|    if (tokBuf[0] == 't' && !strcmp(tokBuf, "true")) {
  ------------------
  |  Branch (516:9): [True: 0, False: 0]
  |  Branch (516:29): [True: 0, False: 0]
  ------------------
  517|      0|      obj->initBool(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  518|      0|    } else if (tokBuf[0] == 'f' && !strcmp(tokBuf, "false")) {
  ------------------
  |  Branch (518:16): [True: 0, False: 0]
  |  Branch (518:36): [True: 0, False: 0]
  ------------------
  519|      0|      obj->initBool(gFalse);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  520|      0|    } else if (tokBuf[0] == 'n' && !strcmp(tokBuf, "null")) {
  ------------------
  |  Branch (520:16): [True: 0, False: 0]
  |  Branch (520:36): [True: 0, False: 0]
  ------------------
  521|      0|      obj->initNull();
  522|      0|    } else {
  523|      0|      obj->initCmd(tokBuf);
  524|      0|    }
  525|      0|    break;
  526|      0|  }
  527|       |
  528|      0|  return obj;
  529|      0|}
_ZN5Lexer7isSpaceEi:
  552|  34.6k|GBool Lexer::isSpace(int c) {
  553|  34.6k|  return c >= 0 && c <= 0xff && specialChars[c] == 1;
  ------------------
  |  Branch (553:10): [True: 34.6k, False: 0]
  |  Branch (553:20): [True: 34.6k, False: 0]
  |  Branch (553:33): [True: 17.8k, False: 16.7k]
  ------------------
  554|  34.6k|}

_ZN14NameToCharCodeC2Ev:
   25|    258|NameToCharCode::NameToCharCode() {
   26|    258|  int i;
   27|       |
   28|    258|  size = 31;
   29|    258|  len = 0;
   30|    258|  tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   31|  8.25k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (31:15): [True: 7.99k, False: 258]
  ------------------
   32|  7.99k|    tab[i].name = NULL;
   33|  7.99k|  }
   34|    258|}
_ZN14NameToCharCodeD2Ev:
   36|    258|NameToCharCode::~NameToCharCode() {
   37|    258|  int i;
   38|       |
   39|  2.17M|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (39:15): [True: 2.17M, False: 258]
  ------------------
   40|  2.17M|    if (tab[i].name) {
  ------------------
  |  Branch (40:9): [True: 575k, False: 1.60M]
  ------------------
   41|   575k|      gfree(tab[i].name);
   42|   575k|    }
   43|  2.17M|  }
   44|    258|  gfree(tab);
   45|    258|}
_ZN14NameToCharCode3addEPKcj:
   47|   576k|void NameToCharCode::add(const char *name, CharCode c) {
   48|   576k|  NameToCharCodeEntry *oldTab;
   49|   576k|  int h, i, oldSize;
   50|       |
   51|       |  // expand the table if necessary
   52|   576k|  if (len >= size / 2) {
  ------------------
  |  Branch (52:7): [True: 1.67k, False: 574k]
  ------------------
   53|  1.67k|    oldSize = size;
   54|  1.67k|    oldTab = tab;
   55|  1.67k|    size = 2*size + 1;
   56|  1.67k|    tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   57|  4.34M|    for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (57:17): [True: 4.34M, False: 1.67k]
  ------------------
   58|  4.34M|      tab[h].name = NULL;
   59|  4.34M|    }
   60|  2.17M|    for (i = 0; i < oldSize; ++i) {
  ------------------
  |  Branch (60:17): [True: 2.16M, False: 1.67k]
  ------------------
   61|  2.16M|      if (oldTab[i].name) {
  ------------------
  |  Branch (61:11): [True: 1.08M, False: 1.08M]
  ------------------
   62|  1.08M|	h = hash(oldTab[i].name);
   63|  1.58M|	while (tab[h].name) {
  ------------------
  |  Branch (63:9): [True: 499k, False: 1.08M]
  ------------------
   64|   499k|	  if (++h == size) {
  ------------------
  |  Branch (64:8): [True: 0, False: 499k]
  ------------------
   65|      0|	    h = 0;
   66|      0|	  }
   67|   499k|	}
   68|  1.08M|	tab[h] = oldTab[i];
   69|  1.08M|      }
   70|  2.16M|    }
   71|  1.67k|    gfree(oldTab);
   72|  1.67k|  }
   73|       |
   74|       |  // add the new name
   75|   576k|  h = hash(name);
   76|  2.39M|  while (tab[h].name && strcmp(tab[h].name, name)) {
  ------------------
  |  Branch (76:10): [True: 1.81M, False: 575k]
  |  Branch (76:25): [True: 1.81M, False: 129]
  ------------------
   77|  1.81M|    if (++h == size) {
  ------------------
  |  Branch (77:9): [True: 387, False: 1.81M]
  ------------------
   78|    387|      h = 0;
   79|    387|    }
   80|  1.81M|  }
   81|   576k|  if (!tab[h].name) {
  ------------------
  |  Branch (81:7): [True: 575k, False: 129]
  ------------------
   82|   575k|    tab[h].name = copyString(name);
   83|   575k|  }
   84|   576k|  tab[h].c = c;
   85|       |
   86|   576k|  ++len;
   87|   576k|}
_ZN14NameToCharCode4hashEPKc:
  104|  1.66M|int NameToCharCode::hash(const char *name) {
  105|  1.66M|  const char *p;
  106|  1.66M|  unsigned int h;
  107|       |
  108|  1.66M|  h = 0;
  109|  19.5M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (109:18): [True: 17.8M, False: 1.66M]
  ------------------
  110|  17.8M|    h = 17 * h + (int)(*p & 0xff);
  111|  17.8M|  }
  112|  1.66M|  return (int)(h % size);
  113|  1.66M|}

_ZN6Object10initStreamEP6Stream:
   70|     10|Object *Object::initStream(Stream *streamA) {
   71|     10|  initObj(objStream);
  ------------------
  |  |   77|     10|#define initObj(t) type = t
  ------------------
   72|     10|  stream = streamA;
   73|     10|  return this;
   74|     10|}
_ZN6Object4copyEPS_:
   76|     30|Object *Object::copy(Object *obj) {
   77|     30|  *obj = *this;
   78|     30|  switch (type) {
   79|      0|  case objString:
  ------------------
  |  Branch (79:3): [True: 0, False: 30]
  ------------------
   80|      0|    obj->string = string->copy();
   81|      0|    break;
   82|      0|  case objName:
  ------------------
  |  Branch (82:3): [True: 0, False: 30]
  ------------------
   83|      0|    obj->name = copyString(name);
   84|      0|    break;
   85|      0|  case objArray:
  ------------------
  |  Branch (85:3): [True: 0, False: 30]
  ------------------
   86|      0|    array->incRef();
   87|      0|    break;
   88|      0|  case objDict:
  ------------------
  |  Branch (88:3): [True: 0, False: 30]
  ------------------
   89|      0|    dict->incRef();
   90|      0|    break;
   91|     10|  case objStream:
  ------------------
  |  Branch (91:3): [True: 10, False: 20]
  ------------------
   92|     10|    obj->stream = stream->copy();
   93|     10|    break;
   94|      0|  case objCmd:
  ------------------
  |  Branch (94:3): [True: 0, False: 30]
  ------------------
   95|      0|    obj->cmd = copyString(cmd);
   96|      0|    break;
   97|     20|  default:
  ------------------
  |  Branch (97:3): [True: 20, False: 10]
  ------------------
   98|     20|    break;
   99|     30|  }
  100|       |#ifdef DEBUG_OBJECT_MEM
  101|       |#if MULTITHREADED
  102|       |  gAtomicIncrement(&numAlloc[type]);
  103|       |#else
  104|       |  ++numAlloc[type];
  105|       |#endif
  106|       |#endif
  107|     30|  return obj;
  108|     30|}
_ZN6Object4freeEv:
  115|    467|void Object::free() {
  116|    467|  switch (type) {
  117|      0|  case objString:
  ------------------
  |  Branch (117:3): [True: 0, False: 467]
  ------------------
  118|      0|    delete string;
  119|      0|    break;
  120|      0|  case objName:
  ------------------
  |  Branch (120:3): [True: 0, False: 467]
  ------------------
  121|      0|    gfree(name);
  122|      0|    break;
  123|      0|  case objArray:
  ------------------
  |  Branch (123:3): [True: 0, False: 467]
  ------------------
  124|      0|    if (!array->decRef()) {
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|      delete array;
  126|      0|    }
  127|      0|    break;
  128|      0|  case objDict:
  ------------------
  |  Branch (128:3): [True: 0, False: 467]
  ------------------
  129|      0|    if (!dict->decRef()) {
  ------------------
  |  Branch (129:9): [True: 0, False: 0]
  ------------------
  130|      0|      delete dict;
  131|      0|    }
  132|      0|    break;
  133|     20|  case objStream:
  ------------------
  |  Branch (133:3): [True: 20, False: 447]
  ------------------
  134|     20|    delete stream;
  135|     20|    break;
  136|      0|  case objCmd:
  ------------------
  |  Branch (136:3): [True: 0, False: 467]
  ------------------
  137|      0|    gfree(cmd);
  138|      0|    break;
  139|    447|  default:
  ------------------
  |  Branch (139:3): [True: 447, False: 20]
  ------------------
  140|    447|    break;
  141|    467|  }
  142|       |#ifdef DEBUG_OBJECT_MEM
  143|       |#if MULTITHREADED
  144|       |  gAtomicDecrement(&numAlloc[type]);
  145|       |#else
  146|       |  --numAlloc[type];
  147|       |#endif
  148|       |#endif
  149|    467|  type = objNone;
  150|    467|}

_ZN6ObjectC2Ev:
   85|  5.25k|    type(objNone) {}
_ZN6Object8initNullEv:
   99|    139|    { initObj(objNull); return this; }
  ------------------
  |  |   77|    139|#define initObj(t) type = t
  ------------------
_ZN6Object7initEOFEv:
  111|     30|    { initObj(objEOF); return this; }
  ------------------
  |  |   77|     30|#define initObj(t) type = t
  ------------------
_ZN6Object5isIntEv:
  126|     20|  GBool isInt() { return type == objInt; }
_ZN6Object8isStringEv:
  129|     10|  GBool isString() { return type == objString; }
_ZN6Object6isNoneEv:
  139|     50|  GBool isNone() { return type == objNone; }
_ZN6Object5isCmdEPKc:
  147|     10|    { return type == objCmd && !strcmp(cmd, cmdA); }
  ------------------
  |  Branch (147:14): [True: 0, False: 10]
  |  Branch (147:32): [True: 0, False: 0]
  ------------------
_ZN6Object11streamResetEv:
  290|     10|  { stream->reset(); }
_ZN6Object11streamCloseEv:
  293|     10|  { stream->close(); }
_ZN6Object13streamGetCharEv:
  296|     10|  { return stream->getChar(); }

_ZN6PDFDocC2EP10BaseStreamP7GStringS3_P7PDFCore:
  219|    129|	       GString *userPassword, PDFCore *coreA) {
  220|       |#ifdef _WIN32
  221|       |  int n, i;
  222|       |#endif
  223|       |
  224|    129|  init(coreA);
  225|       |
  226|    129|  if (strA->getFileName()) {
  ------------------
  |  Branch (226:7): [True: 0, False: 129]
  ------------------
  227|      0|    fileName = strA->getFileName()->copy();
  228|       |#ifdef _WIN32
  229|       |    n = fileName->getLength();
  230|       |    fileNameU = (wchar_t *)gmallocn(n + 1, sizeof(wchar_t));
  231|       |    for (i = 0; i < n; ++i) {
  232|       |      fileNameU[i] = (wchar_t)(fileName->getChar(i) & 0xff);
  233|       |    }
  234|       |    fileNameU[n] = L'\0';
  235|       |#endif
  236|    129|  } else {
  237|    129|    fileName = NULL;
  238|       |#ifdef _WIN32
  239|       |    fileNameU = NULL;
  240|       |#endif
  241|    129|  }
  242|    129|  str = strA;
  243|    129|  ok = setup(ownerPassword, userPassword);
  244|    129|}
_ZN6PDFDoc4initEP7PDFCore:
  246|    129|void PDFDoc::init(PDFCore *coreA) {
  247|    129|  ok = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  248|    129|  errCode = errNone;
  ------------------
  |  |   12|    129|#define errNone             0	// no error
  ------------------
  249|    129|  core = coreA;
  250|    129|  file = NULL;
  251|    129|  str = NULL;
  252|    129|  xref = NULL;
  253|    129|  catalog = NULL;
  254|    129|  annots = NULL;
  255|    129|#ifndef DISABLE_OUTLINE
  256|    129|  outline = NULL;
  257|    129|#endif
  258|    129|  optContent = NULL;
  259|    129|}
_ZN6PDFDoc5setupEP7GStringS1_:
  261|    129|GBool PDFDoc::setup(GString *ownerPassword, GString *userPassword) {
  262|       |
  263|    129|  str->reset();
  264|       |
  265|       |  // check header
  266|    129|  checkHeader();
  267|       |
  268|       |  // read the xref and catalog
  269|    129|  if (!PDFDoc::setup2(ownerPassword, userPassword, gFalse)) {
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  |  Branch (269:7): [True: 129, False: 0]
  ------------------
  270|    129|    if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   18|    258|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
                  if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  |  Branch (270:9): [True: 129, False: 0]
  |  Branch (270:34): [True: 0, False: 0]
  ------------------
  271|       |      // try repairing the xref table
  272|    129|      error(errSyntaxWarning, -1,
  273|    129|	    "PDF file is damaged - attempting to reconstruct xref table...");
  274|    129|      if (!PDFDoc::setup2(ownerPassword, userPassword, gTrue)) {
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  |  Branch (274:11): [True: 129, False: 0]
  ------------------
  275|    129|	return gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  276|    129|      }
  277|    129|    } else {
  278|      0|      return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  279|      0|    }
  280|    129|  }
  281|       |
  282|      0|#ifndef DISABLE_OUTLINE
  283|       |  // read outline
  284|      0|  outline = new Outline(catalog->getOutline(), xref);
  285|      0|#endif
  286|       |
  287|       |  // read the optional content info
  288|      0|  optContent = new OptionalContent(this);
  289|       |
  290|       |
  291|       |  // done
  292|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  293|    129|}
_ZN6PDFDoc6setup2EP7GStringS1_i:
  296|    258|		     GBool repairXRef) {
  297|       |  // read xref table
  298|    258|  xref = new XRef(str, repairXRef);
  299|    258|  if (!xref->isOk()) {
  ------------------
  |  Branch (299:7): [True: 258, False: 0]
  ------------------
  300|    258|    error(errSyntaxError, -1, "Couldn't read xref table");
  301|    258|    errCode = xref->getErrorCode();
  302|    258|    delete xref;
  303|    258|    xref = NULL;
  304|    258|    return gFalse;
  ------------------
  |  |   18|    258|#define gFalse 0
  ------------------
  305|    258|  }
  306|       |
  307|       |  // check for encryption
  308|      0|  if (!checkEncryption(ownerPassword, userPassword)) {
  ------------------
  |  Branch (308:7): [True: 0, False: 0]
  ------------------
  309|      0|    errCode = errEncrypted;
  ------------------
  |  |   21|      0|#define errEncrypted        4	// file was encrypted and password was
  ------------------
  310|      0|    delete xref;
  311|      0|    xref = NULL;
  312|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  313|      0|  }
  314|       |
  315|       |  // read catalog
  316|      0|  catalog = new Catalog(this);
  317|      0|  if (!catalog->isOk()) {
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|    error(errSyntaxError, -1, "Couldn't read page catalog");
  319|      0|    errCode = errBadCatalog;
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  320|      0|    delete catalog;
  321|      0|    catalog = NULL;
  322|      0|    delete xref;
  323|      0|    xref = NULL;
  324|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  325|      0|  }
  326|       |
  327|       |  // initialize the Annots object
  328|      0|  annots = new Annots(this);
  329|       |
  330|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  331|      0|}
_ZN6PDFDocD2Ev:
  333|    129|PDFDoc::~PDFDoc() {
  334|    129|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 129]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|    129|#ifndef DISABLE_OUTLINE
  338|    129|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 129]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|    129|#endif
  342|    129|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 129]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|    129|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 129]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|    129|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 129]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|    129|  if (str) {
  ------------------
  |  Branch (351:7): [True: 129, False: 0]
  ------------------
  352|    129|    delete str;
  353|    129|  }
  354|    129|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 129]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|    129|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 0, False: 129]
  ------------------
  358|      0|    delete fileName;
  359|      0|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|    129|}
_ZN6PDFDoc11checkHeaderEv:
  369|    129|void PDFDoc::checkHeader() {
  370|    129|  char hdrBuf[headerSearchSize+1];
  371|    129|  char *p;
  372|    129|  int i;
  373|       |
  374|    129|  pdfVersion = 0;
  375|    129|  memset(hdrBuf, 0, headerSearchSize + 1);
  ------------------
  |  |   44|    129|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  376|    129|  str->getBlock(hdrBuf, headerSearchSize);
  ------------------
  |  |   44|    129|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  377|   115k|  for (i = 0; i < headerSearchSize - 5; ++i) {
  ------------------
  |  |   44|   115k|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (377:15): [True: 115k, False: 112]
  ------------------
  378|   115k|    if (!strncmp(&hdrBuf[i], "%PDF-", 5)) {
  ------------------
  |  Branch (378:9): [True: 17, False: 115k]
  ------------------
  379|     17|      break;
  380|     17|    }
  381|   115k|  }
  382|    129|  if (i >= headerSearchSize - 5) {
  ------------------
  |  |   44|    129|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (382:7): [True: 112, False: 17]
  ------------------
  383|    112|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  384|    112|    return;
  385|    112|  }
  386|     17|  str->moveStart(i);
  387|     17|  if (!(p = strtok(&hdrBuf[i+5], " \t\n\r"))) {
  ------------------
  |  Branch (387:7): [True: 3, False: 14]
  ------------------
  388|      3|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  389|      3|    return;
  390|      3|  }
  391|     14|  pdfVersion = atof(p);
  392|     14|  if (!(hdrBuf[i+5] >= '0' && hdrBuf[i+5] <= '9') ||
  ------------------
  |  Branch (392:9): [True: 7, False: 7]
  |  Branch (392:31): [True: 1, False: 6]
  ------------------
  393|     14|      pdfVersion > supportedPDFVersionNum + 0.0001) {
  ------------------
  |  |   28|      1|#define supportedPDFVersionNum 2.0
  ------------------
  |  Branch (393:7): [True: 1, False: 0]
  ------------------
  394|     14|    error(errSyntaxWarning, -1,
  395|     14|	  "PDF version {0:s} -- xpdf supports version {1:s} (continuing anyway)",
  396|     14|	  p, supportedPDFVersionStr);
  ------------------
  |  |   27|     14|#define supportedPDFVersionStr "2.0"
  ------------------
  397|     14|  }
  398|     14|}

_ZN6PDFDoc4isOkEv:
   57|    129|  GBool isOk() { return ok; }

_ZN6ParserC2EP4XRefP5Lexeri:
   26|     10|Parser::Parser(XRef *xrefA, Lexer *lexerA, GBool allowStreamsA) {
   27|     10|  xref = xrefA;
   28|     10|  lexer = lexerA;
   29|     10|  inlineImg = 0;
   30|     10|  allowStreams = allowStreamsA;
   31|     10|  lexer->getObj(&buf1);
   32|     10|  lexer->getObj(&buf2);
   33|     10|}
_ZN6ParserD2Ev:
   35|     10|Parser::~Parser() {
   36|     10|  buf1.free();
   37|     10|  buf2.free();
   38|     10|  delete lexer;
   39|     10|}
_ZN6Parser6getObjEP6ObjectiPh14CryptAlgorithmiiii:
   44|     10|		       int objNum, int objGen, int recursion) {
   45|     10|  char *key;
   46|     10|  Stream *str;
   47|     10|  Object obj2;
   48|     10|  int num;
   49|     10|  DecryptStream *decrypt;
   50|     10|  GString *s, *s2;
   51|     10|  int c;
   52|       |
   53|       |  // refill buffer after inline image data
   54|     10|  if (inlineImg == 2) {
  ------------------
  |  Branch (54:7): [True: 0, False: 10]
  ------------------
   55|      0|    buf1.free();
   56|      0|    buf2.free();
   57|      0|    lexer->getObj(&buf1);
   58|      0|    lexer->getObj(&buf2);
   59|      0|    inlineImg = 0;
   60|      0|  }
   61|       |
   62|       |  // array
   63|     10|  if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("[")) {
  ------------------
  |  |   24|     10|#define recursionLimit 500
  ------------------
  |  Branch (63:7): [True: 0, False: 10]
  |  Branch (63:22): [True: 0, False: 0]
  |  Branch (63:52): [True: 0, False: 0]
  ------------------
   64|      0|    shift();
   65|      0|    obj->initArray(xref);
   66|      0|    while (!buf1.isCmd("]") && !buf1.isEOF())
  ------------------
  |  Branch (66:12): [True: 0, False: 0]
  |  Branch (66:32): [True: 0, False: 0]
  ------------------
   67|      0|      obj->arrayAdd(getObj(&obj2, gFalse, fileKey, encAlgorithm, keyLength,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   68|      0|			   objNum, objGen, recursion + 1));
   69|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (69:9): [True: 0, False: 0]
  ------------------
   70|      0|      error(errSyntaxError, getPos(), "End of file inside array");
   71|      0|    shift();
   72|       |
   73|       |  // dictionary or stream
   74|     10|  } else if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("<<")) {
  ------------------
  |  |   24|     10|#define recursionLimit 500
  ------------------
  |  Branch (74:14): [True: 0, False: 10]
  |  Branch (74:29): [True: 0, False: 0]
  |  Branch (74:59): [True: 0, False: 0]
  ------------------
   75|      0|    shift();
   76|      0|    obj->initDict(xref);
   77|      0|    while (!buf1.isCmd(">>") && !buf1.isEOF()) {
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  |  Branch (77:33): [True: 0, False: 0]
  ------------------
   78|      0|      if (!buf1.isName()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|	error(errSyntaxError, getPos(),
   80|      0|	      "Dictionary key must be a name object");
   81|      0|	shift();
   82|      0|      } else {
   83|      0|	key = copyString(buf1.getName());
   84|      0|	shift();
   85|      0|	if (buf1.isEOF() || buf1.isError()) {
  ------------------
  |  Branch (85:6): [True: 0, False: 0]
  |  Branch (85:22): [True: 0, False: 0]
  ------------------
   86|      0|	  gfree(key);
   87|      0|	  break;
   88|      0|	}
   89|      0|	obj->dictAdd(key, getObj(&obj2, gFalse,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   90|      0|				 fileKey, encAlgorithm, keyLength,
   91|      0|				 objNum, objGen, recursion + 1));
   92|      0|      }
   93|      0|    }
   94|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (94:9): [True: 0, False: 0]
  ------------------
   95|      0|      error(errSyntaxError, getPos(), "End of file inside dictionary");
   96|       |    // stream objects are not allowed inside content streams or
   97|       |    // object streams
   98|      0|    if (allowStreams && buf2.isCmd("stream")) {
  ------------------
  |  Branch (98:9): [True: 0, False: 0]
  |  Branch (98:25): [True: 0, False: 0]
  ------------------
   99|      0|      if ((str = makeStream(obj, fileKey, encAlgorithm, keyLength,
  ------------------
  |  Branch (99:11): [True: 0, False: 0]
  ------------------
  100|      0|			    objNum, objGen, recursion + 1))) {
  101|      0|	obj->initStream(str);
  102|      0|      } else {
  103|      0|	obj->free();
  104|      0|	obj->initError();
  105|      0|      }
  106|      0|    } else {
  107|      0|      shift();
  108|      0|    }
  109|       |
  110|       |  // indirect reference or integer
  111|     10|  } else if (buf1.isInt()) {
  ------------------
  |  Branch (111:14): [True: 0, False: 10]
  ------------------
  112|      0|    num = buf1.getInt();
  113|      0|    shift();
  114|      0|    if (buf1.isInt() && buf2.isCmd("R")) {
  ------------------
  |  Branch (114:9): [True: 0, False: 0]
  |  Branch (114:25): [True: 0, False: 0]
  ------------------
  115|      0|      obj->initRef(num, buf1.getInt());
  116|      0|      shift();
  117|      0|      shift();
  118|      0|    } else {
  119|      0|      obj->initInt(num);
  120|      0|    }
  121|       |
  122|       |  // string
  123|     10|  } else if (buf1.isString() && fileKey) {
  ------------------
  |  Branch (123:14): [True: 0, False: 10]
  |  Branch (123:33): [True: 0, False: 0]
  ------------------
  124|      0|    s = buf1.getString();
  125|      0|    s2 = new GString();
  126|      0|    obj2.initNull();
  127|      0|    decrypt = new DecryptStream(new MemStream(s->getCString(), 0,
  128|      0|					      s->getLength(), &obj2),
  129|      0|				fileKey, encAlgorithm, keyLength,
  130|      0|				objNum, objGen);
  131|      0|    decrypt->reset();
  132|      0|    while ((c = decrypt->getChar()) != EOF) {
  ------------------
  |  Branch (132:12): [True: 0, False: 0]
  ------------------
  133|      0|      s2->append((char)c);
  134|      0|    }
  135|      0|    delete decrypt;
  136|      0|    obj->initString(s2);
  137|      0|    shift();
  138|       |
  139|       |  // simple object
  140|     10|  } else {
  141|     10|    buf1.copy(obj);
  142|     10|    shift();
  143|     10|  }
  144|       |
  145|     10|  return obj;
  146|     10|}
_ZN6Parser5shiftEv:
  293|     10|void Parser::shift() {
  294|     10|  if (inlineImg > 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 10]
  ------------------
  295|      0|    if (inlineImg < 2) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      ++inlineImg;
  297|      0|    } else {
  298|       |      // in a damaged content stream, if 'ID' shows up in the middle
  299|       |      // of a dictionary, we need to reset
  300|      0|      inlineImg = 0;
  301|      0|    }
  302|     10|  } else if (buf2.isCmd("ID")) {
  ------------------
  |  Branch (302:14): [True: 0, False: 10]
  ------------------
  303|      0|    lexer->skipChar();		// skip char after 'ID' command
  304|      0|    inlineImg = 1;
  305|      0|  }
  306|     10|  buf1.free();
  307|     10|  buf1 = buf2;
  308|     10|  if (inlineImg > 0)		// don't buffer inline image data
  ------------------
  |  Branch (308:7): [True: 0, False: 10]
  ------------------
  309|      0|    buf2.initNull();
  310|     10|  else
  311|     10|    lexer->getObj(&buf2);
  312|     10|}

_ZN6StreamC2Ev:
   62|    149|Stream::Stream() {
   63|    149|}
_ZN6StreamD2Ev:
   65|    149|Stream::~Stream() {
   66|    149|}
_ZN10BaseStreamC2EP6Object:
  325|    149|BaseStream::BaseStream(Object *dictA) {
  326|    149|  dict = *dictA;
  327|    149|}
_ZN10BaseStreamD2Ev:
  329|    149|BaseStream::~BaseStream() {
  330|    149|  dict.free();
  331|    149|}
_ZN9MemStreamC2EPcjjP6Object:
  873|    149|    BaseStream(dictA) {
  874|    149|  buf = bufA;
  875|    149|  start = startA;
  876|    149|  length = lengthA;
  877|    149|  bufEnd = buf + start + length;
  878|    149|  bufPtr = buf + start;
  879|    149|  needFree = gFalse;
  ------------------
  |  |   18|    149|#define gFalse 0
  ------------------
  880|    149|}
_ZN9MemStreamD2Ev:
  882|    149|MemStream::~MemStream() {
  883|    149|  if (needFree) {
  ------------------
  |  Branch (883:7): [True: 0, False: 149]
  ------------------
  884|      0|    gfree(buf);
  885|      0|  }
  886|    149|}
_ZN9MemStream4copyEv:
  888|     10|Stream *MemStream::copy() {
  889|     10|  Object dictA;
  890|       |
  891|     10|  dict.copy(&dictA);
  892|     10|  return new MemStream(buf, start, length, &dictA);
  893|     10|}
_ZN9MemStream13makeSubStreamElilP6Object:
  896|     10|				 GFileOffset lengthA, Object *dictA) {
  897|     10|  MemStream *subStr;
  898|     10|  Guint newStart, newLength;
  899|       |
  900|     10|  if (startA < start) {
  ------------------
  |  Branch (900:7): [True: 0, False: 10]
  ------------------
  901|      0|    newStart = start;
  902|     10|  } else if (startA > start + length) {
  ------------------
  |  Branch (902:14): [True: 10, False: 0]
  ------------------
  903|     10|    newStart = start + (int)length;
  904|     10|  } else {
  905|      0|    newStart = (int)startA;
  906|      0|  }
  907|     10|  if (!limited || newStart + lengthA > start + length) {
  ------------------
  |  Branch (907:7): [True: 10, False: 0]
  |  Branch (907:19): [True: 0, False: 0]
  ------------------
  908|     10|    newLength = start + length - newStart;
  909|     10|  } else {
  910|      0|    newLength = (Guint)lengthA;
  911|      0|  }
  912|     10|  subStr = new MemStream(buf, newStart, newLength, dictA);
  913|     10|  return subStr;
  914|     10|}
_ZN9MemStream5resetEv:
  916|    268|void MemStream::reset() {
  917|    268|  bufPtr = buf + start;
  918|    268|}
_ZN9MemStream5closeEv:
  920|     10|void MemStream::close() {
  921|     10|}
_ZN9MemStream8getBlockEPci:
  923|    397|int MemStream::getBlock(char *blk, int size) {
  924|    397|  int n;
  925|       |
  926|    397|  if (size <= 0) {
  ------------------
  |  Branch (926:7): [True: 0, False: 397]
  ------------------
  927|      0|    return 0;
  928|      0|  }
  929|    397|  if (bufEnd - bufPtr < size) {
  ------------------
  |  Branch (929:7): [True: 374, False: 23]
  ------------------
  930|    374|    n = (int)(bufEnd - bufPtr);
  931|    374|  } else {
  932|     23|    n = size;
  933|     23|  }
  934|    397|  memcpy(blk, bufPtr, n);
  935|    397|  bufPtr += n;
  936|    397|  return n;
  937|    397|}
_ZN9MemStream6setPosEli:
  939|    139|void MemStream::setPos(GFileOffset pos, int dir) {
  940|    139|  Guint i;
  941|       |
  942|    139|  if (dir >= 0) {
  ------------------
  |  Branch (942:7): [True: 10, False: 129]
  ------------------
  943|     10|    i = (Guint)pos;
  944|    129|  } else {
  945|    129|    if (pos > start + length) {
  ------------------
  |  Branch (945:9): [True: 117, False: 12]
  ------------------
  946|    117|      i = 0;
  947|    117|    } else {
  948|     12|      i = (Guint)(start + length - pos);
  949|     12|    }
  950|    129|  }
  951|    139|  if (i < start) {
  ------------------
  |  Branch (951:7): [True: 16, False: 123]
  ------------------
  952|     16|    i = start;
  953|    123|  } else if (i > start + length) {
  ------------------
  |  Branch (953:14): [True: 10, False: 113]
  ------------------
  954|     10|    i = start + length;
  955|     10|  }
  956|    139|  bufPtr = buf + i;
  957|    139|}
_ZN9MemStream9moveStartEi:
  959|     17|void MemStream::moveStart(int delta) {
  960|     17|  start += delta;
  961|     17|  length -= delta;
  962|     17|  bufPtr = buf + start;
  963|     17|}

_ZN10BaseStream11getFileNameEv:
  180|    129|  virtual GString *getFileName() { return NULL; }
_ZN9MemStream7getCharEv:
  365|     10|    { return (bufPtr < bufEnd) ? (*bufPtr++ & 0xff) : EOF; }
  ------------------
  |  Branch (365:14): [True: 0, False: 10]
  ------------------
_ZN9MemStream6getPosEv:
  369|     16|  virtual GFileOffset getPos() { return (GFileOffset)(bufPtr - buf); }
_ZN9MemStream8getStartEv:
  371|    258|  virtual GFileOffset getStart() { return start; }

_ZN10UnicodeMapC2EPKciP15UnicodeMapRangei:
  122|    516|		       UnicodeMapRange *rangesA, int lenA) {
  123|    516|  encodingName = new GString(encodingNameA);
  124|    516|  unicodeOut = unicodeOutA;
  125|    516|  kind = unicodeMapResident;
  126|    516|  ranges = rangesA;
  127|    516|  len = lenA;
  128|    516|  eMaps = NULL;
  129|    516|  eMapsLen = 0;
  130|    516|  refCnt = 1;
  131|    516|}
_ZN10UnicodeMapC2EPKciPFijPciE:
  134|    258|		       UnicodeMapFunc funcA) {
  135|    258|  encodingName = new GString(encodingNameA);
  136|    258|  unicodeOut = unicodeOutA;
  137|    258|  kind = unicodeMapFunc;
  138|    258|  func = funcA;
  139|    258|  eMaps = NULL;
  140|    258|  eMapsLen = 0;
  141|    258|  refCnt = 1;
  142|    258|}
_ZN10UnicodeMapD2Ev:
  144|    774|UnicodeMap::~UnicodeMap() {
  145|    774|  delete encodingName;
  146|    774|  if (kind == unicodeMapUser && ranges) {
  ------------------
  |  Branch (146:7): [True: 0, False: 774]
  |  Branch (146:33): [True: 0, False: 0]
  ------------------
  147|      0|    gfree(ranges);
  148|      0|  }
  149|    774|  if (eMaps) {
  ------------------
  |  Branch (149:7): [True: 0, False: 774]
  ------------------
  150|      0|    gfree(eMaps);
  151|      0|  }
  152|    774|}
_ZN15UnicodeMapCacheC2Ev:
  228|    129|UnicodeMapCache::UnicodeMapCache() {
  229|    129|  int i;
  230|       |
  231|    645|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    645|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (231:15): [True: 516, False: 129]
  ------------------
  232|    516|    cache[i] = NULL;
  233|    516|  }
  234|    129|}
_ZN15UnicodeMapCacheD2Ev:
  236|    129|UnicodeMapCache::~UnicodeMapCache() {
  237|    129|  int i;
  238|       |
  239|    645|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    645|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (239:15): [True: 516, False: 129]
  ------------------
  240|    516|    if (cache[i]) {
  ------------------
  |  Branch (240:9): [True: 0, False: 516]
  ------------------
  241|      0|      cache[i]->decRefCnt();
  242|      0|    }
  243|    516|  }
  244|    129|}

_ZN10UnicodeMap15getEncodingNameEv:
   65|    774|  GString *getEncodingName() { return encodingName; }

_ZN16UnicodeRemappingC2Ev:
   69|    129|UnicodeRemapping::UnicodeRemapping() {
   70|  33.1k|  for (int i = 0; i < 256; ++i) {
  ------------------
  |  Branch (70:19): [True: 33.0k, False: 129]
  ------------------
   71|  33.0k|    page0[i] = (Unicode)i;
   72|  33.0k|  }
   73|    129|  sMap = NULL;
   74|    129|  sMapLen = sMapSize = 0;
   75|    129|}
_ZN16UnicodeRemappingD2Ev:
   77|    129|UnicodeRemapping::~UnicodeRemapping() {
   78|    129|  gfree(sMap);
   79|    129|}

_ZN10XRefPosSetC2Ev:
   66|     10|XRefPosSet::XRefPosSet() {
   67|     10|  size = 16;
   68|     10|  len = 0;
   69|     10|  tab = (GFileOffset *)gmallocn(size, sizeof(GFileOffset));
   70|     10|}
_ZN10XRefPosSetD2Ev:
   72|     10|XRefPosSet::~XRefPosSet() {
   73|     10|  gfree(tab);
   74|     10|}
_ZN10XRefPosSet3addEl:
   76|     10|void XRefPosSet::add(GFileOffset pos) {
   77|     10|  int i;
   78|       |
   79|     10|  i = find(pos);
   80|     10|  if (i < len && tab[i] == pos) {
  ------------------
  |  Branch (80:7): [True: 0, False: 10]
  |  Branch (80:18): [True: 0, False: 0]
  ------------------
   81|      0|    return;
   82|      0|  }
   83|     10|  if (len == size) {
  ------------------
  |  Branch (83:7): [True: 0, False: 10]
  ------------------
   84|      0|    if (size > INT_MAX / 2) {
  ------------------
  |  Branch (84:9): [True: 0, False: 0]
  ------------------
   85|      0|      gMemError("Integer overflow in XRefPosSet::add()");
   86|      0|    }
   87|      0|    size *= 2;
   88|      0|    tab = (GFileOffset *)greallocn(tab, size, sizeof(GFileOffset));
   89|      0|  }
   90|     10|  if (i < len) {
  ------------------
  |  Branch (90:7): [True: 0, False: 10]
  ------------------
   91|      0|    memmove(&tab[i + 1], &tab[i], (len - i) * sizeof(GFileOffset));
   92|      0|  }
   93|     10|  tab[i] = pos;
   94|     10|  ++len;
   95|     10|}
_ZN10XRefPosSet5checkEl:
   97|     10|GBool XRefPosSet::check(GFileOffset pos) {
   98|     10|  int i;
   99|       |
  100|     10|  i = find(pos);
  101|     10|  return i < len && tab[i] == pos;
  ------------------
  |  Branch (101:10): [True: 0, False: 10]
  |  Branch (101:21): [True: 0, False: 0]
  ------------------
  102|     10|}
_ZN10XRefPosSet4findEl:
  104|     20|int XRefPosSet::find(GFileOffset pos) {
  105|     20|  int a, b, m;
  106|       |
  107|     20|  a = - 1;
  108|     20|  b = len;
  109|       |  // invariant: tab[a] < pos < tab[b]
  110|     20|  while (b - a > 1) {
  ------------------
  |  Branch (110:10): [True: 0, False: 20]
  ------------------
  111|      0|    m = (a + b) / 2;
  112|      0|    if (tab[m] < pos) {
  ------------------
  |  Branch (112:9): [True: 0, False: 0]
  ------------------
  113|      0|      a = m;
  114|      0|    } else if (tab[m] > pos) {
  ------------------
  |  Branch (114:16): [True: 0, False: 0]
  ------------------
  115|      0|      b = m;
  116|      0|    } else {
  117|      0|      return m;
  118|      0|    }
  119|      0|  }
  120|     20|  return b;
  121|     20|}
_ZN4XRefC2EP10BaseStreami:
  289|    258|XRef::XRef(BaseStream *strA, GBool repair) {
  290|    258|  GFileOffset pos;
  291|    258|  Object obj;
  292|    258|  XRefPosSet *posSet;
  293|    258|  int i;
  294|       |
  295|    258|  ok = gTrue;
  ------------------
  |  |   17|    258|#define gTrue 1
  ------------------
  296|    258|  errCode = errNone;
  ------------------
  |  |   12|    258|#define errNone             0	// no error
  ------------------
  297|    258|  repaired = gFalse;
  ------------------
  |  |   18|    258|#define gFalse 0
  ------------------
  298|    258|  size = 0;
  299|    258|  last = -1;
  300|    258|  entries = NULL;
  301|    258|  lastStartxrefPos = 0;
  302|    258|  xrefTablePos = NULL;
  303|    258|  xrefTablePosLen = 0;
  304|    258|  streamEnds = NULL;
  305|    258|  streamEndsLen = 0;
  306|  33.2k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  33.2k|#define objStrCacheSize 128
  ------------------
  |  Branch (306:15): [True: 33.0k, False: 258]
  ------------------
  307|  33.0k|    objStrs[i] = NULL;
  308|  33.0k|    objStrLastUse[i] = 0;
  309|  33.0k|  }
  310|    258|  objStrCacheLength = 0;
  311|    258|  objStrTime = 0;
  312|       |
  313|    258|  encrypted = gFalse;
  ------------------
  |  |   18|    258|#define gFalse 0
  ------------------
  314|    258|  permFlags = defPermFlags;
  ------------------
  |  |   41|    258|#define defPermFlags 0xfffc
  ------------------
  315|    258|  ownerPasswordOk = gFalse;
  ------------------
  |  |   18|    258|#define gFalse 0
  ------------------
  316|       |
  317|  4.38k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  4.38k|#define xrefCacheSize 16
  ------------------
  |  Branch (317:15): [True: 4.12k, False: 258]
  ------------------
  318|  4.12k|    cache[i].num = -1;
  319|  4.12k|  }
  320|       |
  321|    258|#if MULTITHREADED
  322|    258|  gInitMutex(&objStrsMutex);
  ------------------
  |  |   51|    258|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  323|    258|  gInitMutex(&cacheMutex);
  ------------------
  |  |   51|    258|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  324|    258|#endif
  325|       |
  326|    258|  str = strA;
  327|    258|  start = str->getStart();
  328|       |
  329|       |  // if the 'repair' flag is set, try to reconstruct the xref table
  330|    258|  if (repair) {
  ------------------
  |  Branch (330:7): [True: 129, False: 129]
  ------------------
  331|    129|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (331:9): [True: 129, False: 0]
  ------------------
  332|    129|      errCode = errDamaged;
  ------------------
  |  |   18|    129|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  333|    129|      return;
  334|    129|    }
  335|      0|    repaired = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  336|       |
  337|       |  // if the 'repair' flag is not set, read the xref table
  338|    129|  } else {
  339|       |
  340|       |    // read the trailer
  341|    129|    pos = getStartXref();
  342|    129|    if (pos == 0) {
  ------------------
  |  Branch (342:9): [True: 119, False: 10]
  ------------------
  343|    119|      errCode = errDamaged;
  ------------------
  |  |   18|    119|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  344|    119|      ok = gFalse;
  ------------------
  |  |   18|    119|#define gFalse 0
  ------------------
  345|    119|      return;
  346|    119|    }
  347|       |
  348|       |    // read the xref table
  349|     10|    posSet = new XRefPosSet();
  350|     10|    while (readXRef(&pos, posSet, gFalse)) ;
  ------------------
  |  |   18|     10|#define gFalse 0
  ------------------
  |  Branch (350:12): [True: 0, False: 10]
  ------------------
  351|     10|    xrefTablePosLen = posSet->getLength();
  352|     10|    xrefTablePos = (GFileOffset *)gmallocn(xrefTablePosLen,
  353|     10|					   sizeof(GFileOffset));
  354|     20|    for (i = 0; i < xrefTablePosLen; ++i)  {
  ------------------
  |  Branch (354:17): [True: 10, False: 10]
  ------------------
  355|     10|      xrefTablePos[i] = posSet->get(i);
  356|     10|    }
  357|     10|    delete posSet;
  358|     10|    if (!ok) {
  ------------------
  |  Branch (358:9): [True: 10, False: 0]
  ------------------
  359|     10|      errCode = errDamaged;
  ------------------
  |  |   18|     10|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  360|     10|      return;
  361|     10|    }
  362|     10|  }
  363|       |
  364|       |  // get the root dictionary (catalog) object
  365|      0|  trailerDict.dictLookupNF("Root", &obj);
  366|      0|  if (obj.isRef()) {
  ------------------
  |  Branch (366:7): [True: 0, False: 0]
  ------------------
  367|      0|    rootNum = obj.getRefNum();
  368|      0|    rootGen = obj.getRefGen();
  369|      0|    obj.free();
  370|      0|  } else {
  371|      0|    obj.free();
  372|      0|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (372:9): [True: 0, False: 0]
  ------------------
  373|      0|      errCode = errDamaged;
  ------------------
  |  |   18|      0|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  374|      0|      return;
  375|      0|    }
  376|      0|  }
  377|       |
  378|       |  // now set the trailer dictionary's xref pointer so we can fetch
  379|       |  // indirect objects from it
  380|      0|  trailerDict.getDict()->setXRef(this);
  381|      0|}
_ZN4XRefD2Ev:
  383|    258|XRef::~XRef() {
  384|    258|  int i;
  385|       |
  386|  4.38k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  4.38k|#define xrefCacheSize 16
  ------------------
  |  Branch (386:15): [True: 4.12k, False: 258]
  ------------------
  387|  4.12k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (387:9): [True: 0, False: 4.12k]
  ------------------
  388|      0|      cache[i].obj.free();
  389|      0|    }
  390|  4.12k|  }
  391|    258|  gfree(entries);
  392|    258|  trailerDict.free();
  393|    258|  if (xrefTablePos) {
  ------------------
  |  Branch (393:7): [True: 10, False: 248]
  ------------------
  394|     10|    gfree(xrefTablePos);
  395|     10|  }
  396|    258|  if (streamEnds) {
  ------------------
  |  Branch (396:7): [True: 0, False: 258]
  ------------------
  397|      0|    gfree(streamEnds);
  398|      0|  }
  399|  33.2k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  33.2k|#define objStrCacheSize 128
  ------------------
  |  Branch (399:15): [True: 33.0k, False: 258]
  ------------------
  400|  33.0k|    if (objStrs[i]) {
  ------------------
  |  Branch (400:9): [True: 0, False: 33.0k]
  ------------------
  401|      0|      delete objStrs[i];
  402|      0|    }
  403|  33.0k|  }
  404|    258|#if MULTITHREADED
  405|    258|  gDestroyMutex(&objStrsMutex);
  ------------------
  |  |   52|    258|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  406|    258|  gDestroyMutex(&cacheMutex);
  ------------------
  |  |   52|    258|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  407|    258|#endif
  408|    258|}
_ZN4XRef12getStartXrefEv:
  411|    129|GFileOffset XRef::getStartXref() {
  412|    129|  char buf[xrefSearchSize+1];
  413|    129|  char *p;
  414|    129|  int n, i;
  415|       |
  416|       |  // read last xrefSearchSize bytes
  417|    129|  str->setPos(xrefSearchSize, -1);
  ------------------
  |  |   30|    129|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  418|    129|  n = str->getBlock(buf, xrefSearchSize);
  ------------------
  |  |   30|    129|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  419|    129|  buf[n] = '\0';
  420|       |
  421|       |  // find startxref
  422|  26.3k|  for (i = n - 9; i >= 0; --i) {
  ------------------
  |  Branch (422:19): [True: 26.2k, False: 113]
  ------------------
  423|  26.2k|    if (!strncmp(&buf[i], "startxref", 9)) {
  ------------------
  |  Branch (423:9): [True: 16, False: 26.2k]
  ------------------
  424|     16|      break;
  425|     16|    }
  426|  26.2k|  }
  427|    129|  if (i < 0) {
  ------------------
  |  Branch (427:7): [True: 113, False: 16]
  ------------------
  428|    113|    return 0;
  429|    113|  }
  430|    100|  for (p = &buf[i+9]; isspace(*p & 0xff); ++p) ;
  ------------------
  |  Branch (430:23): [True: 84, False: 16]
  ------------------
  431|     16|  lastXRefPos = strToFileOffset(p);
  432|     16|  lastStartxrefPos = str->getPos() - n + i;
  433|       |
  434|     16|  return lastXRefPos;
  435|    129|}
_ZN4XRef8readXRefEPlP10XRefPosSeti:
  441|     10|GBool XRef::readXRef(GFileOffset *pos, XRefPosSet *posSet, GBool hybrid) {
  442|     10|  Parser *parser;
  443|     10|  Object obj;
  444|     10|  GBool more;
  445|     10|  char buf[100];
  446|     10|  int n, i;
  447|       |
  448|       |  // check for a loop in the xref tables
  449|     10|  if (posSet->check(*pos)) {
  ------------------
  |  Branch (449:7): [True: 0, False: 10]
  ------------------
  450|      0|    error(errSyntaxWarning, -1, "Infinite loop in xref table");
  451|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  452|      0|  }
  453|     10|  posSet->add(*pos);
  454|       |
  455|       |  // the xref data should either be "xref ..." (for an xref table) or
  456|       |  // "nn gg obj << ... >> stream ..." (for an xref stream); possibly
  457|       |  // preceded by whitespace
  458|     10|  str->setPos(start + *pos);
  459|     10|  n = str->getBlock(buf, 100);
  460|     10|  for (i = 0; i < n && Lexer::isSpace(buf[i]); ++i) ;
  ------------------
  |  Branch (460:15): [True: 0, False: 10]
  |  Branch (460:24): [True: 0, False: 0]
  ------------------
  461|       |
  462|       |  // parse an old-style xref table
  463|     10|  if (!hybrid &&
  ------------------
  |  Branch (463:7): [True: 10, False: 0]
  ------------------
  464|     10|      i + 4 < n &&
  ------------------
  |  Branch (464:7): [True: 0, False: 10]
  ------------------
  465|     10|      buf[i] == 'x' && buf[i+1] == 'r' && buf[i+2] == 'e' && buf[i+3] == 'f' &&
  ------------------
  |  Branch (465:7): [True: 0, False: 0]
  |  Branch (465:24): [True: 0, False: 0]
  |  Branch (465:43): [True: 0, False: 0]
  |  Branch (465:62): [True: 0, False: 0]
  ------------------
  466|     10|      Lexer::isSpace(buf[i+4])) {
  ------------------
  |  Branch (466:7): [True: 0, False: 0]
  ------------------
  467|      0|    more = readXRefTable(pos, i + 5, posSet);
  468|       |
  469|       |  // parse an xref stream
  470|     10|  } else {
  471|     10|    obj.initNull();
  472|     10|    parser = new Parser(NULL,
  473|     10|	       new Lexer(NULL,
  474|     10|		 str->makeSubStream(start + *pos, gFalse, 0, &obj)),
  ------------------
  |  |   18|     10|#define gFalse 0
  ------------------
  475|     10|	       gTrue);
  ------------------
  |  |   17|     10|#define gTrue 1
  ------------------
  476|     10|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|     10|#define gTrue 1
  ------------------
  |  Branch (476:9): [True: 10, False: 0]
  ------------------
  477|     10|      goto err;
  478|     10|    }
  479|      0|    obj.free();
  480|      0|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  |  Branch (480:9): [True: 0, False: 0]
  ------------------
  481|      0|      goto err;
  482|      0|    }
  483|      0|    obj.free();
  484|      0|    if (!parser->getObj(&obj, gTrue)->isCmd("obj")) {
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  |  Branch (484:9): [True: 0, False: 0]
  ------------------
  485|      0|      goto err;
  486|      0|    }
  487|      0|    obj.free();
  488|      0|    if (!parser->getObj(&obj)->isStream()) {
  ------------------
  |  Branch (488:9): [True: 0, False: 0]
  ------------------
  489|      0|      goto err;
  490|      0|    }
  491|      0|    more = readXRefStream(obj.getStream(), pos, hybrid);
  492|      0|    obj.free();
  493|      0|    delete parser;
  494|      0|  }
  495|       |
  496|      0|  return more;
  497|       |
  498|     10| err:
  499|     10|  obj.free();
  500|     10|  delete parser;
  501|     10|  ok = gFalse;
  ------------------
  |  |   18|     10|#define gFalse 0
  ------------------
  502|     10|  return gFalse;
  ------------------
  |  |   18|     10|#define gFalse 0
  ------------------
  503|     10|}
_ZN4XRef13constructXRefEv:
  864|    129|GBool XRef::constructXRef() {
  865|    129|  int *streamObjNums = NULL;
  866|    129|  int streamObjNumsLen = 0;
  867|    129|  int streamObjNumsSize = 0;
  868|    129|  int lastObjNum = -1;
  869|    129|  rootNum = -1;
  870|    129|  int streamEndsSize = 0;
  871|    129|  streamEndsLen = 0;
  872|    129|  char buf[4096 + 1];
  873|    129|  str->reset();
  874|    129|  GFileOffset bufPos = start;
  875|    129|  char *p = buf;
  876|    129|  char *end = buf;
  877|    129|  GBool startOfLine = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  878|    129|  GBool space = gTrue;
  ------------------
  |  |   17|    129|#define gTrue 1
  ------------------
  879|    129|  GBool eof = gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  880|  35.1k|  while (1) {
  ------------------
  |  Branch (880:10): [Folded - Ignored]
  ------------------
  881|  35.1k|    if (end - p < 256 && !eof) {
  ------------------
  |  Branch (881:9): [True: 14.8k, False: 20.3k]
  |  Branch (881:26): [True: 129, False: 14.6k]
  ------------------
  882|    129|      memcpy(buf, p, end - p);
  883|    129|      bufPos += p - buf;
  884|    129|      p = buf + (end - p);
  885|    129|      int n = (int)(buf + 4096 - p);
  886|    129|      int m = str->getBlock(p, n);
  887|    129|      end = p + m;
  888|    129|      *end = '\0';
  889|    129|      p = buf;
  890|    129|      eof = m < n;
  891|    129|    }
  892|  35.1k|    if (p == end && eof) {
  ------------------
  |  Branch (892:9): [True: 129, False: 35.0k]
  |  Branch (892:21): [True: 129, False: 0]
  ------------------
  893|    129|      break;
  894|    129|    }
  895|  35.0k|    if (startOfLine && !strncmp(p, "trailer", 7)) {
  ------------------
  |  Branch (895:9): [True: 1.20k, False: 33.8k]
  |  Branch (895:24): [True: 0, False: 1.20k]
  ------------------
  896|      0|      constructTrailerDict((GFileOffset)(bufPos + (p + 7 - buf)));
  897|      0|      p += 7;
  898|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  899|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  900|  35.0k|    } else if (startOfLine && !strncmp(p, "endstream", 9)) {
  ------------------
  |  Branch (900:16): [True: 1.20k, False: 33.8k]
  |  Branch (900:31): [True: 0, False: 1.20k]
  ------------------
  901|      0|      if (streamEndsLen == streamEndsSize) {
  ------------------
  |  Branch (901:11): [True: 0, False: 0]
  ------------------
  902|      0|	streamEndsSize += 64;
  903|      0|	streamEnds = (GFileOffset *)greallocn(streamEnds, streamEndsSize,
  904|      0|					      sizeof(GFileOffset));
  905|      0|      }
  906|      0|      streamEnds[streamEndsLen++] = (GFileOffset)(bufPos + (p - buf));
  907|      0|      p += 9;
  908|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  909|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  910|  35.0k|    } else if (space && *p >= '0' && *p <= '9') {
  ------------------
  |  Branch (910:16): [True: 18.1k, False: 16.9k]
  |  Branch (910:25): [True: 703, False: 17.4k]
  |  Branch (910:38): [True: 239, False: 464]
  ------------------
  911|    239|      p = constructObjectEntry(p, (GFileOffset)(bufPos + (p - buf)),
  912|    239|			       &lastObjNum);
  913|    239|      startOfLine = gFalse;
  ------------------
  |  |   18|    239|#define gFalse 0
  ------------------
  914|    239|      space = gFalse;
  ------------------
  |  |   18|    239|#define gFalse 0
  ------------------
  915|  34.7k|    } else if (p[0] == '>' && p[1] == '>') {
  ------------------
  |  Branch (915:16): [True: 16, False: 34.7k]
  |  Branch (915:31): [True: 0, False: 16]
  ------------------
  916|      0|      p += 2;
  917|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  918|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  919|       |      // skip any PDF whitespace except for '\0'
  920|      0|      while (*p == '\t' || *p == '\n' || *p == '\x0c' ||
  ------------------
  |  Branch (920:14): [True: 0, False: 0]
  |  Branch (920:28): [True: 0, False: 0]
  |  Branch (920:42): [True: 0, False: 0]
  ------------------
  921|      0|	     *p == '\r' || *p == ' ') {
  ------------------
  |  Branch (921:7): [True: 0, False: 0]
  |  Branch (921:21): [True: 0, False: 0]
  ------------------
  922|      0|	if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (922:6): [True: 0, False: 0]
  |  Branch (922:20): [True: 0, False: 0]
  ------------------
  923|      0|	  startOfLine = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  924|      0|	}
  925|      0|	space = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  926|      0|	++p;
  927|      0|      }
  928|      0|      if (!strncmp(p, "stream", 6)) {
  ------------------
  |  Branch (928:11): [True: 0, False: 0]
  ------------------
  929|      0|	if (lastObjNum >= 0) {
  ------------------
  |  Branch (929:6): [True: 0, False: 0]
  ------------------
  930|      0|	  if (streamObjNumsLen == streamObjNumsSize) {
  ------------------
  |  Branch (930:8): [True: 0, False: 0]
  ------------------
  931|      0|	    streamObjNumsSize += 64;
  932|      0|	    streamObjNums = (int *)greallocn(streamObjNums, streamObjNumsSize,
  933|      0|					     sizeof(int));
  934|      0|	  }
  935|      0|	  streamObjNums[streamObjNumsLen++] = lastObjNum;
  936|      0|	}
  937|      0|	p += 6;
  938|      0|	startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  939|      0|	space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  940|      0|      }
  941|  34.7k|    } else {
  942|  34.7k|      if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (942:11): [True: 116, False: 34.6k]
  |  Branch (942:25): [True: 19, False: 34.6k]
  ------------------
  943|    135|	startOfLine = gTrue;
  ------------------
  |  |   17|    135|#define gTrue 1
  ------------------
  944|    135|	space = gTrue;
  ------------------
  |  |   17|    135|#define gTrue 1
  ------------------
  945|  34.6k|      } else if (Lexer::isSpace(*p & 0xff)) {
  ------------------
  |  Branch (945:18): [True: 17.8k, False: 16.7k]
  ------------------
  946|  17.8k|	space = gTrue;
  ------------------
  |  |   17|  17.8k|#define gTrue 1
  ------------------
  947|  17.8k|      } else {
  948|  16.7k|	startOfLine = gFalse;
  ------------------
  |  |   18|  16.7k|#define gFalse 0
  ------------------
  949|  16.7k|	space = gFalse;
  ------------------
  |  |   18|  16.7k|#define gFalse 0
  ------------------
  950|  16.7k|      }
  951|  34.7k|      ++p;
  952|  34.7k|    }
  953|  35.0k|  }
  954|       |
  955|       |  // read each stream object, check for xref or object stream
  956|    129|  for (int i = 0; i < streamObjNumsLen; ++i) {
  ------------------
  |  Branch (956:19): [True: 0, False: 129]
  ------------------
  957|      0|    Object obj;
  958|      0|    fetch(streamObjNums[i], entries[streamObjNums[i]].gen, &obj);
  959|      0|    if (obj.isStream()) {
  ------------------
  |  Branch (959:9): [True: 0, False: 0]
  ------------------
  960|      0|      Dict *dict = obj.streamGetDict();
  961|      0|      Object type;
  962|      0|      dict->lookup("Type", &type);
  963|      0|      if (type.isName("XRef")) {
  ------------------
  |  Branch (963:11): [True: 0, False: 0]
  ------------------
  964|      0|	saveTrailerDict(dict, gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  965|      0|      } else if (type.isName("ObjStm")) {
  ------------------
  |  Branch (965:18): [True: 0, False: 0]
  ------------------
  966|      0|	constructObjectStreamEntries(&obj, streamObjNums[i]);
  967|      0|      }
  968|      0|      type.free();
  969|      0|    }
  970|      0|    obj.free();
  971|      0|  }
  972|       |
  973|    129|  gfree(streamObjNums);
  974|       |
  975|       |  // if the file is encrypted, then any objects fetched here will be
  976|       |  // incorrect (because decryption is not yet enabled), so clear the
  977|       |  // cache to avoid that problem
  978|  2.19k|  for (int i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  2.19k|#define xrefCacheSize 16
  ------------------
  |  Branch (978:19): [True: 2.06k, False: 129]
  ------------------
  979|  2.06k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (979:9): [True: 0, False: 2.06k]
  ------------------
  980|      0|      cache[i].obj.free();
  981|      0|      cache[i].num = -1;
  982|      0|    }
  983|  2.06k|  }
  984|       |
  985|    129|  if (rootNum < 0) {
  ------------------
  |  Branch (985:7): [True: 129, False: 0]
  ------------------
  986|    129|    error(errSyntaxError, -1, "Couldn't find trailer dictionary");
  987|    129|    return gFalse;
  ------------------
  |  |   18|    129|#define gFalse 0
  ------------------
  988|    129|  }
  989|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  990|    129|}
_ZN4XRef20constructObjectEntryEPclPi:
 1032|    239|char *XRef::constructObjectEntry(char *p, GFileOffset pos, int *objNum) {
 1033|       |  // we look for non-end-of-line space characters here, to deal with
 1034|       |  // situations like:
 1035|       |  //    nnn          <-- garbage digits on a line
 1036|       |  //    nnn nnn obj  <-- actual object
 1037|       |  // and we also ignore '\0' (because it's used to terminate the
 1038|       |  // buffer in this damage-scanning code)
 1039|    239|  int num = 0;
 1040|    684|  do {
 1041|    684|    num = (num * 10) + (*p - '0');
 1042|    684|    ++p;
 1043|    684|  } while (*p >= '0' && *p <= '9' && num < 100000000);
  ------------------
  |  Branch (1043:12): [True: 488, False: 196]
  |  Branch (1043:25): [True: 472, False: 16]
  |  Branch (1043:38): [True: 445, False: 27]
  ------------------
 1044|    239|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1044:7): [True: 82, False: 157]
  |  Branch (1044:21): [True: 75, False: 7]
  |  Branch (1044:37): [True: 75, False: 0]
  ------------------
 1045|     75|    return p;
 1046|     75|  }
 1047|  1.53k|  do {
 1048|  1.53k|    ++p;
 1049|  1.53k|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1049:12): [True: 1.37k, False: 164]
  |  Branch (1049:26): [True: 0, False: 164]
  |  Branch (1049:42): [True: 0, False: 164]
  ------------------
 1050|    164|  if (!(*p >= '0' && *p <= '9')) {
  ------------------
  |  Branch (1050:9): [True: 36, False: 128]
  |  Branch (1050:22): [True: 33, False: 3]
  ------------------
 1051|    131|    return p;
 1052|    131|  }
 1053|     33|  int gen = 0;
 1054|    245|  do {
 1055|    245|    gen = (gen * 10) + (*p - '0');
 1056|    245|    ++p;
 1057|    245|  } while (*p >= '0' && *p <= '9' && gen < 100000000);
  ------------------
  |  Branch (1057:12): [True: 235, False: 10]
  |  Branch (1057:25): [True: 234, False: 1]
  |  Branch (1057:38): [True: 212, False: 22]
  ------------------
 1058|     33|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1058:7): [True: 32, False: 1]
  |  Branch (1058:21): [True: 32, False: 0]
  |  Branch (1058:37): [True: 32, False: 0]
  ------------------
 1059|     32|    return p;
 1060|     32|  }
 1061|     10|  do {
 1062|     10|    ++p;
 1063|     10|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1063:12): [True: 9, False: 1]
  |  Branch (1063:26): [True: 0, False: 1]
  |  Branch (1063:42): [True: 0, False: 1]
  ------------------
 1064|      1|  if (strncmp(p, "obj", 3)) {
  ------------------
  |  Branch (1064:7): [True: 1, False: 0]
  ------------------
 1065|      1|    return p;
 1066|      1|  }
 1067|       |
 1068|      0|  if (constructXRefEntry(num, gen, pos - start, xrefEntryUncompressed)) {
  ------------------
  |  Branch (1068:7): [True: 0, False: 0]
  ------------------
 1069|      0|    *objNum = num;
 1070|      0|  }
 1071|       |
 1072|      0|  return p;
 1073|      1|}
_ZN4XRef15strToFileOffsetEPc:
 1435|     16|GFileOffset XRef::strToFileOffset(char *s) {
 1436|     16|  GFileOffset x, d;
 1437|     16|  char *p;
 1438|       |
 1439|     16|  x = 0;
 1440|    116|  for (p = s; *p && isdigit(*p & 0xff); ++p) {
  ------------------
  |  Branch (1440:15): [True: 113, False: 3]
  |  Branch (1440:21): [True: 102, False: 11]
  ------------------
 1441|    102|    d = *p - '0';
 1442|    102|    if (x > (GFILEOFFSET_MAX - d) / 10) {
  ------------------
  |  |  128|    102|#define GFILEOFFSET_MAX 0x7fffffffffffffffLL
  ------------------
  |  Branch (1442:9): [True: 2, False: 100]
  ------------------
 1443|      2|      break;
 1444|      2|    }
 1445|    100|    x = 10 * x + d;
 1446|    100|  }
 1447|     16|  return x;
 1448|     16|}
_ZN10XRefPosSet9getLengthEv:
   54|     10|  int getLength() { return len; }
_ZN10XRefPosSet3getEi:
   55|     10|  GFileOffset get(int idx) { return tab[idx]; }

_ZN4XRef4isOkEv:
   64|    258|  GBool isOk() { return ok; }
_ZN4XRef12getErrorCodeEv:
   67|    258|  int getErrorCode() { return errCode; }

