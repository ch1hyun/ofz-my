{
    "samples": [

    {
        "benchmark": "output-xpdf-_zn6pdfdoc16displaypagesliceep9outputdeviddiiiiiiiipfipves2_",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "triage": "-",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include \"PDFDoc.h\"\\n#include \"OutputDev.h\"\\n#include \"Object.h\"\\n#include \"Dict.h\"\\n#include \"Stream.h\"\\n\\nclass MyOutputDev : public OutputDev {\\npublic:\\n    GBool upsideDown() override { return true; }\\n    GBool useDrawChar() override { return true; }\\n    GBool interpretType3Chars() override { return true; }\\n    void startStream(Ref streamRef, GfxState *state) override {}\\n    void endStream(Ref streamRef) override {}\\n    void tilingPatternFill(GfxState *state, Gfx *gfx, Object *strRef, int paintType, int tilingType, Dict *resDict, double *mat, double *bbox) override {}\\n    void drawImageMask(GfxState *state, Object *ref, Stream *str) override {}\\n    void drawImage(GfxState *state, Object *ref, Stream *str) override {}\\n    void drawMaskedImage(GfxState *state, Object *ref, Stream *str) override {}\\n    void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str) override {}\\n    void drawForm(Ref id) override {}\\n    void beginStructureItem(const char *tag, int mcid, Dict *dict) override {}\\n    void opiBegin(GfxState *state, Dict *opiDict) override {}\\n    void opiEnd(GfxState *state, Dict *opiDict) override {}\\n};\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    MyOutputDev* outputDev = new MyOutputDev();\\n    int page = stream.ConsumeIntegral<int>();\\n    double xMin = stream.ConsumeFloatingPoint<double>();\\n    double yMin = stream.ConsumeFloatingPoint<double>();\\n    int xMax = stream.ConsumeIntegral<int>();\\n    GBool clip = stream.ConsumeBool();\\n    GBool invert = stream.ConsumeBool();\\n    GBool flush = stream.ConsumeBool();\\n    int hDPI = stream.ConsumeIntegral<int>();\\n    int vDPI = stream.ConsumeIntegral<int>();\\n    int rotate = stream.ConsumeIntegral<int>();\\n    int flags = stream.ConsumeIntegral<int>();\\n    void* loop = new int(0); // Initialize loop object with a dummy value\\n    void* dataPtr = new uint8_t(); // Initialize dataPtr object\\n\\n    PDFDoc::displayPageSlice(outputDev, page, xMin, yMin, xMax, clip, invert, flush, hDPI, vDPI, rotate, flags, loop, dataPtr);\\n\\n    delete outputDev;\\n    delete static_cast<int*>(loop);\\n    delete static_cast<uint8_t*>(dataPtr);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-xpdf-_zn6pdfdoc16displaypagesliceep9outputdeviddiiiiiiiipfipves2_",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "triage": "-",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include \"PDFDoc.h\"\\n#include \"OutputDev.h\"\\n#include \"Error.h\"\\n\\nclass DummyOutputDev : public OutputDev {\\npublic:\\n    GBool upsideDown() override { return gFalse; }\\n    GBool useDrawChar() override { return gFalse; }\\n    GBool interpretType3Chars() override { return gFalse; }\\n};\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Initialize parameters for the function-under-test\\n    DummyOutputDev* dev = new DummyOutputDev();\\n    if (!dev) {\\n        error(err, \"Failed to allocate memory for DummyOutputDev\"); // Fixed error handling\\n        return 1;\\n    }\\n    \\n    int page = stream.ConsumeIntegral<int>();\\n    double xMin = stream.ConsumeFloatingPoint<double>();\\n    double yMin = stream.ConsumeFloatingPoint<double>();\\n    int xMax = stream.ConsumeIntegral<int>();\\n    GBool smoothShade = stream.ConsumeBool();\\n    GBool interpolate = stream.ConsumeBool();\\n    GBool antialias = stream.ConsumeBool();\\n    int params1 = stream.ConsumeIntegral<int>();\\n    int params2 = stream.ConsumeIntegral<int>();\\n    int params3 = stream.ConsumeIntegral<int>();\\n    int params4 = stream.ConsumeIntegral<int>();\\n    void* loop = nullptr;\\n    void* dataPtr = nullptr;\\n\\n    // Call the function-under-test\\n    PDFDoc::displayPageSlice(dev, page, xMin, yMin, xMax, smoothShade, interpolate, antialias, params1, params2, params3, params4, loop, dataPtr);\\n\\n    // Cleanup allocated memory\\n    delete dev;\\n    if (dataPtr != nullptr) {\\n        delete static_cast<void*>(dataPtr);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}