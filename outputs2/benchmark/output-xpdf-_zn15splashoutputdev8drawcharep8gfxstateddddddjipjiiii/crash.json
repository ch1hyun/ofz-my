{
    "samples": [

    {
        "benchmark": "output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "triage": "-",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <vector>\\n#include <cstdint> // For uint8_t\\n#include <cstdlib> // For size_t\\n\\n// Include necessary headers for SplashOutputDev, GfxState, and GBool\\n#include \"GfxState.h\" // Assuming this header defines GfxState\\n#include \"/src/xpdf-4.05/xpdf/OutputDev.h\" // Correct path for CharCode\\n#include \"/src/xpdf-4.05/xpdf/UnicodeMap.h\" // Using UnicodeMap as a replacement for Unicode\\n#include \"/src/xpdf-4.05/xpdf/SplashOutputDev.h\" // Assuming this header defines SplashOutputDev\\n\\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    // Create a FuzzedDataProvider to consume the input data\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Initialize parameters for the drawChar function\\n    std::vector<uint8_t> gfxStateData = stream.ConsumeBytes<uint8_t>(sizeof(GfxState));\\n    if (gfxStateData.size() != sizeof(GfxState)) return 0; // Validate size\\n    GfxState* gfxState = reinterpret_cast<GfxState*>(gfxStateData.data()); // Ensure gfxState is not NULL\\n\\n    double x1 = stream.ConsumeFloatingPoint<double>();\\n    double y1 = stream.ConsumeFloatingPoint<double>();\\n    double x2 = stream.ConsumeFloatingPoint<double>();\\n    double y2 = stream.ConsumeFloatingPoint<double>();\\n    double x3 = stream.ConsumeFloatingPoint<double>();\\n    double y3 = stream.ConsumeFloatingPoint<double>();\\n    // Use the correct type for charCode\\n    CharCode charCode = stream.ConsumeIntegral<CharCode>();\\n    int intParam = stream.ConsumeIntegral<int>();\\n    \\n    // Allocate memory for Unicode and ensure it's not NULL\\n    std::vector<Unicode> unicodeVec;\\n    size_t unicodeSize = stream.ConsumeIntegralInRange<size_t>(1, 100); // Ensure at least 1 Unicode character\\n    unicodeVec.resize(unicodeSize);\\n    if (stream.ConsumeData(unicodeVec.data(), unicodeSize * sizeof(Unicode)) != unicodeSize * sizeof(Unicode)) return 0; // Validate size\\n\\n    int intParam2 = stream.ConsumeIntegral<int>();\\n    GBool boolParam1 = stream.ConsumeBool() ? gTrue : gFalse; // Convert to GBool\\n    GBool boolParam2 = stream.ConsumeBool() ? gTrue : gFalse; // Convert to GBool\\n    GBool boolParam3 = stream.ConsumeBool() ? gTrue : gFalse; // Convert to GBool\\n\\n    // Create a SplashOutputDev instance with valid parameters\\n    SplashColorMode colorMode = splashModeRGB; // Example color mode\\n    int bitmapRowPad = 4; // Example row padding\\n    SplashColorPtr paperColor = nullptr; // Assuming a valid pointer is set elsewhere\\n    SplashOutputDev splashOutputDev(colorMode, bitmapRowPad, gFalse, paperColor);\\n\\n    // Call the function under test\\n    splashOutputDev.drawChar(gfxState, x1, y1, x2, y2, x3, y3, charCode, intParam, unicodeVec.data(), intParam2, boolParam1, boolParam2, boolParam3);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "triage": "-",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <vector>\\n#include <cstdint>\\n#include <string> // Include for std::string\\n#include <cstring> // Include for memcpy\\n\\n// Assuming the necessary includes for SplashOutputDev, GfxState, and GBool are available\\n#include \"GfxState.h\" // Include the header for GfxState\\n#include \"/src/xpdf-4.05/xpdf/OutputDev.h\" // Include the header for OutputDev which contains CharCode\\n#include \"/src/xpdf-4.05/xpdf/CharCodeToUnicode.h\" // Include the header for CharCode to Unicode mapping\\n#include \"/src/xpdf-4.05/xpdf/OutputDev.h\" // Replacing GBool.h with OutputDev.h which contains the declaration for GBool\\n#include \"SplashOutputDev.h\" // Include the header for SplashOutputDev\\n\\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider fuzzed_data(data, size);\\n\\n    // Initialize parameters for the function under test\\n    // Assuming GfxState requires specific parameters, we will provide dummy values\\n    double hDPIA = 72.0; // Example horizontal DPI\\n    double vDPIA = 72.0; // Example vertical DPI\\n    PDFRectangle *pageBox = nullptr; // Assuming a nullptr for the page box\\n    int rotateA = 0; // Example rotation\\n    GBool upsideDown = gFalse; // Example upside down value\\n\\n    GfxState *gfx_state = new GfxState(hDPIA, vDPIA, pageBox, rotateA, upsideDown); // Initialize GfxState with parameters\\n\\n    double param1 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    double param2 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    double param3 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    double param4 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    double param5 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    double param6 = fuzzed_data.ConsumeFloatingPoint<double>();\\n    CharCode char_code = static_cast<CharCode>(fuzzed_data.ConsumeIntegral<int>());\\n    int int_param = fuzzed_data.ConsumeIntegral<int>();\\n\\n    // Unicode pointer initialization\\n    size_t unicode_size = fuzzed_data.ConsumeIntegralInRange<size_t>(1, 100); // Avoiding zero size\\n    std::string unicode_string = fuzzed_data.ConsumeRandomLengthString(); // Using ConsumeRandomLengthString\\n    std::vector<uint8_t> unicode_data(unicode_string.begin(), unicode_string.end()); // Convert string to vector<uint8_t>\\n    if (unicode_data.size() != unicode_size) return 0; // Validate size\\n\\n    // Allocate memory for Unicode array\\n    // Since we don't have the actual Unicode type, we will assume it is a uint32_t for this example\\n    uint32_t *unicode_array = new uint32_t[unicode_size]; // Allocate memory for Unicode array\\n    memcpy(unicode_array, unicode_data.data(), unicode_size * sizeof(uint32_t)); // Fill Unicode array with data\\n\\n    int int_param2 = fuzzed_data.ConsumeIntegral<int>();\\n    GBool bool_param1 = static_cast<GBool>(fuzzed_data.ConsumeIntegral<int>() % 2); // Randomly 0 or 1\\n    GBool bool_param2 = static_cast<GBool>(fuzzed_data.ConsumeIntegral<int>() % 2);\\n    GBool bool_param3 = static_cast<GBool>(fuzzed_data.ConsumeIntegral<int>() % 2);\\n\\n    // Initialize SplashOutputDev with required parameters\\n    SplashOutputDev splash_output_dev(gfx_state); // Assuming SplashOutputDev requires a GfxState pointer\\n\\n    // Call the function under test\\n    splash_output_dev.drawChar(gfx_state, param1, param2, param3, param4, param5, param6, char_code, int_param, unicode_array, int_param2, bool_param1, bool_param2, bool_param3);\\n\\n    // Clean up\\n    delete[] unicode_array;\\n    delete gfx_state;\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}