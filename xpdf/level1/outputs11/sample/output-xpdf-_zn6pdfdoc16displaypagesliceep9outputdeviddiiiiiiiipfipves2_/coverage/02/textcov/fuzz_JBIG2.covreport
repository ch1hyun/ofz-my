LLVMFuzzerTestOneInput:
   27|    159|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   28|    159|  FuzzedDataProvider fdp(data, size);
   29|    159|  double hdpi = fdp.ConsumeFloatingPoint<double>();
   30|    159|  double vdpi = fdp.ConsumeFloatingPoint<double>();
   31|    159|  int rotate = fdp.ConsumeIntegral<int>();
   32|    159|  bool useMediaBox = fdp.ConsumeBool();
   33|    159|  bool crop = fdp.ConsumeBool();
   34|    159|  bool printing = fdp.ConsumeBool();
   35|    159|  std::vector<char> payload = fdp.ConsumeRemainingBytes<char>();
   36|       |
   37|    159|  Object xpdf_obj;
   38|    159|  xpdf_obj.initNull();
   39|    159|  BaseStream *stream = new MemStream(payload.data(), 0, payload.size(), &xpdf_obj);
   40|       |
   41|    159|  Object info, xfa;
   42|    159|  Object *acroForm;
   43|    159|  globalParams = new GlobalParams(NULL);
   44|    159|  globalParams->setErrQuiet(1);
   45|    159|  globalParams->setupBaseFonts(NULL);
   46|    159|  char yes[] = "yes";
   47|    159|  globalParams->setEnableFreeType(yes); // Yes, it's a string and not a bool.
   48|    159|  globalParams->setErrQuiet(1);
   49|       |
   50|    159|  PDFDoc *doc = NULL;
   51|    159|  try {
   52|    159|    PDFDoc doc(stream);
   53|    159|    if (doc.isOk() == gTrue) {
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  |  Branch (53:9): [True: 0, False: 159]
  ------------------
   54|      0|      doc.getNumPages();
   55|      0|      doc.getOutline();
   56|      0|      doc.getStructTreeRoot();
   57|      0|      doc.getXRef();
   58|      0|      doc.okToPrint(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   59|      0|      doc.okToCopy(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   60|      0|      doc.okToChange(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   61|      0|      doc.okToAddNotes(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   62|      0|      doc.isLinearized();
   63|      0|      doc.getPDFVersion();
   64|       |
   65|      0|      GString *metadata;
   66|      0|      if ((metadata = doc.readMetadata())) {
  ------------------
  |  Branch (66:11): [True: 0, False: 0]
  ------------------
   67|      0|        (void)metadata->getCString();
   68|      0|      }
   69|      0|      delete metadata;
   70|       |
   71|      0|      Object info;
   72|      0|      doc.getDocInfo(&info);
   73|      0|      if (info.isDict()) {
  ------------------
  |  Branch (73:11): [True: 0, False: 0]
  ------------------
   74|      0|        info.getDict();
   75|      0|      }
   76|      0|      info.free();
   77|       |
   78|      0|      if ((acroForm = doc.getCatalog()->getAcroForm())->isDict()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|        acroForm->dictLookup("XFA", &xfa);
   80|      0|        xfa.free();
   81|      0|      }
   82|       |
   83|      0|      SplashColor paperColor = {0xff, 0xff, 0xff};
   84|      0|      SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 1, gFalse, paperColor);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   85|      0|      splashOut->setNoComposite(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   86|      0|      splashOut->startDoc(doc.getXRef());
   87|      0|      for (size_t i = 1; i <= doc.getNumPages(); ++i) {
  ------------------
  |  Branch (87:26): [True: 0, False: 0]
  ------------------
   88|      0|        doc.displayPageSlice(splashOut, i, hdpi, vdpi, rotate, useMediaBox, crop, printing, 0, 0, 0, 0, nullptr, nullptr);
   89|      0|      }
   90|      0|      (void)splashOut->getBitmap();
   91|       |
   92|      0|      delete splashOut;
   93|      0|    }
   94|    159|  } catch (...) {
   95|      0|  }
   96|       |
   97|    159|  delete globalParams;
   98|       |
   99|    159|  return 0;
  100|    159|}

_ZN5GHashC2Ei:
   34|  1.74k|GHash::GHash(GBool deleteKeysA) {
   35|  1.74k|  int h;
   36|       |
   37|  1.74k|  deleteKeys = deleteKeysA;
   38|  1.74k|  size = 7;
   39|  1.74k|  tab = (GHashBucket **)gmallocn(size, sizeof(GHashBucket *));
   40|  13.9k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (40:15): [True: 12.2k, False: 1.74k]
  ------------------
   41|  12.2k|    tab[h] = NULL;
   42|  12.2k|  }
   43|  1.74k|  len = 0;
   44|  1.74k|}
_ZN5GHashD2Ev:
   46|  1.74k|GHash::~GHash() {
   47|  1.74k|  GHashBucket *p;
   48|  1.74k|  int h;
   49|       |
   50|  13.9k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (50:15): [True: 12.2k, False: 1.74k]
  ------------------
   51|  13.3k|    while (tab[h]) {
  ------------------
  |  Branch (51:12): [True: 1.11k, False: 12.2k]
  ------------------
   52|  1.11k|      p = tab[h];
   53|  1.11k|      tab[h] = p->next;
   54|  1.11k|      if (deleteKeys) {
  ------------------
  |  Branch (54:11): [True: 159, False: 954]
  ------------------
   55|    159|	delete p->key;
   56|    159|      }
   57|  1.11k|      delete p;
   58|  1.11k|    }
   59|  12.2k|  }
   60|  1.74k|  gfree(tab);
   61|  1.74k|}
_ZN5GHash3addEP7GStringPv:
   63|  1.11k|void GHash::add(GString *key, void *val) {
   64|  1.11k|  GHashBucket *p;
   65|  1.11k|  int h;
   66|       |
   67|       |  // expand the table if necessary
   68|  1.11k|  if (len >= size) {
  ------------------
  |  Branch (68:7): [True: 0, False: 1.11k]
  ------------------
   69|      0|    expand();
   70|      0|  }
   71|       |
   72|       |  // add the new symbol
   73|  1.11k|  p = new GHashBucket;
   74|  1.11k|  p->key = key;
   75|  1.11k|  p->val.p = val;
   76|  1.11k|  h = hash(key);
   77|  1.11k|  p->next = tab[h];
   78|  1.11k|  tab[h] = p;
   79|  1.11k|  ++len;
   80|  1.11k|}
_ZN5GHash6lookupEPKc:
  149|  7.31k|void *GHash::lookup(const char *key) {
  150|  7.31k|  GHashBucket *p;
  151|  7.31k|  int h;
  152|       |
  153|  7.31k|  if (!(p = find(key, &h))) {
  ------------------
  |  Branch (153:7): [True: 7.31k, False: 0]
  ------------------
  154|  7.31k|    return NULL;
  155|  7.31k|  }
  156|      0|  return p->val.p;
  157|  7.31k|}
_ZN5GHash9startIterEPP9GHashIter:
  261|  1.59k|void GHash::startIter(GHashIter **iter) {
  262|  1.59k|  *iter = new GHashIter;
  263|  1.59k|  (*iter)->h = -1;
  264|  1.59k|  (*iter)->p = NULL;
  265|  1.59k|}
_ZN5GHash7getNextEPP9GHashIterPP7GStringPPv:
  267|  2.70k|GBool GHash::getNext(GHashIter **iter, GString **key, void **val) {
  268|  2.70k|  if (!*iter) {
  ------------------
  |  Branch (268:7): [True: 0, False: 2.70k]
  ------------------
  269|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  270|      0|  }
  271|  2.70k|  if ((*iter)->p) {
  ------------------
  |  Branch (271:7): [True: 1.11k, False: 1.59k]
  ------------------
  272|  1.11k|    (*iter)->p = (*iter)->p->next;
  273|  1.11k|  }
  274|  13.8k|  while (!(*iter)->p) {
  ------------------
  |  Branch (274:10): [True: 12.7k, False: 1.11k]
  ------------------
  275|  12.7k|    if (++(*iter)->h == size) {
  ------------------
  |  Branch (275:9): [True: 1.59k, False: 11.1k]
  ------------------
  276|  1.59k|      delete *iter;
  277|  1.59k|      *iter = NULL;
  278|  1.59k|      return gFalse;
  ------------------
  |  |   18|  1.59k|#define gFalse 0
  ------------------
  279|  1.59k|    }
  280|  11.1k|    (*iter)->p = tab[(*iter)->h];
  281|  11.1k|  }
  282|  1.11k|  *key = (*iter)->p->key;
  283|  1.11k|  *val = (*iter)->p->val.p;
  284|  1.11k|  return gTrue;
  ------------------
  |  |   17|  1.11k|#define gTrue 1
  ------------------
  285|  2.70k|}
_ZN5GHash4findEPKcPi:
  348|  7.31k|GHashBucket *GHash::find(const char *key, int *h) {
  349|  7.31k|  GHashBucket *p;
  350|       |
  351|  7.31k|  *h = hash(key);
  352|  7.31k|  for (p = tab[*h]; p; p = p->next) {
  ------------------
  |  Branch (352:21): [True: 0, False: 7.31k]
  ------------------
  353|      0|    if (!p->key->cmp(key)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 0]
  ------------------
  354|      0|      return p;
  355|      0|    }
  356|      0|  }
  357|  7.31k|  return NULL;
  358|  7.31k|}
_ZN5GHash4hashEP7GString:
  360|  1.11k|int GHash::hash(GString *key) {
  361|  1.11k|  const char *p;
  362|  1.11k|  unsigned int h;
  363|  1.11k|  int i;
  364|       |
  365|  1.11k|  h = 0;
  366|  8.58k|  for (p = key->getCString(), i = 0; i < key->getLength(); ++p, ++i) {
  ------------------
  |  Branch (366:38): [True: 7.47k, False: 1.11k]
  ------------------
  367|  7.47k|    h = 17 * h + (int)(*p & 0xff);
  368|  7.47k|  }
  369|  1.11k|  return (int)(h % size);
  370|  1.11k|}
_ZN5GHash4hashEPKc:
  372|  7.31k|int GHash::hash(const char *key) {
  373|  7.31k|  const char *p;
  374|  7.31k|  unsigned int h;
  375|       |
  376|  7.31k|  h = 0;
  377|   100k|  for (p = key; *p; ++p) {
  ------------------
  |  Branch (377:17): [True: 93.0k, False: 7.31k]
  ------------------
  378|  93.0k|    h = 17 * h + (int)(*p & 0xff);
  379|  93.0k|  }
  380|  7.31k|  return (int)(h % size);
  381|  7.31k|}

_ZN5GListC2Ev:
   21|  10.9k|GList::GList() {
   22|  10.9k|  size = 8;
   23|  10.9k|  data = (void **)gmallocn(size, sizeof(void*));
   24|  10.9k|  length = 0;
   25|  10.9k|  inc = 0;
   26|  10.9k|}
_ZN5GListD2Ev:
   35|  10.9k|GList::~GList() {
   36|  10.9k|  gfree(data);
   37|  10.9k|}
_ZN5GList6appendEPv:
   49|  21.4k|void GList::append(void *p) {
   50|  21.4k|  if (length >= size) {
  ------------------
  |  Branch (50:7): [True: 636, False: 20.8k]
  ------------------
   51|    636|    expand();
   52|    636|  }
   53|  21.4k|  data[length++] = p;
   54|  21.4k|}
_ZN5GList6expandEv:
  116|    636|void GList::expand() {
  117|    636|  size += (inc > 0) ? inc : size;
  ------------------
  |  Branch (117:11): [True: 0, False: 636]
  ------------------
  118|    636|  data = (void **)greallocn(data, size, sizeof(void*));
  119|    636|}

_ZN5GList9getLengthEv:
   35|  32.4k|  int getLength() { return length; }
_ZN5GList3getEi:
   44|  21.4k|  void *get(int i) { return data[i]; }

_ZN7GStringC2EPKc:
  135|  28.6k|GString::GString(const char *sA) {
  136|  28.6k|  int n = (int)strlen(sA);
  137|       |
  138|  28.6k|  s = NULL;
  139|  28.6k|  resize(length = n);
  140|  28.6k|  memcpy(s, sA, n + 1);
  141|  28.6k|}
_ZN7GStringC2EPKci:
  143|      7|GString::GString(const char *sA, int lengthA) {
  144|      7|  s = NULL;
  145|      7|  resize(length = lengthA);
  146|      7|  memcpy(s, sA, length * sizeof(char));
  147|      7|  s[length] = '\0';
  148|      7|}
_ZN7GStringC2EPS_:
  157|      1|GString::GString(GString *str) {
  158|      1|  s = NULL;
  159|      1|  resize(length = str->getLength());
  160|      1|  memcpy(s, str->getCString(), length + 1);
  161|      1|}
_ZN7GStringD2Ev:
  204|  28.6k|GString::~GString() {
  205|  28.6k|  delete[] s;
  206|  28.6k|}
_ZN7GString6appendEc:
  214|  11.9k|GString *GString::append(char c) {
  215|  11.9k|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 11.9k]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|  11.9k|  resize(length + 1);
  219|  11.9k|  s[length++] = c;
  220|  11.9k|  s[length] = '\0';
  221|  11.9k|  return this;
  222|  11.9k|}
_ZN7GString6appendEPKc:
  236|  11.9k|GString *GString::append(const char *str) {
  237|  11.9k|  int n = (int)strlen(str);
  238|       |
  239|  11.9k|  if (length > INT_MAX - n) {
  ------------------
  |  Branch (239:7): [True: 0, False: 11.9k]
  ------------------
  240|      0|    gMemError("Integer overflow in GString::append()");
  241|      0|  }
  242|  11.9k|  resize(length + n);
  243|  11.9k|  memcpy(s + length, str, n + 1);
  244|  11.9k|  length += n;
  245|  11.9k|  return this;
  246|  11.9k|}
_ZN7GString6appendEPKci:
  248|      1|GString *GString::append(const char *str, int lengthA) {
  249|      1|  if (lengthA < 0 || length > INT_MAX - lengthA) {
  ------------------
  |  Branch (249:7): [True: 0, False: 1]
  |  Branch (249:22): [True: 0, False: 1]
  ------------------
  250|      0|    gMemError("Integer overflow in GString::append()");
  251|      0|  }
  252|      1|  resize(length + lengthA);
  253|      1|  memcpy(s + length, str, lengthA);
  254|      1|  length += lengthA;
  255|      1|  s[length] = '\0';
  256|      1|  return this;
  257|      1|}
_ZN7GString6resizeEi:
  108|  52.4k|inline void GString::resize(int length1) {
  109|  52.4k|  char *s1;
  110|       |
  111|  52.4k|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 52.4k]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|  52.4k|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 28.6k, False: 23.8k]
  ------------------
  115|  28.6k|    s = new char[size(length1)];
  116|  28.6k|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 7.47k, False: 16.3k]
  ------------------
  117|  7.47k|    s1 = new char[size(length1)];
  118|  7.47k|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 7.47k]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|  7.47k|    } else {
  122|  7.47k|      memcpy(s1, s, length + 1);
  123|  7.47k|    }
  124|  7.47k|    delete[] s;
  125|  7.47k|    s = s1;
  126|  7.47k|  }
  127|  52.4k|}
GString.cc:_ZL4sizei:
   98|  83.8k|static inline int size(int len) {
   99|  83.8k|  int delta;
  100|   256k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 172k, False: 83.8k]
  |  Branch (100:34): [True: 172k, False: 0]
  ------------------
  101|  83.8k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 83.8k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|  83.8k|  return (len + delta) & ~(delta - 1);
  106|  83.8k|}

_ZN7GString10getCStringEv:
   79|  12.5k|  char *getCString() { return s; }
_ZN7GString4copyEv:
   38|      1|  GString *copy() { return new GString(this); }
_ZN7GString9getLengthEv:
   76|  32.4k|  int getLength() { return length; }
_ZN7GString7getCharEi:
   82|  11.9k|  char getChar(int i) { return s[i]; }

_Z10getHomeDirv:
   49|    795|GString *getHomeDir() {
   50|       |#ifdef VMS
   51|       |  //---------- VMS ----------
   52|       |  return new GString("SYS$LOGIN:");
   53|       |
   54|       |#elif defined(_WIN32)
   55|       |  //---------- Win32 ----------
   56|       |  char *s;
   57|       |  GString *ret;
   58|       |
   59|       |  if ((s = getenv("USERPROFILE")))
   60|       |    ret = new GString(s);
   61|       |  else
   62|       |    ret = new GString(".");
   63|       |  return ret;
   64|       |
   65|       |#elif defined(__EMX__)
   66|       |  //---------- OS/2+EMX ----------
   67|       |  char *s;
   68|       |  GString *ret;
   69|       |
   70|       |  if ((s = getenv("HOME")))
   71|       |    ret = new GString(s);
   72|       |  else
   73|       |    ret = new GString(".");
   74|       |  return ret;
   75|       |
   76|       |#elif defined(ACORN)
   77|       |  //---------- RISCOS ----------
   78|       |  return new GString("@");
   79|       |
   80|       |#else
   81|       |  //---------- Unix ----------
   82|    795|  char *s;
   83|    795|  struct passwd *pw;
   84|    795|  GString *ret;
   85|       |
   86|    795|  if ((s = getenv("HOME"))) {
  ------------------
  |  Branch (86:7): [True: 795, False: 0]
  ------------------
   87|    795|    ret = new GString(s);
   88|    795|  } else {
   89|      0|    if ((s = getenv("USER")))
  ------------------
  |  Branch (89:9): [True: 0, False: 0]
  ------------------
   90|      0|      pw = getpwnam(s);
   91|      0|    else
   92|      0|      pw = getpwuid(getuid());
   93|      0|    if (pw)
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      ret = new GString(pw->pw_dir);
   95|      0|    else
   96|      0|      ret = new GString(".");
   97|      0|  }
   98|    795|  return ret;
   99|    795|#endif
  100|    795|}
_Z12appendToPathP7GStringPKc:
  118|  11.9k|GString *appendToPath(GString *path, const char *fileName) {
  119|       |#if defined(VMS)
  120|       |  //---------- VMS ----------
  121|       |  //~ this should handle everything necessary for file
  122|       |  //~ requesters, but it's certainly not complete
  123|       |  char *p0, *p1, *p2;
  124|       |  char *q1;
  125|       |
  126|       |  p0 = path->getCString();
  127|       |  p1 = p0 + path->getLength() - 1;
  128|       |  if (!strcmp(fileName, "-")) {
  129|       |    if (*p1 == ']') {
  130|       |      for (p2 = p1; p2 > p0 && *p2 != '.' && *p2 != '['; --p2) ;
  131|       |      if (*p2 == '[')
  132|       |	++p2;
  133|       |      path->del(p2 - p0, p1 - p2);
  134|       |    } else if (*p1 == ':') {
  135|       |      path->append("[-]");
  136|       |    } else {
  137|       |      path->clear();
  138|       |      path->append("[-]");
  139|       |    }
  140|       |  } else if ((q1 = strrchr(fileName, '.')) && !strncmp(q1, ".DIR;", 5)) {
  141|       |    if (*p1 == ']') {
  142|       |      path->insert(p1 - p0, '.');
  143|       |      path->insert(p1 - p0 + 1, fileName, q1 - fileName);
  144|       |    } else if (*p1 == ':') {
  145|       |      path->append('[');
  146|       |      path->append(']');
  147|       |      path->append(fileName, q1 - fileName);
  148|       |    } else {
  149|       |      path->clear();
  150|       |      path->append(fileName, q1 - fileName);
  151|       |    }
  152|       |  } else {
  153|       |    if (*p1 != ']' && *p1 != ':')
  154|       |      path->clear();
  155|       |    path->append(fileName);
  156|       |  }
  157|       |  return path;
  158|       |
  159|       |#elif defined(_WIN32)
  160|       |  //---------- Win32 ----------
  161|       |  GString *tmp;
  162|       |  char buf[256];
  163|       |  char *fp;
  164|       |
  165|       |  tmp = new GString(path);
  166|       |  tmp->append('/');
  167|       |  tmp->append(fileName);
  168|       |  GetFullPathNameA(tmp->getCString(), sizeof(buf), buf, &fp);
  169|       |  delete tmp;
  170|       |  path->clear();
  171|       |  path->append(buf);
  172|       |  return path;
  173|       |
  174|       |#elif defined(ACORN)
  175|       |  //---------- RISCOS ----------
  176|       |  char *p;
  177|       |  int i;
  178|       |
  179|       |  path->append(".");
  180|       |  i = path->getLength();
  181|       |  path->append(fileName);
  182|       |  for (p = path->getCString() + i; *p; ++p) {
  183|       |    if (*p == '/') {
  184|       |      *p = '.';
  185|       |    } else if (*p == '.') {
  186|       |      *p = '/';
  187|       |    }
  188|       |  }
  189|       |  return path;
  190|       |
  191|       |#elif defined(__EMX__)
  192|       |  //---------- OS/2+EMX ----------
  193|       |  int i;
  194|       |
  195|       |  // appending "." does nothing
  196|       |  if (!strcmp(fileName, "."))
  197|       |    return path;
  198|       |
  199|       |  // appending ".." goes up one directory
  200|       |  if (!strcmp(fileName, "..")) {
  201|       |    for (i = path->getLength() - 2; i >= 0; --i) {
  202|       |      if (path->getChar(i) == '/' || path->getChar(i) == '\\' ||
  203|       |	  path->getChar(i) == ':')
  204|       |	break;
  205|       |    }
  206|       |    if (i <= 0) {
  207|       |      if (path->getChar(0) == '/' || path->getChar(0) == '\\') {
  208|       |	path->del(1, path->getLength() - 1);
  209|       |      } else if (path->getLength() >= 2 && path->getChar(1) == ':') {
  210|       |	path->del(2, path->getLength() - 2);
  211|       |      } else {
  212|       |	path->clear();
  213|       |	path->append("..");
  214|       |      }
  215|       |    } else {
  216|       |      if (path->getChar(i-1) == ':')
  217|       |	++i;
  218|       |      path->del(i, path->getLength() - i);
  219|       |    }
  220|       |    return path;
  221|       |  }
  222|       |
  223|       |  // otherwise, append "/" and new path component
  224|       |  if (path->getLength() > 0 &&
  225|       |      path->getChar(path->getLength() - 1) != '/' &&
  226|       |      path->getChar(path->getLength() - 1) != '\\')
  227|       |    path->append('/');
  228|       |  path->append(fileName);
  229|       |  return path;
  230|       |
  231|       |#else
  232|       |  //---------- Unix ----------
  233|  11.9k|  int i;
  234|       |
  235|       |  // appending "." does nothing
  236|  11.9k|  if (!strcmp(fileName, "."))
  ------------------
  |  Branch (236:7): [True: 0, False: 11.9k]
  ------------------
  237|      0|    return path;
  238|       |
  239|       |  // appending ".." goes up one directory
  240|  11.9k|  if (!strcmp(fileName, "..")) {
  ------------------
  |  Branch (240:7): [True: 0, False: 11.9k]
  ------------------
  241|      0|    for (i = path->getLength() - 2; i >= 0; --i) {
  ------------------
  |  Branch (241:37): [True: 0, False: 0]
  ------------------
  242|      0|      if (path->getChar(i) == '/')
  ------------------
  |  Branch (242:11): [True: 0, False: 0]
  ------------------
  243|      0|	break;
  244|      0|    }
  245|      0|    if (i <= 0) {
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|      if (path->getChar(0) == '/') {
  ------------------
  |  Branch (246:11): [True: 0, False: 0]
  ------------------
  247|      0|	path->del(1, path->getLength() - 1);
  248|      0|      } else {
  249|      0|	path->clear();
  250|      0|	path->append("..");
  251|      0|      }
  252|      0|    } else {
  253|      0|      path->del(i, path->getLength() - i);
  254|      0|    }
  255|      0|    return path;
  256|      0|  }
  257|       |
  258|       |  // otherwise, append "/" and new path component
  259|  11.9k|  if (path->getLength() > 0 &&
  ------------------
  |  Branch (259:7): [True: 11.9k, False: 0]
  ------------------
  260|  11.9k|      path->getChar(path->getLength() - 1) != '/')
  ------------------
  |  Branch (260:7): [True: 11.9k, False: 0]
  ------------------
  261|  11.9k|    path->append('/');
  262|  11.9k|  path->append(fileName);
  263|  11.9k|  return path;
  264|  11.9k|#endif
  265|  11.9k|}

_Z7gmalloci:
  139|   727k|void *gmalloc(int size) GMEM_EXCEP {
  140|   727k|  void *p;
  141|       |
  142|   727k|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 727k]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|   727k|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 727k]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|   727k|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 727k]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|   727k|  return p;
  152|   727k|}
_Z8greallocPvi:
  155|    712|void *grealloc(void *p, int size) GMEM_EXCEP {
  156|       |#ifdef DEBUG_MEM
  157|       |  GMemHdr *hdr;
  158|       |  void *q;
  159|       |  int oldSize;
  160|       |
  161|       |  if (size < 0) {
  162|       |    gMemError("Invalid memory allocation size");
  163|       |  }
  164|       |  if (size == 0) {
  165|       |    if (p) {
  166|       |      gfree(p);
  167|       |    }
  168|       |    return NULL;
  169|       |  }
  170|       |  if (p) {
  171|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  172|       |    oldSize = (int)hdr->size;
  173|       |    q = gmalloc(size);
  174|       |    memcpy(q, p, size < oldSize ? size : oldSize);
  175|       |    gfree(p);
  176|       |  } else {
  177|       |    q = gmalloc(size);
  178|       |  }
  179|       |  return q;
  180|       |#else
  181|    712|  void *q;
  182|       |
  183|    712|  if (size < 0) {
  ------------------
  |  Branch (183:7): [True: 0, False: 712]
  ------------------
  184|      0|    gMemError("Invalid memory allocation size");
  185|      0|  }
  186|    712|  if (size == 0) {
  ------------------
  |  Branch (186:7): [True: 0, False: 712]
  ------------------
  187|      0|    if (p) {
  ------------------
  |  Branch (187:9): [True: 0, False: 0]
  ------------------
  188|      0|      free(p);
  189|      0|    }
  190|      0|    return NULL;
  191|      0|  }
  192|    712|  if (p) {
  ------------------
  |  Branch (192:7): [True: 636, False: 76]
  ------------------
  193|    636|    q = realloc(p, size);
  194|    636|  } else {
  195|     76|    q = malloc(size);
  196|     76|  }
  197|    712|  if (!q) {
  ------------------
  |  Branch (197:7): [True: 0, False: 712]
  ------------------
  198|      0|    gMemError("Out of memory");
  199|      0|  }
  200|    712|  return q;
  201|    712|#endif
  202|    712|}
_Z8gmallocnii:
  204|  17.7k|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|  17.7k|  int n;
  206|       |
  207|  17.7k|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 17.7k]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|  17.7k|  n = nObjs * objSize;
  211|  17.7k|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 17.7k]
  |  Branch (211:23): [True: 0, False: 17.7k]
  |  Branch (211:36): [True: 0, False: 17.7k]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|  17.7k|  return gmalloc(n);
  215|  17.7k|}
_Z9greallocnPvii:
  291|    712|void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
  292|    712|  int n;
  293|       |
  294|    712|  if (nObjs == 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 712]
  ------------------
  295|      0|    if (p) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      gfree(p);
  297|      0|    }
  298|      0|    return NULL;
  299|      0|  }
  300|    712|  n = nObjs * objSize;
  301|    712|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (301:7): [True: 0, False: 712]
  |  Branch (301:23): [True: 0, False: 712]
  |  Branch (301:36): [True: 0, False: 712]
  ------------------
  302|      0|    gMemError("Bogus memory allocation size");
  303|      0|  }
  304|    712|  return grealloc(p, n);
  305|    712|}
_Z5gfreePv:
  307|   728k|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|   728k|  if (p) {
  ------------------
  |  Branch (348:7): [True: 728k, False: 636]
  ------------------
  349|   728k|    free(p);
  350|   728k|  }
  351|   728k|#endif
  352|   728k|}
_Z10copyStringPKc:
  390|   710k|char *copyString(const char *s) {
  391|   710k|  char *s1;
  392|       |
  393|   710k|  s1 = (char *)gmalloc((int)strlen(s) + 1);
  394|   710k|  strcpy(s1, s);
  395|   710k|  return s1;
  396|   710k|}

_ZN5ArrayC2EP4XRef:
   22|     75|Array::Array(XRef *xrefA) {
   23|     75|  xref = xrefA;
   24|     75|  elems = NULL;
   25|     75|  size = length = 0;
   26|     75|  ref = 1;
   27|     75|}
_ZN5ArrayD2Ev:
   29|     75|Array::~Array() {
   30|     75|  int i;
   31|       |
   32|    150|  for (i = 0; i < length; ++i)
  ------------------
  |  Branch (32:15): [True: 75, False: 75]
  ------------------
   33|     75|    elems[i].free();
   34|     75|  gfree(elems);
   35|     75|}
_ZN5Array3addEP6Object:
   37|     75|void Array::add(Object *elem) {
   38|     75|  if (length == size) {
  ------------------
  |  Branch (38:7): [True: 75, False: 0]
  ------------------
   39|     75|    if (length == 0) {
  ------------------
  |  Branch (39:9): [True: 75, False: 0]
  ------------------
   40|     75|      size = 8;
   41|     75|    } else {
   42|      0|      size *= 2;
   43|      0|    }
   44|     75|    elems = (Object *)greallocn(elems, size, sizeof(Object));
   45|     75|  }
   46|     75|  elems[length] = *elem;
   47|     75|  ++length;
   48|     75|}

_ZN5Array9getLengthEv:
   44|     33|  int getLength() { return length; }

_ZN17BuiltinFontWidthsC2EP16BuiltinFontWidthi:
   20|  2.22k|BuiltinFontWidths::BuiltinFontWidths(BuiltinFontWidth *widths, int sizeA) {
   21|  2.22k|  int i, h;
   22|       |
   23|  2.22k|  size = sizeA;
   24|  2.22k|  tab = (BuiltinFontWidth **)gmallocn(size, sizeof(BuiltinFontWidth *));
   25|   665k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (25:15): [True: 663k, False: 2.22k]
  ------------------
   26|   663k|    tab[i] = NULL;
   27|   663k|  }
   28|   665k|  for (i = 0; i < sizeA; ++i) {
  ------------------
  |  Branch (28:15): [True: 663k, False: 2.22k]
  ------------------
   29|   663k|    h = hash(widths[i].name);
   30|   663k|    widths[i].next = tab[h];
   31|   663k|    tab[h] = &widths[i];
   32|   663k|  }
   33|  2.22k|}
_ZN17BuiltinFontWidthsD2Ev:
   35|  2.22k|BuiltinFontWidths::~BuiltinFontWidths() {
   36|  2.22k|  gfree(tab);
   37|  2.22k|}
_ZN17BuiltinFontWidths4hashEPKc:
   54|   663k|int BuiltinFontWidths::hash(const char *name) {
   55|   663k|  const char *p;
   56|   663k|  unsigned int h;
   57|       |
   58|   663k|  h = 0;
   59|  4.93M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (59:18): [True: 4.27M, False: 663k]
  ------------------
   60|  4.27M|    h = 17 * h + (int)(*p & 0xff);
   61|  4.27M|  }
   62|   663k|  return (int)(h % size);
   63|   663k|}

_Z21initBuiltinFontTablesv:
 4262|    159|void initBuiltinFontTables() {
 4263|    159|  builtinFonts[0].widths = new BuiltinFontWidths(courierWidthsTab, 315);
 4264|    159|  builtinFonts[1].widths = new BuiltinFontWidths(courierBoldWidthsTab, 315);
 4265|    159|  builtinFonts[2].widths = new BuiltinFontWidths(courierBoldObliqueWidthsTab, 315);
 4266|    159|  builtinFonts[3].widths = new BuiltinFontWidths(courierObliqueWidthsTab, 315);
 4267|    159|  builtinFonts[4].widths = new BuiltinFontWidths(helveticaWidthsTab, 315);
 4268|    159|  builtinFonts[5].widths = new BuiltinFontWidths(helveticaBoldWidthsTab, 316);
 4269|    159|  builtinFonts[6].widths = new BuiltinFontWidths(helveticaBoldObliqueWidthsTab, 315);
 4270|    159|  builtinFonts[7].widths = new BuiltinFontWidths(helveticaObliqueWidthsTab, 315);
 4271|    159|  builtinFonts[8].widths = new BuiltinFontWidths(symbolWidthsTab, 190);
 4272|    159|  builtinFonts[9].widths = new BuiltinFontWidths(timesBoldWidthsTab, 315);
 4273|    159|  builtinFonts[10].widths = new BuiltinFontWidths(timesBoldItalicWidthsTab, 315);
 4274|    159|  builtinFonts[11].widths = new BuiltinFontWidths(timesItalicWidthsTab, 315);
 4275|    159|  builtinFonts[12].widths = new BuiltinFontWidths(timesRomanWidthsTab, 315);
 4276|    159|  builtinFonts[13].widths = new BuiltinFontWidths(zapfDingbatsWidthsTab, 202);
 4277|    159|}
_Z21freeBuiltinFontTablesv:
 4279|    159|void freeBuiltinFontTables() {
 4280|    159|  int i;
 4281|       |
 4282|  2.38k|  for (i = 0; i < 14; ++i) {
  ------------------
  |  Branch (4282:15): [True: 2.22k, False: 159]
  ------------------
 4283|  2.22k|    delete builtinFonts[i].widths;
 4284|  2.22k|  }
 4285|    159|}

_ZN9CMapCacheC2Ev:
  387|    159|CMapCache::CMapCache() {
  388|    159|  int i;
  389|       |
  390|    795|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    795|#define cMapCacheSize 4
  ------------------
  |  Branch (390:15): [True: 636, False: 159]
  ------------------
  391|    636|    cache[i] = NULL;
  392|    636|  }
  393|    159|}
_ZN9CMapCacheD2Ev:
  395|    159|CMapCache::~CMapCache() {
  396|    159|  int i;
  397|       |
  398|    795|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    795|#define cMapCacheSize 4
  ------------------
  |  Branch (398:15): [True: 636, False: 159]
  ------------------
  399|    636|    if (cache[i]) {
  ------------------
  |  Branch (399:9): [True: 0, False: 636]
  ------------------
  400|      0|      cache[i]->decRefCnt();
  401|      0|    }
  402|    636|  }
  403|    159|}

_ZN22CharCodeToUnicodeCacheC2Ei:
  709|    318|CharCodeToUnicodeCache::CharCodeToUnicodeCache(int sizeA) {
  710|    318|  int i;
  711|       |
  712|    318|  size = sizeA;
  713|    318|  cache = (CharCodeToUnicode **)gmallocn(size, sizeof(CharCodeToUnicode *));
  714|  1.59k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (714:15): [True: 1.27k, False: 318]
  ------------------
  715|  1.27k|    cache[i] = NULL;
  716|  1.27k|  }
  717|    318|}
_ZN22CharCodeToUnicodeCacheD2Ev:
  719|    318|CharCodeToUnicodeCache::~CharCodeToUnicodeCache() {
  720|    318|  int i;
  721|       |
  722|  1.59k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (722:15): [True: 1.27k, False: 318]
  ------------------
  723|  1.27k|    if (cache[i]) {
  ------------------
  |  Branch (723:9): [True: 0, False: 1.27k]
  ------------------
  724|      0|      cache[i]->decRefCnt();
  725|      0|    }
  726|  1.27k|  }
  727|    318|  gfree(cache);
  728|    318|}

_Z5error13ErrorCategorylPKcz:
   46|  3.21k|		 const char *msg, ...) {
   47|  3.21k|  va_list args;
   48|  3.21k|  GString *s, *sanitized;
   49|  3.21k|  char c;
   50|  3.21k|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|  3.21k|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 3.21k, False: 0]
  |  Branch (53:20): [True: 3.21k, False: 0]
  |  Branch (53:36): [True: 3.21k, False: 0]
  ------------------
   54|  3.21k|    return;
   55|  3.21k|  }
   56|      0|  va_start(args, msg);
   57|      0|  s = GString::formatv(msg, args);
   58|      0|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|      0|  sanitized = new GString();
   63|      0|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 0, False: 0]
  ------------------
   64|      0|    c = s->getChar(i);
   65|      0|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 0, False: 0]
  |  Branch (65:22): [True: 0, False: 0]
  ------------------
   66|      0|      sanitized->append(c);
   67|      0|    } else {
   68|      0|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|      0|    }
   70|      0|  }
   71|       |
   72|      0|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 0]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|      0|  } else {
   75|      0|    fflush(stdout);
   76|      0|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 0]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|      0|    } else {
   80|      0|      fprintf(stderr, "%s: %s\n",
   81|      0|	      errorCategoryNames[category], sanitized->getCString());
   82|      0|    }
   83|      0|    fflush(stderr);
   84|      0|  }
   85|       |
   86|      0|  delete s;
   87|      0|  delete sanitized;
   88|      0|}

_ZN11SysFontListC2Ev:
  374|    159|SysFontList::SysFontList() {
  375|    159|  fonts = new GList();
  376|    159|}
_ZN11SysFontListD2Ev:
  378|    159|SysFontList::~SysFontList() {
  379|    159|  deleteGList(fonts, SysFontInfo);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  380|    159|}
_ZN10KeyBindingC2EiiiPKc:
  560|  9.69k|KeyBinding::KeyBinding(int codeA, int modsA, int contextA, const char *cmd0) {
  561|  9.69k|  code = codeA;
  562|  9.69k|  mods = modsA;
  563|  9.69k|  context = contextA;
  564|  9.69k|  cmds = new GList();
  565|  9.69k|  cmds->append(new GString(cmd0));
  566|  9.69k|}
_ZN10KeyBindingD2Ev:
  585|  9.69k|KeyBinding::~KeyBinding() {
  586|  9.69k|  deleteGList(cmds, GString);
  ------------------
  |  |   94|  9.69k|  do {                                              \
  |  |   95|  9.69k|    GList *_list = (list);                          \
  |  |   96|  9.69k|    {                                               \
  |  |   97|  9.69k|      int _i;                                       \
  |  |   98|  19.3k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 9.69k, False: 9.69k]
  |  |  ------------------
  |  |   99|  9.69k|        delete (T*)_list->get(_i);                  \
  |  |  100|  9.69k|      }                                             \
  |  |  101|  9.69k|      delete _list;                                 \
  |  |  102|  9.69k|    }                                               \
  |  |  103|  9.69k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  587|  9.69k|}
_ZN12GlobalParamsC2EPKc:
  607|    159|GlobalParams::GlobalParams(const char *cfgFileName) {
  608|    159|  UnicodeMap *map;
  609|    159|  GString *fileName;
  610|    159|  FILE *f;
  611|    159|  int i;
  612|       |
  613|    159|#if MULTITHREADED
  614|    159|  gInitMutex(&mutex);
  ------------------
  |  |   51|    159|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  615|    159|  gInitMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   51|    159|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  616|    159|  gInitMutex(&cMapCacheMutex);
  ------------------
  |  |   51|    159|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  617|    159|#endif
  618|       |
  619|       |#ifdef _WIN32
  620|       |  tlsWin32ErrorInfo = TlsAlloc();
  621|       |#endif
  622|       |
  623|    159|  initBuiltinFontTables();
  624|       |
  625|       |  // scan the encoding in reverse because we want the lowest-numbered
  626|       |  // index for each char name ('space' is encoded twice)
  627|    159|  macRomanReverseMap = new NameToCharCode();
  628|  40.8k|  for (i = 255; i >= 0; --i) {
  ------------------
  |  Branch (628:17): [True: 40.7k, False: 159]
  ------------------
  629|  40.7k|    if (macRomanEncoding[i]) {
  ------------------
  |  Branch (629:9): [True: 35.4k, False: 5.24k]
  ------------------
  630|  35.4k|      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);
  631|  35.4k|    }
  632|  40.7k|  }
  633|       |
  634|       |#ifdef _WIN32
  635|       |  // baseDir will be set by a call to setBaseDir
  636|       |  baseDir = new GString();
  637|       |#else
  638|    159|  baseDir = appendToPath(getHomeDir(), ".xpdf");
  639|    159|#endif
  640|    159|  configFileVars = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  641|    159|  setDataDirVar();
  642|    159|  nameToUnicode = new NameToCharCode();
  643|    159|  cidToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  644|    159|  unicodeToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  645|    159|  residentUnicodeMaps = new GHash();
  646|    159|  unicodeMaps = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  647|    159|  cMapDirs = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  648|    159|  toUnicodeDirs = new GList();
  649|    159|  unicodeRemapping = new UnicodeRemapping();
  650|    159|  fontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  651|    159|  fontDirs = new GList();
  652|    159|  ccFontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  653|    159|  base14SysFonts = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  654|    159|  sysFonts = new SysFontList();
  655|       |#if HAVE_PAPER_H
  656|       |  const char *paperName;
  657|       |  const struct paper *paperType;
  658|       |  paperinit();
  659|       |  if ((paperName = systempapername())) {
  660|       |    paperType = paperinfo(paperName);
  661|       |    psPaperWidth = (int)paperpswidth(paperType);
  662|       |    psPaperHeight = (int)paperpsheight(paperType);
  663|       |  } else {
  664|       |    error(errConfig, -1, "No paper information available - using defaults");
  665|       |    psPaperWidth = defPaperWidth;
  666|       |    psPaperHeight = defPaperHeight;
  667|       |  }
  668|       |  paperdone();
  669|       |#else
  670|    159|  psPaperWidth = defPaperWidth;
  ------------------
  |  |   46|    159|#define defPaperWidth  612    // American letter (8.5x11")
  ------------------
  671|    159|  psPaperHeight = defPaperHeight;
  ------------------
  |  |   47|    159|#define defPaperHeight 792
  ------------------
  672|    159|#endif
  673|    159|  psImageableLLX = psImageableLLY = 0;
  674|    159|  psImageableURX = psPaperWidth;
  675|    159|  psImageableURY = psPaperHeight;
  676|    159|  psCrop = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  677|    159|  psUseCropBoxAsPage = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  678|    159|  psExpandSmaller = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  679|    159|  psShrinkLarger = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  680|    159|  psCenter = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  681|    159|  psDuplex = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  682|    159|  psLevel = psLevel2;
  683|    159|  psResidentFonts = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  684|    159|  psResidentFonts16 = new GList();
  685|    159|  psResidentFontsCC = new GList();
  686|    159|  psEmbedType1 = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  687|    159|  psEmbedTrueType = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  688|    159|  psEmbedCIDPostScript = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  689|    159|  psEmbedCIDTrueType = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  690|    159|  psFontPassthrough = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  691|    159|  psPreload = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  692|    159|  psOPI = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  693|    159|  psASCIIHex = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  694|    159|  psLZW = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  695|    159|  psUncompressPreloadedImages = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  696|    159|  psMinLineWidth = 0;
  697|    159|  psRasterResolution = 300;
  698|    159|  psRasterMono = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  699|    159|  psRasterSliceSize = 20000000;
  700|    159|  psAlwaysRasterize = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  701|    159|  psNeverRasterize = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  702|    159|  textEncoding = new GString(defaultTextEncoding);
  703|       |#if defined(_WIN32)
  704|       |  textEOL = eolDOS;
  705|       |#else
  706|    159|  textEOL = eolUnix;
  707|    159|#endif
  708|    159|  textPageBreaks = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  709|    159|  textKeepTinyChars = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  710|    159|  initialZoom = new GString("125");
  711|    159|  defaultFitZoom = 0;
  712|    159|  zoomScaleFactor = 1;
  713|    159|  zoomValues = new GList();
  714|    159|  zoomValues->append(new GString("25"));
  715|    159|  zoomValues->append(new GString("50"));
  716|    159|  zoomValues->append(new GString("75"));
  717|    159|  zoomValues->append(new GString("100"));
  718|    159|  zoomValues->append(new GString("110"));
  719|    159|  zoomValues->append(new GString("125"));
  720|    159|  zoomValues->append(new GString("150"));
  721|    159|  zoomValues->append(new GString("175"));
  722|    159|  zoomValues->append(new GString("200"));
  723|    159|  zoomValues->append(new GString("300"));
  724|    159|  zoomValues->append(new GString("400"));
  725|    159|  zoomValues->append(new GString("600"));
  726|    159|  zoomValues->append(new GString("800"));
  727|    159|  initialDisplayMode = new GString("continuous");
  728|    159|  initialToolbarState = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  729|    159|  initialSidebarState = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  730|    159|  initialSidebarWidth = 0;
  731|    159|  initialSelectMode = new GString("linear");
  732|    159|  maxTileWidth = 1500;
  733|    159|  maxTileHeight = 1500;
  734|    159|  tileCacheSize = 10;
  735|    159|  workerThreads = 1;
  736|    159|  enableFreeType = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  737|    159|  disableFreeTypeHinting = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  738|    159|  antialias = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  739|    159|  vectorAntialias = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  740|    159|  imageMaskAntialias = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  741|    159|  antialiasPrinting = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  742|    159|  strokeAdjust = strokeAdjustNormal;
  743|    159|  screenType = screenUnset;
  744|    159|  screenSize = -1;
  745|    159|  screenDotRadius = -1;
  746|    159|  screenGamma = 1.0;
  747|    159|  screenBlackThreshold = 0.0;
  748|    159|  screenWhiteThreshold = 1.0;
  749|    159|  minLineWidth = 0.0;
  750|    159|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  751|    159|  drawAnnotations = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  752|    159|  drawFormFields = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  753|    159|  enableXFA = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  754|    159|  overprintPreview = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  755|    159|  paperColor = new GString("#ffffff");
  756|    159|  matteColor = new GString("#808080");
  757|    159|  fullScreenMatteColor = new GString("#000000");
  758|    159|  selectionColor = new GString("#8080ff");
  759|    159|  reverseVideoInvertImages = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  760|    159|  allowLinksToChangeZoom = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  761|    159|  launchCommand = NULL;
  762|    159|  movieCommand = NULL;
  763|    159|  defaultPrinter = NULL;
  764|    159|  mapNumericCharNames = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  765|    159|  mapUnknownCharNames = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  766|    159|  mapExtTrueTypeFontsViaUnicode = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  767|    159|  useTrueTypeUnicodeMapping = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  768|    159|  ignoreWrongSizeToUnicode = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  769|    159|  droppedFonts = new GHash(gTrue);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  770|    159|  separateRotatedText = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  771|    159|  createDefaultKeyBindings();
  772|    159|  popupMenuCmds = new GList();
  773|    159|  initStateFilePaths();
  774|    159|  saveSessionOnQuit = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  775|    159|  savePageNumbers = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  776|    159|  printCommands = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  777|    159|  printStatusInfo = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  778|    159|  errQuiet = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  779|    159|  debugLogFile = NULL;
  780|       |
  781|    159|  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);
  ------------------
  |  |   71|    159|#define cidToUnicodeCacheSize     4
  ------------------
  782|    159|  unicodeToUnicodeCache =
  783|    159|      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);
  ------------------
  |  |   72|    159|#define unicodeToUnicodeCacheSize 4
  ------------------
  784|    159|  unicodeMapCache = new UnicodeMapCache();
  785|    159|  cMapCache = new CMapCache();
  786|       |
  787|       |  // set up the initial nameToUnicode table
  788|   674k|  for (i = 0; nameToUnicodeTab[i].name; ++i) {
  ------------------
  |  Branch (788:15): [True: 674k, False: 159]
  ------------------
  789|   674k|    nameToUnicode->add(nameToUnicodeTab[i].name, nameToUnicodeTab[i].u);
  790|   674k|  }
  791|       |
  792|       |  // set up the residentUnicodeMaps table
  793|    159|  map = new UnicodeMap("Latin1", gFalse,
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  794|    159|		       latin1UnicodeMapRanges, latin1UnicodeMapLen);
  ------------------
  |  |   71|    159|#define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  795|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  796|    159|  map = new UnicodeMap("ASCII7", gFalse,
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  797|    159|		       ascii7UnicodeMapRanges, ascii7UnicodeMapLen);
  ------------------
  |  |  207|    159|#define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  798|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  799|    159|  map = new UnicodeMap("Symbol", gFalse,
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  800|    159|		       symbolUnicodeMapRanges, symbolUnicodeMapLen);
  ------------------
  |  |  332|    159|#define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  801|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  802|    159|  map = new UnicodeMap("ZapfDingbats", gFalse, zapfDingbatsUnicodeMapRanges,
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  803|    159|		       zapfDingbatsUnicodeMapLen);
  ------------------
  |  |  366|    159|#define zapfDingbatsUnicodeMapLen (sizeof(zapfDingbatsUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  804|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  805|    159|  map = new UnicodeMap("UTF-8", gTrue, &mapUTF8);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  806|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  807|    159|  map = new UnicodeMap("UCS-2", gTrue, &mapUCS2);
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  808|    159|  residentUnicodeMaps->add(map->getEncodingName(), map);
  809|       |
  810|       |  // look for a user config file, then a system-wide config file
  811|    159|  f = NULL;
  812|    159|  fileName = NULL;
  813|    159|  if (cfgFileName && cfgFileName[0]) {
  ------------------
  |  Branch (813:7): [True: 0, False: 159]
  |  Branch (813:22): [True: 0, False: 0]
  ------------------
  814|      0|    fileName = new GString(cfgFileName);
  815|      0|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (815:9): [True: 0, False: 0]
  ------------------
  816|      0|      delete fileName;
  817|      0|    }
  818|      0|  }
  819|    159|  if (!f) {
  ------------------
  |  Branch (819:7): [True: 159, False: 0]
  ------------------
  820|    159|    fileName = appendToPath(getHomeDir(), xpdfUserConfigFile);
  ------------------
  |  |   58|    159|#define xpdfUserConfigFile ".xpdfrc"
  ------------------
  821|    159|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (821:9): [True: 159, False: 0]
  ------------------
  822|    159|      delete fileName;
  823|    159|    }
  824|    159|  }
  825|    159|  if (!f) {
  ------------------
  |  Branch (825:7): [True: 159, False: 0]
  ------------------
  826|       |#ifdef _WIN32
  827|       |    char buf[512];
  828|       |    i = GetModuleFileNameA(NULL, buf, sizeof(buf));
  829|       |    if (i <= 0 || i >= sizeof(buf)) {
  830|       |      // error or path too long for buffer - just use the current dir
  831|       |      buf[0] = '\0';
  832|       |    }
  833|       |    fileName = grabPath(buf);
  834|       |    appendToPath(fileName, xpdfSysConfigFile);
  835|       |#else
  836|    159|    fileName = new GString(xpdfSysConfigFile);
  ------------------
  |  |   69|    159|#define xpdfSysConfigFile "/etc/xpdfrc"
  ------------------
  837|    159|#endif
  838|    159|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (838:9): [True: 159, False: 0]
  ------------------
  839|    159|      delete fileName;
  840|    159|    }
  841|    159|  }
  842|    159|  if (f) {
  ------------------
  |  Branch (842:7): [True: 0, False: 159]
  ------------------
  843|      0|    parseFile(fileName, f);
  844|      0|    delete fileName;
  845|      0|    fclose(f);
  846|      0|  }
  847|    159|}
_ZN12GlobalParams13setDataDirVarEv:
  849|    159|void GlobalParams::setDataDirVar() {
  850|    159|  GString *dir;
  851|       |
  852|       |#if defined(XPDFRC_DATADIR)
  853|       |  dir = new GString(XPDFRC_DATADIR);
  854|       |#elif defined(_WIN32)
  855|       |  wchar_t buf[512];
  856|       |  DWORD n = GetModuleFileNameW(NULL, buf, sizeof(buf) / sizeof(wchar_t));
  857|       |  if (n <= 0 || n >= sizeof(buf)) {
  858|       |    // error or path too long for buffer - just use the current dir
  859|       |    buf[0] = L'\0';
  860|       |  }
  861|       |  GString *path = fileNameToUTF8(buf);
  862|       |  dir = grabPath(path->getCString());
  863|       |  delete path;
  864|       |  appendToPath(dir, "data");
  865|       |#else
  866|       |  //~ may be useful to allow the options of using the install dir
  867|       |  //~   and/or the user's home dir (?)
  868|    159|  dir = new GString("./data");
  869|    159|#endif
  870|       |
  871|    159|  configFileVars->add(new GString("DATADIR"), dir);
  872|    159|}
_ZN12GlobalParams24createDefaultKeyBindingsEv:
  874|    159|void GlobalParams::createDefaultKeyBindings() {
  875|    159|  keyBindings = new GList();
  876|       |
  877|       |  //----- mouse buttons
  878|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  147|    159|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  879|    159|				     xpdfKeyContextAny, "startSelection"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  880|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  147|    159|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  193|    159|#define xpdfKeyModShift           (1 << 0)
  ------------------
  881|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  882|    159|				     "startExtendedSelection"));
  883|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  156|    159|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  884|    159|				     xpdfKeyContextAny, "endSelection"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  885|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  156|    159|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  193|    159|#define xpdfKeyModShift           (1 << 0)
  ------------------
  886|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  887|    159|				     "endSelection"));
  888|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseDoubleClick1,
  ------------------
  |  |  174|    159|#define xpdfKeyCodeMouseDoubleClick1  0x2301
  ------------------
  889|    159|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  890|    159|				     "selectWord"));
  891|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseTripleClick1,
  ------------------
  |  |  183|    159|#define xpdfKeyCodeMouseTripleClick1  0x2401
  ------------------
  892|    159|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  893|    159|				     "selectLine"));
  894|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  165|    159|#define xpdfKeyCodeMouseClick1        0x2201
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  895|    159|				     xpdfKeyContextAny, "followLinkNoSel"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  896|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  166|    159|#define xpdfKeyCodeMouseClick2        0x2202
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  897|    159|				     xpdfKeyContextOverLink,
  ------------------
  |  |  201|    159|#define xpdfKeyContextOverLink    (1 << 4)
  ------------------
  898|    159|				     "followLinkInNewTab"));
  899|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  148|    159|#define xpdfKeyCodeMousePress2        0x2002
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  900|    159|				     xpdfKeyContextAny, "startPan"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  901|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  157|    159|#define xpdfKeyCodeMouseRelease2      0x2102
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  902|    159|				     xpdfKeyContextAny, "endPan"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  903|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  149|    159|#define xpdfKeyCodeMousePress3        0x2003
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  904|    159|				     xpdfKeyContextAny, "postPopupMenu"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  905|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  150|    159|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  906|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  907|    159|				     "scrollUpPrevPage(16)"));
  908|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  151|    159|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  909|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  910|    159|				     "scrollDownNextPage(16)"));
  911|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  152|    159|#define xpdfKeyCodeMousePress6        0x2006
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  912|    159|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  913|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  153|    159|#define xpdfKeyCodeMousePress7        0x2007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  914|    159|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  915|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  150|    159|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  916|    159|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  917|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  151|    159|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  918|    159|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  919|       |
  920|       |  //----- control keys
  921|    159|  keyBindings->append(new KeyBinding('o', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  922|    159|				     xpdfKeyContextAny, "open"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  923|    159|  keyBindings->append(new KeyBinding('r', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  924|    159|				     xpdfKeyContextAny, "reload"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  925|    159|  keyBindings->append(new KeyBinding('f', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  926|    159|				     xpdfKeyContextAny, "find"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  927|    159|  keyBindings->append(new KeyBinding('g', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  928|    159|				     xpdfKeyContextAny, "findNext"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  929|    159|  keyBindings->append(new KeyBinding('c', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  930|    159|				     xpdfKeyContextAny, "copy"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  931|    159|  keyBindings->append(new KeyBinding('p', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  932|    159|				     xpdfKeyContextAny, "print"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  933|    159|  keyBindings->append(new KeyBinding('0', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  934|    159|				     xpdfKeyContextAny, "zoomPercent(125)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  935|    159|  keyBindings->append(new KeyBinding('+', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  936|    159|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  937|    159|  keyBindings->append(new KeyBinding('=', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  938|    159|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  939|    159|  keyBindings->append(new KeyBinding('-', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  940|    159|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  941|    159|  keyBindings->append(new KeyBinding('s', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  942|    159|				     xpdfKeyContextAny, "saveAs"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  943|    159|  keyBindings->append(new KeyBinding('t', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  944|    159|				     xpdfKeyContextAny, "newTab"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  945|    159|  keyBindings->append(new KeyBinding('n', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  946|    159|				     xpdfKeyContextAny, "newWindow"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  947|    159|  keyBindings->append(new KeyBinding('w', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  948|    159|				     xpdfKeyContextAny, "closeTabOrQuit"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  949|    159|  keyBindings->append(new KeyBinding('l', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  950|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  951|    159|				     "toggleFullScreenMode"));
  952|    159|  keyBindings->append(new KeyBinding('q', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  953|    159|				     xpdfKeyContextAny, "quit"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  954|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  130|    159|#define xpdfKeyCodeTab                0x1000
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  955|    159|				     xpdfKeyContextAny, "nextTab"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  956|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab,
  ------------------
  |  |  130|    159|#define xpdfKeyCodeTab                0x1000
  ------------------
  957|    159|				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  193|    159|#define xpdfKeyModShift           (1 << 0)
  ------------------
              				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  958|    159|				     xpdfKeyContextAny, "prevTab"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  959|    159|  keyBindings->append(new KeyBinding('?', xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  960|    159|				     xpdfKeyContextAny, "help"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  961|       |
  962|       |  //----- alt keys
  963|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  141|    159|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  195|    159|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  964|    159|				     xpdfKeyContextAny, "goBackward"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  965|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  142|    159|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  195|    159|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  966|    159|				     xpdfKeyContextAny, "goForward"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  967|       |
  968|       |  //----- home/end keys
  969|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  137|    159|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  970|    159|				     xpdfKeyContextAny, "gotoPage(1)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  971|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  137|    159|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  972|    159|				     xpdfKeyContextAny, "scrollToTopLeft"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  973|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  138|    159|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  974|    159|				     xpdfKeyContextAny, "gotoLastPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  975|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  138|    159|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  976|    159|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  977|    159|				     "scrollToBottomRight"));
  978|       |
  979|       |  //----- pgup/pgdn keys
  980|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  139|    159|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  981|    159|				     xpdfKeyContextAny, "pageUp"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  982|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  140|    159|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  983|    159|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  984|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    159|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  985|    159|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  986|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    159|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  987|    159|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
  988|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    159|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  989|    159|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    159|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  990|    159|				     "prevPageNoScroll"));
  991|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    159|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  992|    159|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    159|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  993|    159|				     "nextPageNoScroll"));
  994|       |
  995|       |  //----- esc key
  996|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  134|    159|#define xpdfKeyCodeEsc                0x1004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
  997|    159|				     xpdfKeyContextFullScreen,
  ------------------
  |  |  197|    159|#define xpdfKeyContextFullScreen  (1 << 0)
  ------------------
  998|    159|				     "windowMode"));
  999|       |
 1000|       |  //----- arrow keys
 1001|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  141|    159|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1002|    159|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1003|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  142|    159|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1004|    159|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1005|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  143|    159|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1006|    159|				     xpdfKeyContextAny, "scrollUp(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1007|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  144|    159|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1008|    159|				     xpdfKeyContextAny, "scrollDown(16)"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1009|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    159|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1010|    159|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1011|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    159|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1012|    159|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1013|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    159|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1014|    159|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    159|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1015|    159|				     "prevPageNoScroll"));
 1016|    159|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    159|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    159|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1017|    159|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    159|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1018|    159|				     "nextPageNoScroll"));
 1019|       |
 1020|       |  //----- letter keys
 1021|    159|  keyBindings->append(new KeyBinding(' ', xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1022|    159|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1023|    159|  keyBindings->append(new KeyBinding('g', xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1024|    159|				     xpdfKeyContextAny, "focusToPageNum"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1025|    159|  keyBindings->append(new KeyBinding('z', xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1026|    159|				     xpdfKeyContextAny, "zoomFitPage"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1027|    159|  keyBindings->append(new KeyBinding('w', xpdfKeyModNone,
  ------------------
  |  |  192|    159|#define xpdfKeyModNone            0
  ------------------
 1028|    159|				     xpdfKeyContextAny, "zoomFitWidth"));
  ------------------
  |  |  196|    159|#define xpdfKeyContextAny         0
  ------------------
 1029|    159|}
_ZN12GlobalParams18initStateFilePathsEv:
 1031|    159|void GlobalParams::initStateFilePaths() {
 1032|       |#ifdef _WIN32
 1033|       |  char path[MAX_PATH];
 1034|       |  if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL,
 1035|       |		       SHGFP_TYPE_CURRENT, path) != S_OK) {
 1036|       |    return;
 1037|       |  }
 1038|       |  GString *dir = appendToPath(new GString(path), "xpdf");
 1039|       |  CreateDirectoryA(dir->getCString(), NULL);
 1040|       |  pagesFile = appendToPath(dir->copy(), "xpdf.pages");
 1041|       |  tabStateFile = appendToPath(dir->copy(), "xpdf.tab-state");
 1042|       |  sessionFile = appendToPath(dir, "xpdf.session");
 1043|       |#else
 1044|    159|  pagesFile = appendToPath(getHomeDir(), ".xpdf.pages");
 1045|    159|  tabStateFile = appendToPath(getHomeDir(), ".xpdf.tab-state");
 1046|    159|  sessionFile = appendToPath(getHomeDir(), ".xpdf.session");
 1047|    159|#endif
 1048|    159|}
_ZN12GlobalParams11parseYesNo2EPcPi:
 2092|    159|GBool GlobalParams::parseYesNo2(char *token, GBool *flag) {
 2093|    159|  if (!strcmp(token, "yes")) {
  ------------------
  |  Branch (2093:7): [True: 159, False: 0]
  ------------------
 2094|    159|    *flag = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
 2095|    159|  } else if (!strcmp(token, "no")) {
  ------------------
  |  Branch (2095:14): [True: 0, False: 0]
  ------------------
 2096|      0|    *flag = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2097|      0|  } else {
 2098|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2099|      0|  }
 2100|    159|  return gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
 2101|    159|}
_ZN12GlobalParamsD2Ev:
 2179|    159|GlobalParams::~GlobalParams() {
 2180|    159|  GHashIter *iter;
 2181|    159|  GString *key;
 2182|    159|  GList *list;
 2183|       |
 2184|    159|  freeBuiltinFontTables();
 2185|       |
 2186|    159|  delete macRomanReverseMap;
 2187|       |
 2188|    159|  delete baseDir;
 2189|    159|  deleteGHash(configFileVars, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    318|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 159, False: 159]
  |  |  ------------------
  |  |   68|    159|        delete (T*)_p;                             \
  |  |   69|    159|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2190|    159|  delete nameToUnicode;
 2191|    159|  deleteGHash(cidToUnicodes, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2192|    159|  deleteGHash(unicodeToUnicodes, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2193|    159|  deleteGHash(residentUnicodeMaps, UnicodeMap);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|  1.11k|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 954, False: 159]
  |  |  ------------------
  |  |   68|    954|        delete (T*)_p;                             \
  |  |   69|    954|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2194|    159|  deleteGHash(unicodeMaps, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2195|    159|  deleteGList(toUnicodeDirs, GString);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2196|    159|  delete unicodeRemapping;
 2197|    159|  deleteGHash(fontFiles, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2198|    159|  deleteGList(fontDirs, GString);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2199|    159|  deleteGHash(ccFontFiles, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2200|    159|  deleteGHash(base14SysFonts, Base14FontInfo);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2201|    159|  delete sysFonts;
 2202|    159|  deleteGHash(psResidentFonts, GString);
  ------------------
  |  |   60|    159|  do {                                             \
  |  |   61|    159|    GHash *_hash = (hash);                         \
  |  |   62|    159|    {                                              \
  |  |   63|    159|      GHashIter *_iter;                            \
  |  |   64|    159|      GString *_key;                               \
  |  |   65|    159|      void *_p;                                    \
  |  |   66|    159|      _hash->startIter(&_iter);                    \
  |  |   67|    159|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 159]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    159|      delete _hash;                                \
  |  |   71|    159|    }                                              \
  |  |   72|    159|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2203|    159|  deleteGList(psResidentFonts16, PSFontParam16);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2204|    159|  deleteGList(psResidentFontsCC, PSFontParam16);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2205|    159|  delete textEncoding;
 2206|    159|  delete initialZoom;
 2207|    159|  deleteGList(zoomValues, GString);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|  2.22k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 2.06k, False: 159]
  |  |  ------------------
  |  |   99|  2.06k|        delete (T*)_list->get(_i);                  \
  |  |  100|  2.06k|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2208|    159|  delete initialDisplayMode;
 2209|    159|  delete initialSelectMode;
 2210|    159|  if (paperColor) {
  ------------------
  |  Branch (2210:7): [True: 159, False: 0]
  ------------------
 2211|    159|    delete paperColor;
 2212|    159|  }
 2213|    159|  if (matteColor) {
  ------------------
  |  Branch (2213:7): [True: 159, False: 0]
  ------------------
 2214|    159|    delete matteColor;
 2215|    159|  }
 2216|    159|  if (fullScreenMatteColor) {
  ------------------
  |  Branch (2216:7): [True: 159, False: 0]
  ------------------
 2217|    159|    delete fullScreenMatteColor;
 2218|    159|  }
 2219|    159|  if (selectionColor) {
  ------------------
  |  Branch (2219:7): [True: 159, False: 0]
  ------------------
 2220|    159|    delete selectionColor;
 2221|    159|  }
 2222|    159|  if (launchCommand) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 159]
  ------------------
 2223|      0|    delete launchCommand;
 2224|      0|  }
 2225|    159|  if (movieCommand) {
  ------------------
  |  Branch (2225:7): [True: 0, False: 159]
  ------------------
 2226|      0|    delete movieCommand;
 2227|      0|  }
 2228|    159|  if (defaultPrinter) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 159]
  ------------------
 2229|      0|    delete defaultPrinter;
 2230|      0|  }
 2231|    159|  delete droppedFonts;
 2232|    159|  deleteGList(keyBindings, KeyBinding);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|  9.85k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 9.69k, False: 159]
  |  |  ------------------
  |  |   99|  9.69k|        delete (T*)_list->get(_i);                  \
  |  |  100|  9.69k|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2233|    159|  deleteGList(popupMenuCmds, PopupMenuCmd);
  ------------------
  |  |   94|    159|  do {                                              \
  |  |   95|    159|    GList *_list = (list);                          \
  |  |   96|    159|    {                                               \
  |  |   97|    159|      int _i;                                       \
  |  |   98|    159|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 159]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    159|      delete _list;                                 \
  |  |  102|    159|    }                                               \
  |  |  103|    159|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2234|    159|  delete pagesFile;
 2235|    159|  delete tabStateFile;
 2236|    159|  delete sessionFile;
 2237|    159|  delete debugLogFile;
 2238|       |
 2239|    159|  cMapDirs->startIter(&iter);
 2240|    159|  while (cMapDirs->getNext(&iter, &key, (void **)&list)) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 159]
  ------------------
 2241|      0|    deleteGList(list, GString);
  ------------------
  |  |   94|      0|  do {                                              \
  |  |   95|      0|    GList *_list = (list);                          \
  |  |   96|      0|    {                                               \
  |  |   97|      0|      int _i;                                       \
  |  |   98|      0|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 0]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|      0|      delete _list;                                 \
  |  |  102|      0|    }                                               \
  |  |  103|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2242|      0|  }
 2243|    159|  delete cMapDirs;
 2244|       |
 2245|    159|  delete cidToUnicodeCache;
 2246|    159|  delete unicodeToUnicodeCache;
 2247|    159|  delete unicodeMapCache;
 2248|    159|  delete cMapCache;
 2249|       |
 2250|    159|#if MULTITHREADED
 2251|    159|  gDestroyMutex(&mutex);
  ------------------
  |  |   52|    159|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2252|    159|  gDestroyMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   52|    159|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2253|    159|  gDestroyMutex(&cMapCacheMutex);
  ------------------
  |  |   52|    159|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2254|    159|#endif
 2255|    159|}
_ZN12GlobalParams14setupBaseFontsEPKc:
 2347|    159|void GlobalParams::setupBaseFonts(const char *dir) {
 2348|    159|  GString *fontName;
 2349|    159|  GString *fileName;
 2350|    159|  int fontNum;
 2351|    159|  const char *s;
 2352|    159|  Base14FontInfo *base14;
 2353|       |#ifdef _WIN32
 2354|       |  char winFontDir[MAX_PATH];
 2355|       |#endif
 2356|       |#ifdef __APPLE__
 2357|       |  static const char *macFontExts[3] = { "dfont", "ttc", "ttf" };
 2358|       |  GList *dfontFontNames;
 2359|       |  GBool found;
 2360|       |  int k;
 2361|       |#endif
 2362|    159|  FILE *f;
 2363|    159|  int i, j;
 2364|       |
 2365|       |#ifdef _WIN32
 2366|       |  getWinFontDir(winFontDir);
 2367|       |#endif
 2368|       |#ifdef __APPLE__
 2369|       |  dfontFontNames = NULL;
 2370|       |#endif
 2371|  2.38k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2371:15): [True: 2.22k, False: 159]
  ------------------
 2372|  2.22k|    if (fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 2.22k]
  ------------------
 2373|      0|      continue;
 2374|      0|    }
 2375|  2.22k|    fontName = new GString(displayFontTab[i].name);
 2376|  2.22k|    fileName = NULL;
 2377|  2.22k|    fontNum = 0;
 2378|  2.22k|    if (dir) {
  ------------------
  |  Branch (2378:9): [True: 0, False: 2.22k]
  ------------------
 2379|      0|      fileName = appendToPath(new GString(dir), displayFontTab[i].t1FileName);
 2380|      0|      if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2380:11): [True: 0, False: 0]
  ------------------
 2381|      0|	fclose(f);
 2382|      0|      } else {
 2383|      0|	delete fileName;
 2384|      0|	fileName = NULL;
 2385|      0|      }
 2386|      0|    }
 2387|       |#ifdef _WIN32
 2388|       |    if (!fileName && winFontDir[0] && displayFontTab[i].ttFileName) {
 2389|       |      fileName = appendToPath(new GString(winFontDir),
 2390|       |			      displayFontTab[i].ttFileName);
 2391|       |      if ((f = fopen(fileName->getCString(), "rb"))) {
 2392|       |	fclose(f);
 2393|       |      } else {
 2394|       |	delete fileName;
 2395|       |	fileName = NULL;
 2396|       |      }
 2397|       |    }
 2398|       |#endif
 2399|       |#ifdef __APPLE__
 2400|       |    // Check for Mac OS X system fonts.
 2401|       |    s = displayFontTab[i].macFileName;
 2402|       |    if (dfontFontNames && i > 0 &&
 2403|       |	(!s || strcmp(s, displayFontTab[i-1].macFileName))) {
 2404|       |      deleteGList(dfontFontNames, GString);
 2405|       |      dfontFontNames = NULL;
 2406|       |    }
 2407|       |    if (!fileName && s) {
 2408|       |      for (j = 0; j < 3; ++j) {
 2409|       |	fileName = GString::format("{0:s}/{1:s}.{2:s}",
 2410|       |				   macSystemFontPath, s, macFontExts[j]);
 2411|       |	if (!(f = fopen(fileName->getCString(), "rb"))) {
 2412|       |	  delete fileName;
 2413|       |	  fileName = NULL;
 2414|       |	} else {
 2415|       |	  fclose(f);
 2416|       |	  found = gFalse;
 2417|       |	  // for .dfont or .ttc, we need to scan the font list
 2418|       |	  if (j < 2) {
 2419|       |	    if (!dfontFontNames) {
 2420|       |	      dfontFontNames =
 2421|       |	          FoFiIdentifier::getFontList(fileName->getCString());
 2422|       |	    }
 2423|       |	    if (dfontFontNames) {
 2424|       |	      for (k = 0; k < dfontFontNames->getLength(); ++k) {
 2425|       |		if (macFontNameMatches((GString *)dfontFontNames->get(k),
 2426|       |				       displayFontTab[i].macFontName)) {
 2427|       |		  fontNum = k;
 2428|       |		  found = gTrue;
 2429|       |		  break;
 2430|       |		}
 2431|       |	      }
 2432|       |	    }
 2433|       |	  // for .ttf, we just use the font
 2434|       |	  } else {
 2435|       |	    found = gTrue;
 2436|       |	  }
 2437|       |	  if (!found) {
 2438|       |	    delete fileName;
 2439|       |	    fileName = NULL;
 2440|       |	  }
 2441|       |	  break;
 2442|       |	}
 2443|       |      }
 2444|       |    }
 2445|       |#endif // __APPLE__
 2446|       |    // On Linux, this checks the "standard" ghostscript font
 2447|       |    // directories.  On Windows, it checks the "standard" system font
 2448|       |    // directories (because SHGetSpecialFolderPath(CSIDL_FONTS)
 2449|       |    // doesn't work on Win 2k Server or Win2003 Server, or with older
 2450|       |    // versions of shell32.dll).
 2451|       |#ifdef _WIN32
 2452|       |    s = displayFontTab[i].ttFileName;
 2453|       |#else
 2454|  2.22k|    s = displayFontTab[i].t1FileName;
 2455|  2.22k|#endif
 2456|  2.22k|    if (!fileName && s) {
  ------------------
  |  Branch (2456:9): [True: 2.22k, False: 0]
  |  Branch (2456:22): [True: 2.22k, False: 0]
  ------------------
 2457|  13.3k|      for (j = 0; !fileName && displayFontDirs[j]; ++j) {
  ------------------
  |  Branch (2457:19): [True: 13.3k, False: 0]
  |  Branch (2457:32): [True: 11.1k, False: 2.22k]
  ------------------
 2458|  11.1k|	fileName = appendToPath(new GString(displayFontDirs[j]), s);
 2459|  11.1k|	if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2459:6): [True: 0, False: 11.1k]
  ------------------
 2460|      0|	  fclose(f);
 2461|  11.1k|	} else {
 2462|  11.1k|	  delete fileName;
 2463|  11.1k|	  fileName = NULL;
 2464|  11.1k|	}
 2465|  11.1k|      }
 2466|  2.22k|    }
 2467|  2.22k|    if (!fileName) {
  ------------------
  |  Branch (2467:9): [True: 2.22k, False: 0]
  ------------------
 2468|  2.22k|      delete fontName;
 2469|  2.22k|      continue;
 2470|  2.22k|    }
 2471|      0|    base14SysFonts->add(fontName, new Base14FontInfo(fileName, fontNum, 0));
 2472|      0|  }
 2473|       |#ifdef __APPLE__
 2474|       |  if (dfontFontNames) {
 2475|       |    deleteGList(dfontFontNames, GString);
 2476|       |  }
 2477|       |#endif
 2478|  2.38k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2478:15): [True: 2.22k, False: 159]
  ------------------
 2479|  2.22k|    if (!base14SysFonts->lookup(displayFontTab[i].name) &&
  ------------------
  |  Branch (2479:9): [True: 2.22k, False: 0]
  ------------------
 2480|  2.22k|	!fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2480:2): [True: 2.22k, False: 0]
  ------------------
 2481|  2.22k|      if (displayFontTab[i].obliqueFont &&
  ------------------
  |  Branch (2481:11): [True: 636, False: 1.59k]
  ------------------
 2482|  2.22k|	  ((base14 = (Base14FontInfo *)base14SysFonts
  ------------------
  |  Branch (2482:4): [True: 0, False: 636]
  ------------------
 2483|    636|	                 ->lookup(displayFontTab[i].obliqueFont)))) {
 2484|      0|	base14SysFonts->add(
 2485|      0|	        new GString(displayFontTab[i].name),
 2486|      0|		new Base14FontInfo(base14->fileName->copy(),
 2487|      0|				   base14->fontNum,
 2488|      0|				   displayFontTab[i].obliqueFactor));
 2489|  2.22k|      } else {
 2490|  2.22k|	error(errConfig, -1, "No display font for '{0:s}'",
 2491|  2.22k|	      displayFontTab[i].name);
 2492|  2.22k|      }
 2493|  2.22k|    }
 2494|  2.22k|  }
 2495|       |#ifdef _WIN32
 2496|       |  if (winFontDir[0]) {
 2497|       |    sysFonts->scanWindowsFonts(winFontDir);
 2498|       |  }
 2499|       |#endif
 2500|       |#if HAVE_FONTCONFIG
 2501|       |  sysFonts->scanFontconfigFonts();
 2502|       |#endif
 2503|    159|}
_ZN12GlobalParams11getErrQuietEv:
 3562|  3.21k|GBool GlobalParams::getErrQuiet() {
 3563|       |  // no locking -- this function may get called from inside a locked
 3564|       |  // section
 3565|  3.21k|  return errQuiet;
 3566|  3.21k|}
_ZN12GlobalParams17setEnableFreeTypeEPc:
 3888|    159|GBool GlobalParams::setEnableFreeType(char *s) {
 3889|    159|  GBool ok;
 3890|       |
 3891|    159|  lockGlobalParams;
  ------------------
  |  |   50|    159|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    159|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3892|    159|  ok = parseYesNo2(s, &enableFreeType);
 3893|    159|  unlockGlobalParams;
  ------------------
  |  |   53|    159|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    159|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3894|    159|  return ok;
 3895|    159|}
_ZN12GlobalParams11setErrQuietEi:
 4010|    318|void GlobalParams::setErrQuiet(GBool errQuietA) {
 4011|    318|  lockGlobalParams;
  ------------------
  |  |   50|    318|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    318|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 4012|    318|  errQuiet = errQuietA;
 4013|    318|  unlockGlobalParams;
  ------------------
  |  |   53|    318|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    318|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 4014|    318|}

_ZN5LexerC2EP4XRefP6Stream:
   46|     75|Lexer::Lexer(XRef *xref, Stream *str) {
   47|     75|  Object obj;
   48|       |
   49|     75|  curStr.initStream(str);
   50|     75|  streams = new Array(xref);
   51|     75|  streams->add(curStr.copy(&obj));
   52|     75|  strPtr = 0;
   53|     75|  freeArray = gTrue;
  ------------------
  |  |   17|     75|#define gTrue 1
  ------------------
   54|     75|  curStr.streamReset();
   55|     75|}
_ZN5LexerD2Ev:
   75|     75|Lexer::~Lexer() {
   76|     75|  if (!curStr.isNone()) {
  ------------------
  |  Branch (76:7): [True: 42, False: 33]
  ------------------
   77|     42|    curStr.streamClose();
   78|     42|    curStr.free();
   79|     42|  }
   80|     75|  if (freeArray) {
  ------------------
  |  Branch (80:7): [True: 75, False: 0]
  ------------------
   81|     75|    delete streams;
   82|     75|  }
   83|     75|}
_ZN5Lexer7getCharEv:
   85|  4.94k|int Lexer::getChar() {
   86|  4.94k|  int c;
   87|       |
   88|  4.94k|  c = EOF;
   89|  4.97k|  while (!curStr.isNone() && (c = curStr.streamGetChar()) == EOF) {
  ------------------
  |  Branch (89:10): [True: 4.93k, False: 44]
  |  Branch (89:30): [True: 33, False: 4.90k]
  ------------------
   90|     33|    curStr.streamClose();
   91|     33|    curStr.free();
   92|     33|    ++strPtr;
   93|     33|    if (strPtr < streams->getLength()) {
  ------------------
  |  Branch (93:9): [True: 0, False: 33]
  ------------------
   94|      0|      streams->get(strPtr, &curStr);
   95|      0|      curStr.streamReset();
   96|      0|    }
   97|     33|  }
   98|  4.94k|  return c;
   99|  4.94k|}
_ZN5Lexer8lookCharEv:
  101|  2.52k|int Lexer::lookChar() {
  102|  2.52k|  if (curStr.isNone()) {
  ------------------
  |  Branch (102:7): [True: 0, False: 2.52k]
  ------------------
  103|      0|    return EOF;
  104|      0|  }
  105|  2.52k|  return curStr.streamLookChar();
  106|  2.52k|}
_ZN5Lexer6getObjEP6Object:
  108|    232|Object *Lexer::getObj(Object *obj) {
  109|    232|  char *p;
  110|    232|  int c, c2;
  111|    232|  GBool comment, neg, doubleMinus, done, invalid;
  112|    232|  int numParen, nErrors;
  113|    232|  int xi;
  114|    232|  double xf, scale;
  115|    232|  GString *s;
  116|    232|  int n, m;
  117|       |
  118|       |  // skip whitespace and comments
  119|    232|  comment = gFalse;
  ------------------
  |  |   18|    232|#define gFalse 0
  ------------------
  120|  1.91k|  while (1) {
  ------------------
  |  Branch (120:10): [Folded - Ignored]
  ------------------
  121|  1.91k|    if ((c = getChar()) == EOF) {
  ------------------
  |  Branch (121:9): [True: 37, False: 1.88k]
  ------------------
  122|     37|      return obj->initEOF();
  123|     37|    }
  124|  1.88k|    if (comment) {
  ------------------
  |  Branch (124:9): [True: 603, False: 1.27k]
  ------------------
  125|    603|      if (c == '\r' || c == '\n')
  ------------------
  |  Branch (125:11): [True: 2, False: 601]
  |  Branch (125:24): [True: 2, False: 599]
  ------------------
  126|      4|	comment = gFalse;
  ------------------
  |  |   18|      4|#define gFalse 0
  ------------------
  127|  1.27k|    } else if (c == '%') {
  ------------------
  |  Branch (127:16): [True: 18, False: 1.26k]
  ------------------
  128|     18|      comment = gTrue;
  ------------------
  |  |   17|     18|#define gTrue 1
  ------------------
  129|  1.26k|    } else if (specialChars[c] != 1) {
  ------------------
  |  Branch (129:16): [True: 195, False: 1.06k]
  ------------------
  130|    195|      break;
  131|    195|    }
  132|  1.88k|  }
  133|       |
  134|       |  // start reading token
  135|    195|  switch (c) {
  136|       |
  137|       |  // number
  138|      9|  case '0': case '1': case '2': case '3': case '4':
  ------------------
  |  Branch (138:3): [True: 0, False: 195]
  |  Branch (138:13): [True: 7, False: 188]
  |  Branch (138:23): [True: 0, False: 195]
  |  Branch (138:33): [True: 1, False: 194]
  |  Branch (138:43): [True: 1, False: 194]
  ------------------
  139|     18|  case '5': case '6': case '7': case '8': case '9':
  ------------------
  |  Branch (139:3): [True: 2, False: 193]
  |  Branch (139:13): [True: 0, False: 195]
  |  Branch (139:23): [True: 7, False: 188]
  |  Branch (139:33): [True: 0, False: 195]
  |  Branch (139:43): [True: 0, False: 195]
  ------------------
  140|     24|  case '+': case '-': case '.':
  ------------------
  |  Branch (140:3): [True: 1, False: 194]
  |  Branch (140:13): [True: 2, False: 193]
  |  Branch (140:23): [True: 3, False: 192]
  ------------------
  141|       |    // Adobe's number lexer has some "interesting" behavior:
  142|       |    // "--123" is interpreted as 0
  143|       |    // "--123.4" is interpreted as -123.4 [I've seen this in the wild]
  144|       |    // "50-100" is interpreted as 50 [I've seen this in the wild]
  145|       |    // "50--100" is interpreted as 50
  146|       |    // "50-100.0" is an error -- but older versions of Acrobat may
  147|       |    //   have interpreted it as 50100.0 (?)
  148|       |    // "50--100.0" is an error -- but older versions of Acrobat may
  149|       |    //   have interpreted it as 50100.0 (?)
  150|       |    // "50.0-100" is interpreted as 50.0 (or maybe 50.0100?)
  151|       |    // "50.0--100" is interpreted as 50.0 (or maybe 50.0100?)
  152|       |    // "-50-100" is interpreted as -50
  153|       |    // "-" is interpreted as 0
  154|       |    // "-." is interpreted as 0.0
  155|     24|    neg = gFalse;
  ------------------
  |  |   18|     24|#define gFalse 0
  ------------------
  156|     24|    doubleMinus = gFalse;
  ------------------
  |  |   18|     24|#define gFalse 0
  ------------------
  157|     24|    xf = xi = 0;
  158|     24|    if (c == '+') {
  ------------------
  |  Branch (158:9): [True: 1, False: 23]
  ------------------
  159|       |      // just ignore it
  160|     23|    } else if (c == '-') {
  ------------------
  |  Branch (160:16): [True: 2, False: 21]
  ------------------
  161|      2|      neg = gTrue;
  ------------------
  |  |   17|      2|#define gTrue 1
  ------------------
  162|      2|      if (lookChar() == '-') {
  ------------------
  |  Branch (162:11): [True: 0, False: 2]
  ------------------
  163|      0|	doubleMinus = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  164|      0|	do {
  165|      0|	  getChar();
  166|      0|	} while (lookChar() == '-');
  ------------------
  |  Branch (166:11): [True: 0, False: 0]
  ------------------
  167|      0|      }
  168|     21|    } else if (c == '.') {
  ------------------
  |  Branch (168:16): [True: 3, False: 18]
  ------------------
  169|      3|      goto doReal;
  170|     18|    } else {
  171|     18|      xf = xi = c - '0';
  172|     18|    }
  173|     97|    while (1) {
  ------------------
  |  Branch (173:12): [Folded - Ignored]
  ------------------
  174|     97|      c = lookChar();
  175|     97|      if (isdigit(c)) {
  ------------------
  |  Branch (175:11): [True: 76, False: 21]
  ------------------
  176|     76|	getChar();
  177|     76|	xi = xi * 10 + (c - '0');
  178|     76|	if (xf < 1e20) {
  ------------------
  |  Branch (178:6): [True: 72, False: 4]
  ------------------
  179|     72|	  xf = xf * 10 + (c - '0');
  180|     72|	}
  181|     76|      } else if (c == '.') {
  ------------------
  |  Branch (181:18): [True: 0, False: 21]
  ------------------
  182|      0|	getChar();
  183|      0|	goto doReal;
  184|     21|      } else {
  185|     21|	break;
  186|     21|      }
  187|     97|    }
  188|     21|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (188:12): [True: 0, False: 21]
  |  Branch (188:39): [True: 0, False: 21]
  ------------------
  189|      0|      getChar();
  190|      0|    }
  191|     21|    if (neg) {
  ------------------
  |  Branch (191:9): [True: 2, False: 19]
  ------------------
  192|      2|      xi = -xi;
  193|      2|    }
  194|     21|    if (doubleMinus) {
  ------------------
  |  Branch (194:9): [True: 0, False: 21]
  ------------------
  195|      0|      xi = 0;
  196|      0|    }
  197|     21|    obj->initInt(xi);
  198|     21|    break;
  199|      3|  doReal:
  200|      3|    scale = 0.1;
  201|      3|    while (1) {
  ------------------
  |  Branch (201:12): [Folded - Ignored]
  ------------------
  202|      3|      c = lookChar();
  203|      3|      if (c == '-') {
  ------------------
  |  Branch (203:11): [True: 0, False: 3]
  ------------------
  204|      0|	error(errSyntaxWarning, getPos(), "Badly formatted number");
  205|      0|	getChar();
  206|      0|	continue;
  207|      0|      }
  208|      3|      if (!isdigit(c)) {
  ------------------
  |  Branch (208:11): [True: 3, False: 0]
  ------------------
  209|      3|	break;
  210|      3|      }
  211|      0|      getChar();
  212|      0|      xf = xf + scale * (c - '0');
  213|      0|      scale *= 0.1;
  214|      0|    }
  215|      3|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (215:12): [True: 0, False: 3]
  |  Branch (215:39): [True: 0, False: 3]
  ------------------
  216|      0|      getChar();
  217|      0|    }
  218|      3|    if (neg) {
  ------------------
  |  Branch (218:9): [True: 0, False: 3]
  ------------------
  219|      0|      xf = -xf;
  220|      0|    }
  221|      3|    obj->initReal(xf);
  222|      3|    break;
  223|       |
  224|       |  // string
  225|      1|  case '(':
  ------------------
  |  Branch (225:3): [True: 1, False: 194]
  ------------------
  226|      1|    p = tokBuf;
  227|      1|    n = 0;
  228|      1|    numParen = 1;
  229|      1|    done = gFalse;
  ------------------
  |  |   18|      1|#define gFalse 0
  ------------------
  230|      1|    s = NULL;
  231|    140|    do {
  232|    140|      c2 = EOF;
  233|    140|      switch (c = getChar()) {
  234|       |
  235|      1|      case EOF:
  ------------------
  |  Branch (235:7): [True: 1, False: 139]
  ------------------
  236|      1|	error(errSyntaxError, getPos(), "Unterminated string");
  237|      1|	done = gTrue;
  ------------------
  |  |   17|      1|#define gTrue 1
  ------------------
  238|      1|	break;
  239|       |
  240|    110|      case '(':
  ------------------
  |  Branch (240:7): [True: 110, False: 30]
  ------------------
  241|    110|	++numParen;
  242|    110|	c2 = c;
  243|    110|	break;
  244|       |
  245|      0|      case ')':
  ------------------
  |  Branch (245:7): [True: 0, False: 140]
  ------------------
  246|      0|	if (--numParen == 0) {
  ------------------
  |  Branch (246:6): [True: 0, False: 0]
  ------------------
  247|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  248|      0|	} else {
  249|      0|	  c2 = c;
  250|      0|	}
  251|      0|	break;
  252|       |
  253|      0|      case '\r':
  ------------------
  |  Branch (253:7): [True: 0, False: 140]
  ------------------
  254|       |	// The PDF spec says that any literal end-of-line sequence
  255|       |	// (LF, CR, CR+LF) is translated to a single LF char.
  256|      0|	c = lookChar();
  257|      0|	if (c == '\n') {
  ------------------
  |  Branch (257:6): [True: 0, False: 0]
  ------------------
  258|      0|	  getChar();
  259|      0|	}
  260|      0|	c2 = '\n';
  261|      0|	break;
  262|       |
  263|      0|      case '\\':
  ------------------
  |  Branch (263:7): [True: 0, False: 140]
  ------------------
  264|      0|	switch (c = getChar()) {
  265|      0|	case 'n':
  ------------------
  |  Branch (265:2): [True: 0, False: 0]
  ------------------
  266|      0|	  c2 = '\n';
  267|      0|	  break;
  268|      0|	case 'r':
  ------------------
  |  Branch (268:2): [True: 0, False: 0]
  ------------------
  269|      0|	  c2 = '\r';
  270|      0|	  break;
  271|      0|	case 't':
  ------------------
  |  Branch (271:2): [True: 0, False: 0]
  ------------------
  272|      0|	  c2 = '\t';
  273|      0|	  break;
  274|      0|	case 'b':
  ------------------
  |  Branch (274:2): [True: 0, False: 0]
  ------------------
  275|      0|	  c2 = '\b';
  276|      0|	  break;
  277|      0|	case 'f':
  ------------------
  |  Branch (277:2): [True: 0, False: 0]
  ------------------
  278|      0|	  c2 = '\f';
  279|      0|	  break;
  280|      0|	case '\\':
  ------------------
  |  Branch (280:2): [True: 0, False: 0]
  ------------------
  281|      0|	case '(':
  ------------------
  |  Branch (281:2): [True: 0, False: 0]
  ------------------
  282|      0|	case ')':
  ------------------
  |  Branch (282:2): [True: 0, False: 0]
  ------------------
  283|      0|	  c2 = c;
  284|      0|	  break;
  285|      0|	case '0': case '1': case '2': case '3':
  ------------------
  |  Branch (285:2): [True: 0, False: 0]
  |  Branch (285:12): [True: 0, False: 0]
  |  Branch (285:22): [True: 0, False: 0]
  |  Branch (285:32): [True: 0, False: 0]
  ------------------
  286|      0|	case '4': case '5': case '6': case '7':
  ------------------
  |  Branch (286:2): [True: 0, False: 0]
  |  Branch (286:12): [True: 0, False: 0]
  |  Branch (286:22): [True: 0, False: 0]
  |  Branch (286:32): [True: 0, False: 0]
  ------------------
  287|      0|	  c2 = c - '0';
  288|      0|	  c = lookChar();
  289|      0|	  if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (289:8): [True: 0, False: 0]
  |  Branch (289:20): [True: 0, False: 0]
  ------------------
  290|      0|	    getChar();
  291|      0|	    c2 = (c2 << 3) + (c - '0');
  292|      0|	    c = lookChar();
  293|      0|	    if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (293:10): [True: 0, False: 0]
  |  Branch (293:22): [True: 0, False: 0]
  ------------------
  294|      0|	      getChar();
  295|      0|	      c2 = (c2 << 3) + (c - '0');
  296|      0|	    }
  297|      0|	  }
  298|      0|	  break;
  299|      0|	case '\r':
  ------------------
  |  Branch (299:2): [True: 0, False: 0]
  ------------------
  300|      0|	  c = lookChar();
  301|      0|	  if (c == '\n') {
  ------------------
  |  Branch (301:8): [True: 0, False: 0]
  ------------------
  302|      0|	    getChar();
  303|      0|	  }
  304|      0|	  break;
  305|      0|	case '\n':
  ------------------
  |  Branch (305:2): [True: 0, False: 0]
  ------------------
  306|      0|	  break;
  307|      0|	case EOF:
  ------------------
  |  Branch (307:2): [True: 0, False: 0]
  ------------------
  308|      0|	  error(errSyntaxError, getPos(), "Unterminated string");
  309|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  310|      0|	  break;
  311|      0|	default:
  ------------------
  |  Branch (311:2): [True: 0, False: 0]
  ------------------
  312|      0|	  c2 = c;
  313|      0|	  break;
  314|      0|	}
  315|      0|	break;
  316|       |
  317|     29|      default:
  ------------------
  |  Branch (317:7): [True: 29, False: 111]
  ------------------
  318|     29|	c2 = c;
  319|     29|	break;
  320|    140|      }
  321|       |
  322|    140|      if (c2 != EOF) {
  ------------------
  |  Branch (322:11): [True: 139, False: 1]
  ------------------
  323|    139|	if (n == tokBufSize) {
  ------------------
  |  |   19|    139|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (323:6): [True: 1, False: 138]
  ------------------
  324|      1|	  if (!s)
  ------------------
  |  Branch (324:8): [True: 1, False: 0]
  ------------------
  325|      1|	    s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      1|#define tokBufSize 128		// size of token buffer
  ------------------
  326|      0|	  else
  327|      0|	    s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  328|      1|	  p = tokBuf;
  329|      1|	  n = 0;
  330|      1|	}
  331|    139|	*p++ = (char)c2;
  332|    139|	++n;
  333|    139|      }
  334|    140|    } while (!done);
  ------------------
  |  Branch (334:14): [True: 139, False: 1]
  ------------------
  335|      1|    if (!s)
  ------------------
  |  Branch (335:9): [True: 0, False: 1]
  ------------------
  336|      0|      s = new GString(tokBuf, n);
  337|      1|    else
  338|      1|      s->append(tokBuf, n);
  339|      1|    obj->initString(s);
  340|      1|    break;
  341|       |
  342|       |  // name
  343|      2|  case '/':
  ------------------
  |  Branch (343:3): [True: 2, False: 193]
  ------------------
  344|      2|    p = tokBuf;
  345|      2|    n = 0;
  346|      2|    s = NULL;
  347|      2|    invalid = gFalse;
  ------------------
  |  |   18|      2|#define gFalse 0
  ------------------
  348|     19|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (348:12): [True: 18, False: 1]
  |  Branch (348:39): [True: 17, False: 1]
  ------------------
  349|     17|      getChar();
  350|     17|      if (c == '#') {
  ------------------
  |  Branch (350:11): [True: 0, False: 17]
  ------------------
  351|      0|	c2 = lookChar();
  352|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (352:6): [True: 0, False: 0]
  |  Branch (352:19): [True: 0, False: 0]
  ------------------
  353|      0|	  c = c2 - '0';
  354|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (354:13): [True: 0, False: 0]
  |  Branch (354:26): [True: 0, False: 0]
  ------------------
  355|      0|	  c = c2 - 'A' + 10;
  356|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (356:13): [True: 0, False: 0]
  |  Branch (356:26): [True: 0, False: 0]
  ------------------
  357|      0|	  c = c2 - 'a' + 10;
  358|      0|	} else {
  359|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  360|      0|	  goto notEscChar;
  361|      0|	}
  362|      0|	getChar();
  363|      0|	c2 = lookChar();
  364|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (364:6): [True: 0, False: 0]
  |  Branch (364:19): [True: 0, False: 0]
  ------------------
  365|      0|	  c = (c << 4) + (c2 - '0');
  366|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (366:13): [True: 0, False: 0]
  |  Branch (366:26): [True: 0, False: 0]
  ------------------
  367|      0|	  c = (c << 4) + (c2 - 'A' + 10);
  368|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (368:13): [True: 0, False: 0]
  |  Branch (368:26): [True: 0, False: 0]
  ------------------
  369|      0|	  c = (c << 4) + (c2 - 'a' + 10);
  370|      0|	} else {
  371|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  372|      0|	  goto notEscChar;
  373|      0|	}
  374|      0|	getChar();
  375|      0|	if (c == 0) {
  ------------------
  |  Branch (375:6): [True: 0, False: 0]
  ------------------
  376|      0|	  invalid = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  377|      0|	}
  378|      0|      }
  379|     17|     notEscChar:
  380|       |      // the PDF spec claims that names are limited to 127 chars, but
  381|       |      // Distiller 8 will produce longer names, and Acrobat 8 will
  382|       |      // accept longer names
  383|     17|      ++n;
  384|     17|      if (n < tokBufSize) {
  ------------------
  |  |   19|     17|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (384:11): [True: 17, False: 0]
  ------------------
  385|     17|	*p++ = (char)c;
  386|     17|      } else if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (386:18): [True: 0, False: 0]
  ------------------
  387|      0|	*p = (char)c;
  388|      0|	s = new GString(tokBuf, n);
  389|      0|      } else {
  390|      0|	s->append((char)c);
  391|      0|      }
  392|     17|    }
  393|      2|    if (invalid) {
  ------------------
  |  Branch (393:9): [True: 0, False: 2]
  ------------------
  394|      0|      error(errSyntaxError, getPos(), "Null character in name");
  395|      0|      obj->initError();
  396|      0|      if (s) {
  ------------------
  |  Branch (396:11): [True: 0, False: 0]
  ------------------
  397|      0|	delete s;
  398|      0|      }
  399|      2|    } else if (n < tokBufSize) {
  ------------------
  |  |   19|      2|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (399:16): [True: 2, False: 0]
  ------------------
  400|      2|      *p = '\0';
  401|      2|      obj->initName(tokBuf);
  402|      2|    } else {
  403|      0|      obj->initName(s->getCString());
  404|      0|      delete s;
  405|      0|    }
  406|      2|    break;
  407|       |
  408|       |  // array punctuation
  409|      0|  case '[':
  ------------------
  |  Branch (409:3): [True: 0, False: 195]
  ------------------
  410|      1|  case ']':
  ------------------
  |  Branch (410:3): [True: 1, False: 194]
  ------------------
  411|      1|    tokBuf[0] = (char)c;
  412|      1|    tokBuf[1] = '\0';
  413|      1|    obj->initCmd(tokBuf);
  414|      1|    break;
  415|       |
  416|       |  // hex string or dict punctuation
  417|      6|  case '<':
  ------------------
  |  Branch (417:3): [True: 6, False: 189]
  ------------------
  418|      6|    c = lookChar();
  419|       |
  420|       |    // dict punctuation
  421|      6|    if (c == '<') {
  ------------------
  |  Branch (421:9): [True: 0, False: 6]
  ------------------
  422|      0|      getChar();
  423|      0|      tokBuf[0] = tokBuf[1] = '<';
  424|      0|      tokBuf[2] = '\0';
  425|      0|      obj->initCmd(tokBuf);
  426|       |
  427|       |    // hex string
  428|      6|    } else {
  429|      6|      p = tokBuf;
  430|      6|      m = n = 0;
  431|      6|      c2 = 0;
  432|      6|      s = NULL;
  433|      6|      nErrors = 0;
  434|    577|      while (nErrors < 100) {
  ------------------
  |  Branch (434:14): [True: 577, False: 0]
  ------------------
  435|    577|	c = getChar();
  436|    577|	if (c == '>') {
  ------------------
  |  Branch (436:6): [True: 0, False: 577]
  ------------------
  437|      0|	  break;
  438|    577|	} else if (c == EOF) {
  ------------------
  |  Branch (438:13): [True: 6, False: 571]
  ------------------
  439|      6|	  error(errSyntaxError, getPos(), "Unterminated hex string");
  440|      6|	  break;
  441|    571|	} else if (specialChars[c] != 1) {
  ------------------
  |  Branch (441:13): [True: 551, False: 20]
  ------------------
  442|    551|	  c2 = c2 << 4;
  443|    551|	  if (c >= '0' && c <= '9') {
  ------------------
  |  Branch (443:8): [True: 518, False: 33]
  |  Branch (443:20): [True: 261, False: 257]
  ------------------
  444|    261|	    c2 += c - '0';
  445|    290|	  } else if (c >= 'A' && c <= 'F') {
  ------------------
  |  Branch (445:15): [True: 254, False: 36]
  |  Branch (445:27): [True: 0, False: 254]
  ------------------
  446|      0|	    c2 += c - 'A' + 10;
  447|    290|	  } else if (c >= 'a' && c <= 'f') {
  ------------------
  |  Branch (447:15): [True: 243, False: 47]
  |  Branch (447:27): [True: 112, False: 131]
  ------------------
  448|    112|	    c2 += c - 'a' + 10;
  449|    178|	  } else {
  450|    178|	    error(errSyntaxError, getPos(),
  451|    178|		  "Illegal character <{0:02x}> in hex string", c);
  452|    178|	    ++nErrors;
  453|    178|	  }
  454|    551|	  if (++m == 2) {
  ------------------
  |  Branch (454:8): [True: 274, False: 277]
  ------------------
  455|    274|	    if (n == tokBufSize) {
  ------------------
  |  |   19|    274|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (455:10): [True: 0, False: 274]
  ------------------
  456|      0|	      if (!s)
  ------------------
  |  Branch (456:12): [True: 0, False: 0]
  ------------------
  457|      0|		s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  458|      0|	      else
  459|      0|		s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  460|      0|	      p = tokBuf;
  461|      0|	      n = 0;
  462|      0|	    }
  463|    274|	    *p++ = (char)c2;
  464|    274|	    ++n;
  465|    274|	    c2 = 0;
  466|    274|	    m = 0;
  467|    274|	  }
  468|    551|	}
  469|    577|      }
  470|      6|      if (!s)
  ------------------
  |  Branch (470:11): [True: 6, False: 0]
  ------------------
  471|      6|	s = new GString(tokBuf, n);
  472|      0|      else
  473|      0|	s->append(tokBuf, n);
  474|      6|      if (m == 1)
  ------------------
  |  Branch (474:11): [True: 3, False: 3]
  ------------------
  475|      3|	s->append((char)(c2 << 4));
  476|      6|      obj->initString(s);
  477|      6|    }
  478|      6|    break;
  479|       |
  480|       |  // dict punctuation
  481|      4|  case '>':
  ------------------
  |  Branch (481:3): [True: 4, False: 191]
  ------------------
  482|      4|    c = lookChar();
  483|      4|    if (c == '>') {
  ------------------
  |  Branch (483:9): [True: 0, False: 4]
  ------------------
  484|      0|      getChar();
  485|      0|      tokBuf[0] = tokBuf[1] = '>';
  486|      0|      tokBuf[2] = '\0';
  487|      0|      obj->initCmd(tokBuf);
  488|      4|    } else {
  489|      4|      error(errSyntaxError, getPos(), "Illegal character '>'");
  490|      4|      obj->initError();
  491|      4|    }
  492|      4|    break;
  493|       |
  494|       |  // error
  495|      1|  case ')':
  ------------------
  |  Branch (495:3): [True: 1, False: 194]
  ------------------
  496|      2|  case '{':
  ------------------
  |  Branch (496:3): [True: 1, False: 194]
  ------------------
  497|      2|  case '}':
  ------------------
  |  Branch (497:3): [True: 0, False: 195]
  ------------------
  498|      2|    error(errSyntaxError, getPos(), "Illegal character '{0:c}'", c);
  499|      2|    obj->initError();
  500|      2|    break;
  501|       |
  502|       |  // command
  503|    155|  default:
  ------------------
  |  Branch (503:3): [True: 155, False: 40]
  ------------------
  504|    155|    p = tokBuf;
  505|    155|    *p++ = (char)c;
  506|    155|    n = 1;
  507|  2.36k|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (507:12): [True: 2.35k, False: 8]
  |  Branch (507:39): [True: 2.21k, False: 143]
  ------------------
  508|  2.21k|      getChar();
  509|  2.21k|      if (++n == tokBufSize) {
  ------------------
  |  |   19|  2.21k|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (509:11): [True: 4, False: 2.21k]
  ------------------
  510|      4|	error(errSyntaxError, getPos(), "Command token too long");
  511|      4|	break;
  512|      4|      }
  513|  2.21k|      *p++ = (char)c;
  514|  2.21k|    }
  515|    155|    *p = '\0';
  516|    155|    if (tokBuf[0] == 't' && !strcmp(tokBuf, "true")) {
  ------------------
  |  Branch (516:9): [True: 6, False: 149]
  |  Branch (516:29): [True: 0, False: 6]
  ------------------
  517|      0|      obj->initBool(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  518|    155|    } else if (tokBuf[0] == 'f' && !strcmp(tokBuf, "false")) {
  ------------------
  |  Branch (518:16): [True: 1, False: 154]
  |  Branch (518:36): [True: 0, False: 1]
  ------------------
  519|      0|      obj->initBool(gFalse);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  520|    155|    } else if (tokBuf[0] == 'n' && !strcmp(tokBuf, "null")) {
  ------------------
  |  Branch (520:16): [True: 1, False: 154]
  |  Branch (520:36): [True: 0, False: 1]
  ------------------
  521|      0|      obj->initNull();
  522|    155|    } else {
  523|    155|      obj->initCmd(tokBuf);
  524|    155|    }
  525|    155|    break;
  526|    195|  }
  527|       |
  528|    195|  return obj;
  529|    195|}
_ZN5Lexer7isSpaceEi:
  552|  18.2k|GBool Lexer::isSpace(int c) {
  553|  18.2k|  return c >= 0 && c <= 0xff && specialChars[c] == 1;
  ------------------
  |  Branch (553:10): [True: 18.2k, False: 14]
  |  Branch (553:20): [True: 18.2k, False: 0]
  |  Branch (553:33): [True: 4.50k, False: 13.7k]
  ------------------
  554|  18.2k|}

_ZN5Lexer6getPosEv:
   60|    195|    { return curStr.isNone() ? -1 : curStr.streamGetPos(); }
  ------------------
  |  Branch (60:14): [True: 7, False: 188]
  ------------------

_ZN14NameToCharCodeC2Ev:
   25|    318|NameToCharCode::NameToCharCode() {
   26|    318|  int i;
   27|       |
   28|    318|  size = 31;
   29|    318|  len = 0;
   30|    318|  tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   31|  10.1k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (31:15): [True: 9.85k, False: 318]
  ------------------
   32|  9.85k|    tab[i].name = NULL;
   33|  9.85k|  }
   34|    318|}
_ZN14NameToCharCodeD2Ev:
   36|    318|NameToCharCode::~NameToCharCode() {
   37|    318|  int i;
   38|       |
   39|  2.68M|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (39:15): [True: 2.68M, False: 318]
  ------------------
   40|  2.68M|    if (tab[i].name) {
  ------------------
  |  Branch (40:9): [True: 709k, False: 1.97M]
  ------------------
   41|   709k|      gfree(tab[i].name);
   42|   709k|    }
   43|  2.68M|  }
   44|    318|  gfree(tab);
   45|    318|}
_ZN14NameToCharCode3addEPKcj:
   47|   710k|void NameToCharCode::add(const char *name, CharCode c) {
   48|   710k|  NameToCharCodeEntry *oldTab;
   49|   710k|  int h, i, oldSize;
   50|       |
   51|       |  // expand the table if necessary
   52|   710k|  if (len >= size / 2) {
  ------------------
  |  Branch (52:7): [True: 2.06k, False: 708k]
  ------------------
   53|  2.06k|    oldSize = size;
   54|  2.06k|    oldTab = tab;
   55|  2.06k|    size = 2*size + 1;
   56|  2.06k|    tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   57|  5.35M|    for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (57:17): [True: 5.35M, False: 2.06k]
  ------------------
   58|  5.35M|      tab[h].name = NULL;
   59|  5.35M|    }
   60|  2.67M|    for (i = 0; i < oldSize; ++i) {
  ------------------
  |  Branch (60:17): [True: 2.67M, False: 2.06k]
  ------------------
   61|  2.67M|      if (oldTab[i].name) {
  ------------------
  |  Branch (61:11): [True: 1.33M, False: 1.33M]
  ------------------
   62|  1.33M|	h = hash(oldTab[i].name);
   63|  1.95M|	while (tab[h].name) {
  ------------------
  |  Branch (63:9): [True: 616k, False: 1.33M]
  ------------------
   64|   616k|	  if (++h == size) {
  ------------------
  |  Branch (64:8): [True: 0, False: 616k]
  ------------------
   65|      0|	    h = 0;
   66|      0|	  }
   67|   616k|	}
   68|  1.33M|	tab[h] = oldTab[i];
   69|  1.33M|      }
   70|  2.67M|    }
   71|  2.06k|    gfree(oldTab);
   72|  2.06k|  }
   73|       |
   74|       |  // add the new name
   75|   710k|  h = hash(name);
   76|  2.95M|  while (tab[h].name && strcmp(tab[h].name, name)) {
  ------------------
  |  Branch (76:10): [True: 2.24M, False: 709k]
  |  Branch (76:25): [True: 2.24M, False: 159]
  ------------------
   77|  2.24M|    if (++h == size) {
  ------------------
  |  Branch (77:9): [True: 477, False: 2.24M]
  ------------------
   78|    477|      h = 0;
   79|    477|    }
   80|  2.24M|  }
   81|   710k|  if (!tab[h].name) {
  ------------------
  |  Branch (81:7): [True: 709k, False: 159]
  ------------------
   82|   709k|    tab[h].name = copyString(name);
   83|   709k|  }
   84|   710k|  tab[h].c = c;
   85|       |
   86|   710k|  ++len;
   87|   710k|}
_ZN14NameToCharCode4hashEPKc:
  104|  2.04M|int NameToCharCode::hash(const char *name) {
  105|  2.04M|  const char *p;
  106|  2.04M|  unsigned int h;
  107|       |
  108|  2.04M|  h = 0;
  109|  24.0M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (109:18): [True: 22.0M, False: 2.04M]
  ------------------
  110|  22.0M|    h = 17 * h + (int)(*p & 0xff);
  111|  22.0M|  }
  112|  2.04M|  return (int)(h % size);
  113|  2.04M|}

_ZN6Object10initStreamEP6Stream:
   70|     75|Object *Object::initStream(Stream *streamA) {
   71|     75|  initObj(objStream);
  ------------------
  |  |   77|     75|#define initObj(t) type = t
  ------------------
   72|     75|  stream = streamA;
   73|     75|  return this;
   74|     75|}
_ZN6Object4copyEPS_:
   76|    222|Object *Object::copy(Object *obj) {
   77|    222|  *obj = *this;
   78|    222|  switch (type) {
   79|      1|  case objString:
  ------------------
  |  Branch (79:3): [True: 1, False: 221]
  ------------------
   80|      1|    obj->string = string->copy();
   81|      1|    break;
   82|      0|  case objName:
  ------------------
  |  Branch (82:3): [True: 0, False: 222]
  ------------------
   83|      0|    obj->name = copyString(name);
   84|      0|    break;
   85|      0|  case objArray:
  ------------------
  |  Branch (85:3): [True: 0, False: 222]
  ------------------
   86|      0|    array->incRef();
   87|      0|    break;
   88|      0|  case objDict:
  ------------------
  |  Branch (88:3): [True: 0, False: 222]
  ------------------
   89|      0|    dict->incRef();
   90|      0|    break;
   91|     75|  case objStream:
  ------------------
  |  Branch (91:3): [True: 75, False: 147]
  ------------------
   92|     75|    obj->stream = stream->copy();
   93|     75|    break;
   94|     68|  case objCmd:
  ------------------
  |  Branch (94:3): [True: 68, False: 154]
  ------------------
   95|     68|    obj->cmd = copyString(cmd);
   96|     68|    break;
   97|     78|  default:
  ------------------
  |  Branch (97:3): [True: 78, False: 144]
  ------------------
   98|     78|    break;
   99|    222|  }
  100|       |#ifdef DEBUG_OBJECT_MEM
  101|       |#if MULTITHREADED
  102|       |  gAtomicIncrement(&numAlloc[type]);
  103|       |#else
  104|       |  ++numAlloc[type];
  105|       |#endif
  106|       |#endif
  107|    222|  return obj;
  108|    222|}
_ZN6Object4freeEv:
  115|  1.09k|void Object::free() {
  116|  1.09k|  switch (type) {
  117|      8|  case objString:
  ------------------
  |  Branch (117:3): [True: 8, False: 1.08k]
  ------------------
  118|      8|    delete string;
  119|      8|    break;
  120|      2|  case objName:
  ------------------
  |  Branch (120:3): [True: 2, False: 1.08k]
  ------------------
  121|      2|    gfree(name);
  122|      2|    break;
  123|      0|  case objArray:
  ------------------
  |  Branch (123:3): [True: 0, False: 1.09k]
  ------------------
  124|      0|    if (!array->decRef()) {
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|      delete array;
  126|      0|    }
  127|      0|    break;
  128|      0|  case objDict:
  ------------------
  |  Branch (128:3): [True: 0, False: 1.09k]
  ------------------
  129|      0|    if (!dict->decRef()) {
  ------------------
  |  Branch (129:9): [True: 0, False: 0]
  ------------------
  130|      0|      delete dict;
  131|      0|    }
  132|      0|    break;
  133|    150|  case objStream:
  ------------------
  |  Branch (133:3): [True: 150, False: 941]
  ------------------
  134|    150|    delete stream;
  135|    150|    break;
  136|    224|  case objCmd:
  ------------------
  |  Branch (136:3): [True: 224, False: 867]
  ------------------
  137|    224|    gfree(cmd);
  138|    224|    break;
  139|    707|  default:
  ------------------
  |  Branch (139:3): [True: 707, False: 384]
  ------------------
  140|    707|    break;
  141|  1.09k|  }
  142|       |#ifdef DEBUG_OBJECT_MEM
  143|       |#if MULTITHREADED
  144|       |  gAtomicDecrement(&numAlloc[type]);
  145|       |#else
  146|       |  --numAlloc[type];
  147|       |#endif
  148|       |#endif
  149|  1.09k|  type = objNone;
  150|  1.09k|}

_ZN6ObjectC2Ev:
   85|  7.05k|    type(objNone) {}
_ZN6Object8initNullEv:
   99|    234|    { initObj(objNull); return this; }
  ------------------
  |  |   77|    234|#define initObj(t) type = t
  ------------------
_ZN6Object6isDictEv:
  133|     11|  GBool isDict() { return type == objDict; }
_ZN6Object7initIntEi:
   91|     31|    { initObj(objInt); intg = intgA; return this; }
  ------------------
  |  |   77|     31|#define initObj(t) type = t
  ------------------
_ZN6Object8initRealEd:
   93|      3|    { initObj(objReal); real = realA; return this; }
  ------------------
  |  |   77|      3|#define initObj(t) type = t
  ------------------
_ZN6Object10initStringEP7GString:
   95|      7|    { initObj(objString); string = stringA; return this; }
  ------------------
  |  |   77|      7|#define initObj(t) type = t
  ------------------
_ZN6Object8initNameEPKc:
   97|      2|    { initObj(objName); name = copyString(nameA); return this; }
  ------------------
  |  |   77|      2|#define initObj(t) type = t
  ------------------
_ZN6Object7initCmdEPc:
  107|    156|    { initObj(objCmd); cmd = copyString(cmdA); return this; }
  ------------------
  |  |   77|    156|#define initObj(t) type = t
  ------------------
_ZN6Object9initErrorEv:
  109|      6|    { initObj(objError); return this; }
  ------------------
  |  |   77|      6|#define initObj(t) type = t
  ------------------
_ZN6Object7initEOFEv:
  111|     37|    { initObj(objEOF); return this; }
  ------------------
  |  |   77|     37|#define initObj(t) type = t
  ------------------
_ZN6Object5isIntEv:
  126|    163|  GBool isInt() { return type == objInt; }
_ZN6Object8isStringEv:
  129|     72|  GBool isString() { return type == objString; }
_ZN6Object6isNoneEv:
  139|  7.76k|  GBool isNone() { return type == objNone; }
_ZN6Object5isCmdEPKc:
  147|    104|    { return type == objCmd && !strcmp(cmd, cmdA); }
  ------------------
  |  Branch (147:14): [True: 84, False: 20]
  |  Branch (147:32): [True: 0, False: 84]
  ------------------
_ZN6Object6getIntEv:
  151|     10|  int getInt() { return intg; }
_ZN6Object11streamResetEv:
  290|     75|  { stream->reset(); }
_ZN6Object11streamCloseEv:
  293|     75|  { stream->close(); }
_ZN6Object13streamGetCharEv:
  296|  4.93k|  { return stream->getChar(); }
_ZN6Object14streamLookCharEv:
  299|  2.52k|  { return stream->lookChar(); }
_ZN6Object12streamGetPosEv:
  308|    188|  { return stream->getPos(); }

_ZN6PDFDocC2EP10BaseStreamP7GStringS3_P7PDFCore:
  219|    159|	       GString *userPassword, PDFCore *coreA) {
  220|       |#ifdef _WIN32
  221|       |  int n, i;
  222|       |#endif
  223|       |
  224|    159|  init(coreA);
  225|       |
  226|    159|  if (strA->getFileName()) {
  ------------------
  |  Branch (226:7): [True: 0, False: 159]
  ------------------
  227|      0|    fileName = strA->getFileName()->copy();
  228|       |#ifdef _WIN32
  229|       |    n = fileName->getLength();
  230|       |    fileNameU = (wchar_t *)gmallocn(n + 1, sizeof(wchar_t));
  231|       |    for (i = 0; i < n; ++i) {
  232|       |      fileNameU[i] = (wchar_t)(fileName->getChar(i) & 0xff);
  233|       |    }
  234|       |    fileNameU[n] = L'\0';
  235|       |#endif
  236|    159|  } else {
  237|    159|    fileName = NULL;
  238|       |#ifdef _WIN32
  239|       |    fileNameU = NULL;
  240|       |#endif
  241|    159|  }
  242|    159|  str = strA;
  243|    159|  ok = setup(ownerPassword, userPassword);
  244|    159|}
_ZN6PDFDoc4initEP7PDFCore:
  246|    159|void PDFDoc::init(PDFCore *coreA) {
  247|    159|  ok = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  248|    159|  errCode = errNone;
  ------------------
  |  |   12|    159|#define errNone             0	// no error
  ------------------
  249|    159|  core = coreA;
  250|    159|  file = NULL;
  251|    159|  str = NULL;
  252|    159|  xref = NULL;
  253|    159|  catalog = NULL;
  254|    159|  annots = NULL;
  255|    159|#ifndef DISABLE_OUTLINE
  256|    159|  outline = NULL;
  257|    159|#endif
  258|    159|  optContent = NULL;
  259|    159|}
_ZN6PDFDoc5setupEP7GStringS1_:
  261|    159|GBool PDFDoc::setup(GString *ownerPassword, GString *userPassword) {
  262|       |
  263|    159|  str->reset();
  264|       |
  265|       |  // check header
  266|    159|  checkHeader();
  267|       |
  268|       |  // read the xref and catalog
  269|    159|  if (!PDFDoc::setup2(ownerPassword, userPassword, gFalse)) {
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  |  Branch (269:7): [True: 159, False: 0]
  ------------------
  270|    159|    if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   18|    318|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
                  if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  |  Branch (270:9): [True: 159, False: 0]
  |  Branch (270:34): [True: 0, False: 0]
  ------------------
  271|       |      // try repairing the xref table
  272|    159|      error(errSyntaxWarning, -1,
  273|    159|	    "PDF file is damaged - attempting to reconstruct xref table...");
  274|    159|      if (!PDFDoc::setup2(ownerPassword, userPassword, gTrue)) {
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  |  Branch (274:11): [True: 159, False: 0]
  ------------------
  275|    159|	return gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  276|    159|      }
  277|    159|    } else {
  278|      0|      return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  279|      0|    }
  280|    159|  }
  281|       |
  282|      0|#ifndef DISABLE_OUTLINE
  283|       |  // read outline
  284|      0|  outline = new Outline(catalog->getOutline(), xref);
  285|      0|#endif
  286|       |
  287|       |  // read the optional content info
  288|      0|  optContent = new OptionalContent(this);
  289|       |
  290|       |
  291|       |  // done
  292|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  293|    159|}
_ZN6PDFDoc6setup2EP7GStringS1_i:
  296|    318|		     GBool repairXRef) {
  297|       |  // read xref table
  298|    318|  xref = new XRef(str, repairXRef);
  299|    318|  if (!xref->isOk()) {
  ------------------
  |  Branch (299:7): [True: 318, False: 0]
  ------------------
  300|    318|    error(errSyntaxError, -1, "Couldn't read xref table");
  301|    318|    errCode = xref->getErrorCode();
  302|    318|    delete xref;
  303|    318|    xref = NULL;
  304|    318|    return gFalse;
  ------------------
  |  |   18|    318|#define gFalse 0
  ------------------
  305|    318|  }
  306|       |
  307|       |  // check for encryption
  308|      0|  if (!checkEncryption(ownerPassword, userPassword)) {
  ------------------
  |  Branch (308:7): [True: 0, False: 0]
  ------------------
  309|      0|    errCode = errEncrypted;
  ------------------
  |  |   21|      0|#define errEncrypted        4	// file was encrypted and password was
  ------------------
  310|      0|    delete xref;
  311|      0|    xref = NULL;
  312|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  313|      0|  }
  314|       |
  315|       |  // read catalog
  316|      0|  catalog = new Catalog(this);
  317|      0|  if (!catalog->isOk()) {
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|    error(errSyntaxError, -1, "Couldn't read page catalog");
  319|      0|    errCode = errBadCatalog;
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  320|      0|    delete catalog;
  321|      0|    catalog = NULL;
  322|      0|    delete xref;
  323|      0|    xref = NULL;
  324|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  325|      0|  }
  326|       |
  327|       |  // initialize the Annots object
  328|      0|  annots = new Annots(this);
  329|       |
  330|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  331|      0|}
_ZN6PDFDocD2Ev:
  333|    159|PDFDoc::~PDFDoc() {
  334|    159|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 159]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|    159|#ifndef DISABLE_OUTLINE
  338|    159|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 159]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|    159|#endif
  342|    159|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 159]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|    159|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 159]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|    159|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 159]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|    159|  if (str) {
  ------------------
  |  Branch (351:7): [True: 159, False: 0]
  ------------------
  352|    159|    delete str;
  353|    159|  }
  354|    159|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 159]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|    159|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 0, False: 159]
  ------------------
  358|      0|    delete fileName;
  359|      0|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|    159|}
_ZN6PDFDoc11checkHeaderEv:
  369|    159|void PDFDoc::checkHeader() {
  370|    159|  char hdrBuf[headerSearchSize+1];
  371|    159|  char *p;
  372|    159|  int i;
  373|       |
  374|    159|  pdfVersion = 0;
  375|    159|  memset(hdrBuf, 0, headerSearchSize + 1);
  ------------------
  |  |   44|    159|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  376|    159|  str->getBlock(hdrBuf, headerSearchSize);
  ------------------
  |  |   44|    159|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  377|   150k|  for (i = 0; i < headerSearchSize - 5; ++i) {
  ------------------
  |  |   44|   150k|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (377:15): [True: 150k, False: 147]
  ------------------
  378|   150k|    if (!strncmp(&hdrBuf[i], "%PDF-", 5)) {
  ------------------
  |  Branch (378:9): [True: 12, False: 150k]
  ------------------
  379|     12|      break;
  380|     12|    }
  381|   150k|  }
  382|    159|  if (i >= headerSearchSize - 5) {
  ------------------
  |  |   44|    159|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (382:7): [True: 147, False: 12]
  ------------------
  383|    147|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  384|    147|    return;
  385|    147|  }
  386|     12|  str->moveStart(i);
  387|     12|  if (!(p = strtok(&hdrBuf[i+5], " \t\n\r"))) {
  ------------------
  |  Branch (387:7): [True: 9, False: 3]
  ------------------
  388|      9|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  389|      9|    return;
  390|      9|  }
  391|      3|  pdfVersion = atof(p);
  392|      3|  if (!(hdrBuf[i+5] >= '0' && hdrBuf[i+5] <= '9') ||
  ------------------
  |  Branch (392:9): [True: 2, False: 1]
  |  Branch (392:31): [True: 0, False: 2]
  ------------------
  393|      3|      pdfVersion > supportedPDFVersionNum + 0.0001) {
  ------------------
  |  |   28|      0|#define supportedPDFVersionNum 2.0
  ------------------
  |  Branch (393:7): [True: 0, False: 0]
  ------------------
  394|      3|    error(errSyntaxWarning, -1,
  395|      3|	  "PDF version {0:s} -- xpdf supports version {1:s} (continuing anyway)",
  396|      3|	  p, supportedPDFVersionStr);
  ------------------
  |  |   27|      3|#define supportedPDFVersionStr "2.0"
  ------------------
  397|      3|  }
  398|      3|}

_ZN6PDFDoc4isOkEv:
   57|    159|  GBool isOk() { return ok; }

_ZN6ParserC2EP4XRefP5Lexeri:
   26|     75|Parser::Parser(XRef *xrefA, Lexer *lexerA, GBool allowStreamsA) {
   27|     75|  xref = xrefA;
   28|     75|  lexer = lexerA;
   29|     75|  inlineImg = 0;
   30|     75|  allowStreams = allowStreamsA;
   31|     75|  lexer->getObj(&buf1);
   32|     75|  lexer->getObj(&buf2);
   33|     75|}
_ZN6ParserD2Ev:
   35|     75|Parser::~Parser() {
   36|     75|  buf1.free();
   37|     75|  buf2.free();
   38|     75|  delete lexer;
   39|     75|}
_ZN6Parser6getObjEP6ObjectiPh14CryptAlgorithmiiii:
   44|     82|		       int objNum, int objGen, int recursion) {
   45|     82|  char *key;
   46|     82|  Stream *str;
   47|     82|  Object obj2;
   48|     82|  int num;
   49|     82|  DecryptStream *decrypt;
   50|     82|  GString *s, *s2;
   51|     82|  int c;
   52|       |
   53|       |  // refill buffer after inline image data
   54|     82|  if (inlineImg == 2) {
  ------------------
  |  Branch (54:7): [True: 0, False: 82]
  ------------------
   55|      0|    buf1.free();
   56|      0|    buf2.free();
   57|      0|    lexer->getObj(&buf1);
   58|      0|    lexer->getObj(&buf2);
   59|      0|    inlineImg = 0;
   60|      0|  }
   61|       |
   62|       |  // array
   63|     82|  if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("[")) {
  ------------------
  |  |   24|     93|#define recursionLimit 500
  ------------------
  |  Branch (63:7): [True: 11, False: 71]
  |  Branch (63:22): [True: 11, False: 0]
  |  Branch (63:52): [True: 0, False: 11]
  ------------------
   64|      0|    shift();
   65|      0|    obj->initArray(xref);
   66|      0|    while (!buf1.isCmd("]") && !buf1.isEOF())
  ------------------
  |  Branch (66:12): [True: 0, False: 0]
  |  Branch (66:32): [True: 0, False: 0]
  ------------------
   67|      0|      obj->arrayAdd(getObj(&obj2, gFalse, fileKey, encAlgorithm, keyLength,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   68|      0|			   objNum, objGen, recursion + 1));
   69|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (69:9): [True: 0, False: 0]
  ------------------
   70|      0|      error(errSyntaxError, getPos(), "End of file inside array");
   71|      0|    shift();
   72|       |
   73|       |  // dictionary or stream
   74|     82|  } else if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("<<")) {
  ------------------
  |  |   24|     93|#define recursionLimit 500
  ------------------
  |  Branch (74:14): [True: 11, False: 71]
  |  Branch (74:29): [True: 11, False: 0]
  |  Branch (74:59): [True: 0, False: 11]
  ------------------
   75|      0|    shift();
   76|      0|    obj->initDict(xref);
   77|      0|    while (!buf1.isCmd(">>") && !buf1.isEOF()) {
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  |  Branch (77:33): [True: 0, False: 0]
  ------------------
   78|      0|      if (!buf1.isName()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|	error(errSyntaxError, getPos(),
   80|      0|	      "Dictionary key must be a name object");
   81|      0|	shift();
   82|      0|      } else {
   83|      0|	key = copyString(buf1.getName());
   84|      0|	shift();
   85|      0|	if (buf1.isEOF() || buf1.isError()) {
  ------------------
  |  Branch (85:6): [True: 0, False: 0]
  |  Branch (85:22): [True: 0, False: 0]
  ------------------
   86|      0|	  gfree(key);
   87|      0|	  break;
   88|      0|	}
   89|      0|	obj->dictAdd(key, getObj(&obj2, gFalse,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   90|      0|				 fileKey, encAlgorithm, keyLength,
   91|      0|				 objNum, objGen, recursion + 1));
   92|      0|      }
   93|      0|    }
   94|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (94:9): [True: 0, False: 0]
  ------------------
   95|      0|      error(errSyntaxError, getPos(), "End of file inside dictionary");
   96|       |    // stream objects are not allowed inside content streams or
   97|       |    // object streams
   98|      0|    if (allowStreams && buf2.isCmd("stream")) {
  ------------------
  |  Branch (98:9): [True: 0, False: 0]
  |  Branch (98:25): [True: 0, False: 0]
  ------------------
   99|      0|      if ((str = makeStream(obj, fileKey, encAlgorithm, keyLength,
  ------------------
  |  Branch (99:11): [True: 0, False: 0]
  ------------------
  100|      0|			    objNum, objGen, recursion + 1))) {
  101|      0|	obj->initStream(str);
  102|      0|      } else {
  103|      0|	obj->free();
  104|      0|	obj->initError();
  105|      0|      }
  106|      0|    } else {
  107|      0|      shift();
  108|      0|    }
  109|       |
  110|       |  // indirect reference or integer
  111|     82|  } else if (buf1.isInt()) {
  ------------------
  |  Branch (111:14): [True: 10, False: 72]
  ------------------
  112|     10|    num = buf1.getInt();
  113|     10|    shift();
  114|     10|    if (buf1.isInt() && buf2.isCmd("R")) {
  ------------------
  |  Branch (114:9): [True: 0, False: 10]
  |  Branch (114:25): [True: 0, False: 0]
  ------------------
  115|      0|      obj->initRef(num, buf1.getInt());
  116|      0|      shift();
  117|      0|      shift();
  118|     10|    } else {
  119|     10|      obj->initInt(num);
  120|     10|    }
  121|       |
  122|       |  // string
  123|     72|  } else if (buf1.isString() && fileKey) {
  ------------------
  |  Branch (123:14): [True: 1, False: 71]
  |  Branch (123:33): [True: 0, False: 1]
  ------------------
  124|      0|    s = buf1.getString();
  125|      0|    s2 = new GString();
  126|      0|    obj2.initNull();
  127|      0|    decrypt = new DecryptStream(new MemStream(s->getCString(), 0,
  128|      0|					      s->getLength(), &obj2),
  129|      0|				fileKey, encAlgorithm, keyLength,
  130|      0|				objNum, objGen);
  131|      0|    decrypt->reset();
  132|      0|    while ((c = decrypt->getChar()) != EOF) {
  ------------------
  |  Branch (132:12): [True: 0, False: 0]
  ------------------
  133|      0|      s2->append((char)c);
  134|      0|    }
  135|      0|    delete decrypt;
  136|      0|    obj->initString(s2);
  137|      0|    shift();
  138|       |
  139|       |  // simple object
  140|     72|  } else {
  141|     72|    buf1.copy(obj);
  142|     72|    shift();
  143|     72|  }
  144|       |
  145|     82|  return obj;
  146|     82|}
_ZN6Parser5shiftEv:
  293|     82|void Parser::shift() {
  294|     82|  if (inlineImg > 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 82]
  ------------------
  295|      0|    if (inlineImg < 2) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      ++inlineImg;
  297|      0|    } else {
  298|       |      // in a damaged content stream, if 'ID' shows up in the middle
  299|       |      // of a dictionary, we need to reset
  300|      0|      inlineImg = 0;
  301|      0|    }
  302|     82|  } else if (buf2.isCmd("ID")) {
  ------------------
  |  Branch (302:14): [True: 0, False: 82]
  ------------------
  303|      0|    lexer->skipChar();		// skip char after 'ID' command
  304|      0|    inlineImg = 1;
  305|      0|  }
  306|     82|  buf1.free();
  307|     82|  buf1 = buf2;
  308|     82|  if (inlineImg > 0)		// don't buffer inline image data
  ------------------
  |  Branch (308:7): [True: 0, False: 82]
  ------------------
  309|      0|    buf2.initNull();
  310|     82|  else
  311|     82|    lexer->getObj(&buf2);
  312|     82|}

_ZN6StreamC2Ev:
   62|    309|Stream::Stream() {
   63|    309|}
_ZN6StreamD2Ev:
   65|    309|Stream::~Stream() {
   66|    309|}
_ZN10BaseStreamC2EP6Object:
  325|    309|BaseStream::BaseStream(Object *dictA) {
  326|    309|  dict = *dictA;
  327|    309|}
_ZN10BaseStreamD2Ev:
  329|    309|BaseStream::~BaseStream() {
  330|    309|  dict.free();
  331|    309|}
_ZN9MemStreamC2EPcjjP6Object:
  873|    309|    BaseStream(dictA) {
  874|    309|  buf = bufA;
  875|    309|  start = startA;
  876|    309|  length = lengthA;
  877|    309|  bufEnd = buf + start + length;
  878|    309|  bufPtr = buf + start;
  879|    309|  needFree = gFalse;
  ------------------
  |  |   18|    309|#define gFalse 0
  ------------------
  880|    309|}
_ZN9MemStreamD2Ev:
  882|    309|MemStream::~MemStream() {
  883|    309|  if (needFree) {
  ------------------
  |  Branch (883:7): [True: 0, False: 309]
  ------------------
  884|      0|    gfree(buf);
  885|      0|  }
  886|    309|}
_ZN9MemStream4copyEv:
  888|     75|Stream *MemStream::copy() {
  889|     75|  Object dictA;
  890|       |
  891|     75|  dict.copy(&dictA);
  892|     75|  return new MemStream(buf, start, length, &dictA);
  893|     75|}
_ZN9MemStream13makeSubStreamElilP6Object:
  896|     75|				 GFileOffset lengthA, Object *dictA) {
  897|     75|  MemStream *subStr;
  898|     75|  Guint newStart, newLength;
  899|       |
  900|     75|  if (startA < start) {
  ------------------
  |  Branch (900:7): [True: 0, False: 75]
  ------------------
  901|      0|    newStart = start;
  902|     75|  } else if (startA > start + length) {
  ------------------
  |  Branch (902:14): [True: 3, False: 72]
  ------------------
  903|      3|    newStart = start + (int)length;
  904|     72|  } else {
  905|     72|    newStart = (int)startA;
  906|     72|  }
  907|     75|  if (!limited || newStart + lengthA > start + length) {
  ------------------
  |  Branch (907:7): [True: 75, False: 0]
  |  Branch (907:19): [True: 0, False: 0]
  ------------------
  908|     75|    newLength = start + length - newStart;
  909|     75|  } else {
  910|      0|    newLength = (Guint)lengthA;
  911|      0|  }
  912|     75|  subStr = new MemStream(buf, newStart, newLength, dictA);
  913|     75|  return subStr;
  914|     75|}
_ZN9MemStream5resetEv:
  916|    393|void MemStream::reset() {
  917|    393|  bufPtr = buf + start;
  918|    393|}
_ZN9MemStream5closeEv:
  920|     75|void MemStream::close() {
  921|     75|}
_ZN9MemStream8getBlockEPci:
  923|    541|int MemStream::getBlock(char *blk, int size) {
  924|    541|  int n;
  925|       |
  926|    541|  if (size <= 0) {
  ------------------
  |  Branch (926:7): [True: 0, False: 541]
  ------------------
  927|      0|    return 0;
  928|      0|  }
  929|    541|  if (bufEnd - bufPtr < size) {
  ------------------
  |  Branch (929:7): [True: 504, False: 37]
  ------------------
  930|    504|    n = (int)(bufEnd - bufPtr);
  931|    504|  } else {
  932|     37|    n = size;
  933|     37|  }
  934|    541|  memcpy(blk, bufPtr, n);
  935|    541|  bufPtr += n;
  936|    541|  return n;
  937|    541|}
_ZN9MemStream6setPosEli:
  939|    223|void MemStream::setPos(GFileOffset pos, int dir) {
  940|    223|  Guint i;
  941|       |
  942|    223|  if (dir >= 0) {
  ------------------
  |  Branch (942:7): [True: 64, False: 159]
  ------------------
  943|     64|    i = (Guint)pos;
  944|    159|  } else {
  945|    159|    if (pos > start + length) {
  ------------------
  |  Branch (945:9): [True: 158, False: 1]
  ------------------
  946|    158|      i = 0;
  947|    158|    } else {
  948|      1|      i = (Guint)(start + length - pos);
  949|      1|    }
  950|    159|  }
  951|    223|  if (i < start) {
  ------------------
  |  Branch (951:7): [True: 12, False: 211]
  ------------------
  952|     12|    i = start;
  953|    211|  } else if (i > start + length) {
  ------------------
  |  Branch (953:14): [True: 3, False: 208]
  ------------------
  954|      3|    i = start + length;
  955|      3|  }
  956|    223|  bufPtr = buf + i;
  957|    223|}
_ZN9MemStream9moveStartEi:
  959|     12|void MemStream::moveStart(int delta) {
  960|     12|  start += delta;
  961|     12|  length -= delta;
  962|     12|  bufPtr = buf + start;
  963|     12|}

_ZN10BaseStream11getFileNameEv:
  180|    159|  virtual GString *getFileName() { return NULL; }
_ZN9MemStream7getCharEv:
  365|  4.93k|    { return (bufPtr < bufEnd) ? (*bufPtr++ & 0xff) : EOF; }
  ------------------
  |  Branch (365:14): [True: 4.90k, False: 33]
  ------------------
_ZN9MemStream8lookCharEv:
  367|  2.52k|    { return (bufPtr < bufEnd) ? (*bufPtr & 0xff) : EOF; }
  ------------------
  |  Branch (367:14): [True: 2.51k, False: 11]
  ------------------
_ZN9MemStream6getPosEv:
  369|    262|  virtual GFileOffset getPos() { return (GFileOffset)(bufPtr - buf); }
_ZN9MemStream8getStartEv:
  371|    318|  virtual GFileOffset getStart() { return start; }

_ZN10UnicodeMapC2EPKciP15UnicodeMapRangei:
  122|    636|		       UnicodeMapRange *rangesA, int lenA) {
  123|    636|  encodingName = new GString(encodingNameA);
  124|    636|  unicodeOut = unicodeOutA;
  125|    636|  kind = unicodeMapResident;
  126|    636|  ranges = rangesA;
  127|    636|  len = lenA;
  128|    636|  eMaps = NULL;
  129|    636|  eMapsLen = 0;
  130|    636|  refCnt = 1;
  131|    636|}
_ZN10UnicodeMapC2EPKciPFijPciE:
  134|    318|		       UnicodeMapFunc funcA) {
  135|    318|  encodingName = new GString(encodingNameA);
  136|    318|  unicodeOut = unicodeOutA;
  137|    318|  kind = unicodeMapFunc;
  138|    318|  func = funcA;
  139|    318|  eMaps = NULL;
  140|    318|  eMapsLen = 0;
  141|    318|  refCnt = 1;
  142|    318|}
_ZN10UnicodeMapD2Ev:
  144|    954|UnicodeMap::~UnicodeMap() {
  145|    954|  delete encodingName;
  146|    954|  if (kind == unicodeMapUser && ranges) {
  ------------------
  |  Branch (146:7): [True: 0, False: 954]
  |  Branch (146:33): [True: 0, False: 0]
  ------------------
  147|      0|    gfree(ranges);
  148|      0|  }
  149|    954|  if (eMaps) {
  ------------------
  |  Branch (149:7): [True: 0, False: 954]
  ------------------
  150|      0|    gfree(eMaps);
  151|      0|  }
  152|    954|}
_ZN15UnicodeMapCacheC2Ev:
  228|    159|UnicodeMapCache::UnicodeMapCache() {
  229|    159|  int i;
  230|       |
  231|    795|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    795|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (231:15): [True: 636, False: 159]
  ------------------
  232|    636|    cache[i] = NULL;
  233|    636|  }
  234|    159|}
_ZN15UnicodeMapCacheD2Ev:
  236|    159|UnicodeMapCache::~UnicodeMapCache() {
  237|    159|  int i;
  238|       |
  239|    795|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    795|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (239:15): [True: 636, False: 159]
  ------------------
  240|    636|    if (cache[i]) {
  ------------------
  |  Branch (240:9): [True: 0, False: 636]
  ------------------
  241|      0|      cache[i]->decRefCnt();
  242|      0|    }
  243|    636|  }
  244|    159|}

_ZN10UnicodeMap15getEncodingNameEv:
   65|    954|  GString *getEncodingName() { return encodingName; }

_ZN16UnicodeRemappingC2Ev:
   69|    159|UnicodeRemapping::UnicodeRemapping() {
   70|  40.8k|  for (int i = 0; i < 256; ++i) {
  ------------------
  |  Branch (70:19): [True: 40.7k, False: 159]
  ------------------
   71|  40.7k|    page0[i] = (Unicode)i;
   72|  40.7k|  }
   73|    159|  sMap = NULL;
   74|    159|  sMapLen = sMapSize = 0;
   75|    159|}
_ZN16UnicodeRemappingD2Ev:
   77|    159|UnicodeRemapping::~UnicodeRemapping() {
   78|    159|  gfree(sMap);
   79|    159|}

_ZN10XRefPosSetC2Ev:
   66|     64|XRefPosSet::XRefPosSet() {
   67|     64|  size = 16;
   68|     64|  len = 0;
   69|     64|  tab = (GFileOffset *)gmallocn(size, sizeof(GFileOffset));
   70|     64|}
_ZN10XRefPosSetD2Ev:
   72|     64|XRefPosSet::~XRefPosSet() {
   73|     64|  gfree(tab);
   74|     64|}
_ZN10XRefPosSet3addEl:
   76|     64|void XRefPosSet::add(GFileOffset pos) {
   77|     64|  int i;
   78|       |
   79|     64|  i = find(pos);
   80|     64|  if (i < len && tab[i] == pos) {
  ------------------
  |  Branch (80:7): [True: 0, False: 64]
  |  Branch (80:18): [True: 0, False: 0]
  ------------------
   81|      0|    return;
   82|      0|  }
   83|     64|  if (len == size) {
  ------------------
  |  Branch (83:7): [True: 0, False: 64]
  ------------------
   84|      0|    if (size > INT_MAX / 2) {
  ------------------
  |  Branch (84:9): [True: 0, False: 0]
  ------------------
   85|      0|      gMemError("Integer overflow in XRefPosSet::add()");
   86|      0|    }
   87|      0|    size *= 2;
   88|      0|    tab = (GFileOffset *)greallocn(tab, size, sizeof(GFileOffset));
   89|      0|  }
   90|     64|  if (i < len) {
  ------------------
  |  Branch (90:7): [True: 0, False: 64]
  ------------------
   91|      0|    memmove(&tab[i + 1], &tab[i], (len - i) * sizeof(GFileOffset));
   92|      0|  }
   93|     64|  tab[i] = pos;
   94|     64|  ++len;
   95|     64|}
_ZN10XRefPosSet5checkEl:
   97|     64|GBool XRefPosSet::check(GFileOffset pos) {
   98|     64|  int i;
   99|       |
  100|     64|  i = find(pos);
  101|     64|  return i < len && tab[i] == pos;
  ------------------
  |  Branch (101:10): [True: 0, False: 64]
  |  Branch (101:21): [True: 0, False: 0]
  ------------------
  102|     64|}
_ZN10XRefPosSet4findEl:
  104|    128|int XRefPosSet::find(GFileOffset pos) {
  105|    128|  int a, b, m;
  106|       |
  107|    128|  a = - 1;
  108|    128|  b = len;
  109|       |  // invariant: tab[a] < pos < tab[b]
  110|    128|  while (b - a > 1) {
  ------------------
  |  Branch (110:10): [True: 0, False: 128]
  ------------------
  111|      0|    m = (a + b) / 2;
  112|      0|    if (tab[m] < pos) {
  ------------------
  |  Branch (112:9): [True: 0, False: 0]
  ------------------
  113|      0|      a = m;
  114|      0|    } else if (tab[m] > pos) {
  ------------------
  |  Branch (114:16): [True: 0, False: 0]
  ------------------
  115|      0|      b = m;
  116|      0|    } else {
  117|      0|      return m;
  118|      0|    }
  119|      0|  }
  120|    128|  return b;
  121|    128|}
_ZN4XRefC2EP10BaseStreami:
  289|    318|XRef::XRef(BaseStream *strA, GBool repair) {
  290|    318|  GFileOffset pos;
  291|    318|  Object obj;
  292|    318|  XRefPosSet *posSet;
  293|    318|  int i;
  294|       |
  295|    318|  ok = gTrue;
  ------------------
  |  |   17|    318|#define gTrue 1
  ------------------
  296|    318|  errCode = errNone;
  ------------------
  |  |   12|    318|#define errNone             0	// no error
  ------------------
  297|    318|  repaired = gFalse;
  ------------------
  |  |   18|    318|#define gFalse 0
  ------------------
  298|    318|  size = 0;
  299|    318|  last = -1;
  300|    318|  entries = NULL;
  301|    318|  lastStartxrefPos = 0;
  302|    318|  xrefTablePos = NULL;
  303|    318|  xrefTablePosLen = 0;
  304|    318|  streamEnds = NULL;
  305|    318|  streamEndsLen = 0;
  306|  41.0k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  41.0k|#define objStrCacheSize 128
  ------------------
  |  Branch (306:15): [True: 40.7k, False: 318]
  ------------------
  307|  40.7k|    objStrs[i] = NULL;
  308|  40.7k|    objStrLastUse[i] = 0;
  309|  40.7k|  }
  310|    318|  objStrCacheLength = 0;
  311|    318|  objStrTime = 0;
  312|       |
  313|    318|  encrypted = gFalse;
  ------------------
  |  |   18|    318|#define gFalse 0
  ------------------
  314|    318|  permFlags = defPermFlags;
  ------------------
  |  |   41|    318|#define defPermFlags 0xfffc
  ------------------
  315|    318|  ownerPasswordOk = gFalse;
  ------------------
  |  |   18|    318|#define gFalse 0
  ------------------
  316|       |
  317|  5.40k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  5.40k|#define xrefCacheSize 16
  ------------------
  |  Branch (317:15): [True: 5.08k, False: 318]
  ------------------
  318|  5.08k|    cache[i].num = -1;
  319|  5.08k|  }
  320|       |
  321|    318|#if MULTITHREADED
  322|    318|  gInitMutex(&objStrsMutex);
  ------------------
  |  |   51|    318|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  323|    318|  gInitMutex(&cacheMutex);
  ------------------
  |  |   51|    318|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  324|    318|#endif
  325|       |
  326|    318|  str = strA;
  327|    318|  start = str->getStart();
  328|       |
  329|       |  // if the 'repair' flag is set, try to reconstruct the xref table
  330|    318|  if (repair) {
  ------------------
  |  Branch (330:7): [True: 159, False: 159]
  ------------------
  331|    159|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (331:9): [True: 159, False: 0]
  ------------------
  332|    159|      errCode = errDamaged;
  ------------------
  |  |   18|    159|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  333|    159|      return;
  334|    159|    }
  335|      0|    repaired = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  336|       |
  337|       |  // if the 'repair' flag is not set, read the xref table
  338|    159|  } else {
  339|       |
  340|       |    // read the trailer
  341|    159|    pos = getStartXref();
  342|    159|    if (pos == 0) {
  ------------------
  |  Branch (342:9): [True: 95, False: 64]
  ------------------
  343|     95|      errCode = errDamaged;
  ------------------
  |  |   18|     95|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  344|     95|      ok = gFalse;
  ------------------
  |  |   18|     95|#define gFalse 0
  ------------------
  345|     95|      return;
  346|     95|    }
  347|       |
  348|       |    // read the xref table
  349|     64|    posSet = new XRefPosSet();
  350|     64|    while (readXRef(&pos, posSet, gFalse)) ;
  ------------------
  |  |   18|     64|#define gFalse 0
  ------------------
  |  Branch (350:12): [True: 0, False: 64]
  ------------------
  351|     64|    xrefTablePosLen = posSet->getLength();
  352|     64|    xrefTablePos = (GFileOffset *)gmallocn(xrefTablePosLen,
  353|     64|					   sizeof(GFileOffset));
  354|    128|    for (i = 0; i < xrefTablePosLen; ++i)  {
  ------------------
  |  Branch (354:17): [True: 64, False: 64]
  ------------------
  355|     64|      xrefTablePos[i] = posSet->get(i);
  356|     64|    }
  357|     64|    delete posSet;
  358|     64|    if (!ok) {
  ------------------
  |  Branch (358:9): [True: 64, False: 0]
  ------------------
  359|     64|      errCode = errDamaged;
  ------------------
  |  |   18|     64|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  360|     64|      return;
  361|     64|    }
  362|     64|  }
  363|       |
  364|       |  // get the root dictionary (catalog) object
  365|      0|  trailerDict.dictLookupNF("Root", &obj);
  366|      0|  if (obj.isRef()) {
  ------------------
  |  Branch (366:7): [True: 0, False: 0]
  ------------------
  367|      0|    rootNum = obj.getRefNum();
  368|      0|    rootGen = obj.getRefGen();
  369|      0|    obj.free();
  370|      0|  } else {
  371|      0|    obj.free();
  372|      0|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (372:9): [True: 0, False: 0]
  ------------------
  373|      0|      errCode = errDamaged;
  ------------------
  |  |   18|      0|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  374|      0|      return;
  375|      0|    }
  376|      0|  }
  377|       |
  378|       |  // now set the trailer dictionary's xref pointer so we can fetch
  379|       |  // indirect objects from it
  380|      0|  trailerDict.getDict()->setXRef(this);
  381|      0|}
_ZN4XRefD2Ev:
  383|    318|XRef::~XRef() {
  384|    318|  int i;
  385|       |
  386|  5.40k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  5.40k|#define xrefCacheSize 16
  ------------------
  |  Branch (386:15): [True: 5.08k, False: 318]
  ------------------
  387|  5.08k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (387:9): [True: 0, False: 5.08k]
  ------------------
  388|      0|      cache[i].obj.free();
  389|      0|    }
  390|  5.08k|  }
  391|    318|  gfree(entries);
  392|    318|  trailerDict.free();
  393|    318|  if (xrefTablePos) {
  ------------------
  |  Branch (393:7): [True: 64, False: 254]
  ------------------
  394|     64|    gfree(xrefTablePos);
  395|     64|  }
  396|    318|  if (streamEnds) {
  ------------------
  |  Branch (396:7): [True: 1, False: 317]
  ------------------
  397|      1|    gfree(streamEnds);
  398|      1|  }
  399|  41.0k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  41.0k|#define objStrCacheSize 128
  ------------------
  |  Branch (399:15): [True: 40.7k, False: 318]
  ------------------
  400|  40.7k|    if (objStrs[i]) {
  ------------------
  |  Branch (400:9): [True: 0, False: 40.7k]
  ------------------
  401|      0|      delete objStrs[i];
  402|      0|    }
  403|  40.7k|  }
  404|    318|#if MULTITHREADED
  405|    318|  gDestroyMutex(&objStrsMutex);
  ------------------
  |  |   52|    318|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  406|    318|  gDestroyMutex(&cacheMutex);
  ------------------
  |  |   52|    318|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  407|    318|#endif
  408|    318|}
_ZN4XRef12getStartXrefEv:
  411|    159|GFileOffset XRef::getStartXref() {
  412|    159|  char buf[xrefSearchSize+1];
  413|    159|  char *p;
  414|    159|  int n, i;
  415|       |
  416|       |  // read last xrefSearchSize bytes
  417|    159|  str->setPos(xrefSearchSize, -1);
  ------------------
  |  |   30|    159|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  418|    159|  n = str->getBlock(buf, xrefSearchSize);
  ------------------
  |  |   30|    159|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  419|    159|  buf[n] = '\0';
  420|       |
  421|       |  // find startxref
  422|  13.0k|  for (i = n - 9; i >= 0; --i) {
  ------------------
  |  Branch (422:19): [True: 13.0k, False: 85]
  ------------------
  423|  13.0k|    if (!strncmp(&buf[i], "startxref", 9)) {
  ------------------
  |  Branch (423:9): [True: 74, False: 12.9k]
  ------------------
  424|     74|      break;
  425|     74|    }
  426|  13.0k|  }
  427|    159|  if (i < 0) {
  ------------------
  |  Branch (427:7): [True: 85, False: 74]
  ------------------
  428|     85|    return 0;
  429|     85|  }
  430|     75|  for (p = &buf[i+9]; isspace(*p & 0xff); ++p) ;
  ------------------
  |  Branch (430:23): [True: 1, False: 74]
  ------------------
  431|     74|  lastXRefPos = strToFileOffset(p);
  432|     74|  lastStartxrefPos = str->getPos() - n + i;
  433|       |
  434|     74|  return lastXRefPos;
  435|    159|}
_ZN4XRef8readXRefEPlP10XRefPosSeti:
  441|     64|GBool XRef::readXRef(GFileOffset *pos, XRefPosSet *posSet, GBool hybrid) {
  442|     64|  Parser *parser;
  443|     64|  Object obj;
  444|     64|  GBool more;
  445|     64|  char buf[100];
  446|     64|  int n, i;
  447|       |
  448|       |  // check for a loop in the xref tables
  449|     64|  if (posSet->check(*pos)) {
  ------------------
  |  Branch (449:7): [True: 0, False: 64]
  ------------------
  450|      0|    error(errSyntaxWarning, -1, "Infinite loop in xref table");
  451|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  452|      0|  }
  453|     64|  posSet->add(*pos);
  454|       |
  455|       |  // the xref data should either be "xref ..." (for an xref table) or
  456|       |  // "nn gg obj << ... >> stream ..." (for an xref stream); possibly
  457|       |  // preceded by whitespace
  458|     64|  str->setPos(start + *pos);
  459|     64|  n = str->getBlock(buf, 100);
  460|    414|  for (i = 0; i < n && Lexer::isSpace(buf[i]); ++i) ;
  ------------------
  |  Branch (460:15): [True: 410, False: 4]
  |  Branch (460:24): [True: 350, False: 60]
  ------------------
  461|       |
  462|       |  // parse an old-style xref table
  463|     64|  if (!hybrid &&
  ------------------
  |  Branch (463:7): [True: 64, False: 0]
  ------------------
  464|     64|      i + 4 < n &&
  ------------------
  |  Branch (464:7): [True: 60, False: 4]
  ------------------
  465|     64|      buf[i] == 'x' && buf[i+1] == 'r' && buf[i+2] == 'e' && buf[i+3] == 'f' &&
  ------------------
  |  Branch (465:7): [True: 0, False: 60]
  |  Branch (465:24): [True: 0, False: 0]
  |  Branch (465:43): [True: 0, False: 0]
  |  Branch (465:62): [True: 0, False: 0]
  ------------------
  466|     64|      Lexer::isSpace(buf[i+4])) {
  ------------------
  |  Branch (466:7): [True: 0, False: 0]
  ------------------
  467|      0|    more = readXRefTable(pos, i + 5, posSet);
  468|       |
  469|       |  // parse an xref stream
  470|     64|  } else {
  471|     64|    obj.initNull();
  472|     64|    parser = new Parser(NULL,
  473|     64|	       new Lexer(NULL,
  474|     64|		 str->makeSubStream(start + *pos, gFalse, 0, &obj)),
  ------------------
  |  |   18|     64|#define gFalse 0
  ------------------
  475|     64|	       gTrue);
  ------------------
  |  |   17|     64|#define gTrue 1
  ------------------
  476|     64|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|     64|#define gTrue 1
  ------------------
  |  Branch (476:9): [True: 57, False: 7]
  ------------------
  477|     57|      goto err;
  478|     57|    }
  479|      7|    obj.free();
  480|      7|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|      7|#define gTrue 1
  ------------------
  |  Branch (480:9): [True: 7, False: 0]
  ------------------
  481|      7|      goto err;
  482|      7|    }
  483|      0|    obj.free();
  484|      0|    if (!parser->getObj(&obj, gTrue)->isCmd("obj")) {
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  |  Branch (484:9): [True: 0, False: 0]
  ------------------
  485|      0|      goto err;
  486|      0|    }
  487|      0|    obj.free();
  488|      0|    if (!parser->getObj(&obj)->isStream()) {
  ------------------
  |  Branch (488:9): [True: 0, False: 0]
  ------------------
  489|      0|      goto err;
  490|      0|    }
  491|      0|    more = readXRefStream(obj.getStream(), pos, hybrid);
  492|      0|    obj.free();
  493|      0|    delete parser;
  494|      0|  }
  495|       |
  496|      0|  return more;
  497|       |
  498|     64| err:
  499|     64|  obj.free();
  500|     64|  delete parser;
  501|     64|  ok = gFalse;
  ------------------
  |  |   18|     64|#define gFalse 0
  ------------------
  502|     64|  return gFalse;
  ------------------
  |  |   18|     64|#define gFalse 0
  ------------------
  503|     64|}
_ZN4XRef13constructXRefEv:
  864|    159|GBool XRef::constructXRef() {
  865|    159|  int *streamObjNums = NULL;
  866|    159|  int streamObjNumsLen = 0;
  867|    159|  int streamObjNumsSize = 0;
  868|    159|  int lastObjNum = -1;
  869|    159|  rootNum = -1;
  870|    159|  int streamEndsSize = 0;
  871|    159|  streamEndsLen = 0;
  872|    159|  char buf[4096 + 1];
  873|    159|  str->reset();
  874|    159|  GFileOffset bufPos = start;
  875|    159|  char *p = buf;
  876|    159|  char *end = buf;
  877|    159|  GBool startOfLine = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  878|    159|  GBool space = gTrue;
  ------------------
  |  |   17|    159|#define gTrue 1
  ------------------
  879|    159|  GBool eof = gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  880|  18.2k|  while (1) {
  ------------------
  |  Branch (880:10): [Folded - Ignored]
  ------------------
  881|  18.2k|    if (end - p < 256 && !eof) {
  ------------------
  |  Branch (881:9): [True: 15.7k, False: 2.58k]
  |  Branch (881:26): [True: 159, False: 15.5k]
  ------------------
  882|    159|      memcpy(buf, p, end - p);
  883|    159|      bufPos += p - buf;
  884|    159|      p = buf + (end - p);
  885|    159|      int n = (int)(buf + 4096 - p);
  886|    159|      int m = str->getBlock(p, n);
  887|    159|      end = p + m;
  888|    159|      *end = '\0';
  889|    159|      p = buf;
  890|    159|      eof = m < n;
  891|    159|    }
  892|  18.2k|    if (p == end && eof) {
  ------------------
  |  Branch (892:9): [True: 159, False: 18.1k]
  |  Branch (892:21): [True: 159, False: 0]
  ------------------
  893|    159|      break;
  894|    159|    }
  895|  18.1k|    if (startOfLine && !strncmp(p, "trailer", 7)) {
  ------------------
  |  Branch (895:9): [True: 698, False: 17.4k]
  |  Branch (895:24): [True: 11, False: 687]
  ------------------
  896|     11|      constructTrailerDict((GFileOffset)(bufPos + (p + 7 - buf)));
  897|     11|      p += 7;
  898|     11|      startOfLine = gFalse;
  ------------------
  |  |   18|     11|#define gFalse 0
  ------------------
  899|     11|      space = gFalse;
  ------------------
  |  |   18|     11|#define gFalse 0
  ------------------
  900|  18.1k|    } else if (startOfLine && !strncmp(p, "endstream", 9)) {
  ------------------
  |  Branch (900:16): [True: 687, False: 17.4k]
  |  Branch (900:31): [True: 1, False: 686]
  ------------------
  901|      1|      if (streamEndsLen == streamEndsSize) {
  ------------------
  |  Branch (901:11): [True: 1, False: 0]
  ------------------
  902|      1|	streamEndsSize += 64;
  903|      1|	streamEnds = (GFileOffset *)greallocn(streamEnds, streamEndsSize,
  904|      1|					      sizeof(GFileOffset));
  905|      1|      }
  906|      1|      streamEnds[streamEndsLen++] = (GFileOffset)(bufPos + (p - buf));
  907|      1|      p += 9;
  908|      1|      startOfLine = gFalse;
  ------------------
  |  |   18|      1|#define gFalse 0
  ------------------
  909|      1|      space = gFalse;
  ------------------
  |  |   18|      1|#define gFalse 0
  ------------------
  910|  18.1k|    } else if (space && *p >= '0' && *p <= '9') {
  ------------------
  |  Branch (910:16): [True: 4.47k, False: 13.6k]
  |  Branch (910:25): [True: 153, False: 4.32k]
  |  Branch (910:38): [True: 43, False: 110]
  ------------------
  911|     43|      p = constructObjectEntry(p, (GFileOffset)(bufPos + (p - buf)),
  912|     43|			       &lastObjNum);
  913|     43|      startOfLine = gFalse;
  ------------------
  |  |   18|     43|#define gFalse 0
  ------------------
  914|     43|      space = gFalse;
  ------------------
  |  |   18|     43|#define gFalse 0
  ------------------
  915|  18.0k|    } else if (p[0] == '>' && p[1] == '>') {
  ------------------
  |  Branch (915:16): [True: 29, False: 18.0k]
  |  Branch (915:31): [True: 0, False: 29]
  ------------------
  916|      0|      p += 2;
  917|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  918|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  919|       |      // skip any PDF whitespace except for '\0'
  920|      0|      while (*p == '\t' || *p == '\n' || *p == '\x0c' ||
  ------------------
  |  Branch (920:14): [True: 0, False: 0]
  |  Branch (920:28): [True: 0, False: 0]
  |  Branch (920:42): [True: 0, False: 0]
  ------------------
  921|      0|	     *p == '\r' || *p == ' ') {
  ------------------
  |  Branch (921:7): [True: 0, False: 0]
  |  Branch (921:21): [True: 0, False: 0]
  ------------------
  922|      0|	if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (922:6): [True: 0, False: 0]
  |  Branch (922:20): [True: 0, False: 0]
  ------------------
  923|      0|	  startOfLine = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  924|      0|	}
  925|      0|	space = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  926|      0|	++p;
  927|      0|      }
  928|      0|      if (!strncmp(p, "stream", 6)) {
  ------------------
  |  Branch (928:11): [True: 0, False: 0]
  ------------------
  929|      0|	if (lastObjNum >= 0) {
  ------------------
  |  Branch (929:6): [True: 0, False: 0]
  ------------------
  930|      0|	  if (streamObjNumsLen == streamObjNumsSize) {
  ------------------
  |  Branch (930:8): [True: 0, False: 0]
  ------------------
  931|      0|	    streamObjNumsSize += 64;
  932|      0|	    streamObjNums = (int *)greallocn(streamObjNums, streamObjNumsSize,
  933|      0|					     sizeof(int));
  934|      0|	  }
  935|      0|	  streamObjNums[streamObjNumsLen++] = lastObjNum;
  936|      0|	}
  937|      0|	p += 6;
  938|      0|	startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  939|      0|	space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  940|      0|      }
  941|  18.0k|    } else {
  942|  18.0k|      if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (942:11): [True: 171, False: 17.9k]
  |  Branch (942:25): [True: 39, False: 17.8k]
  ------------------
  943|    210|	startOfLine = gTrue;
  ------------------
  |  |   17|    210|#define gTrue 1
  ------------------
  944|    210|	space = gTrue;
  ------------------
  |  |   17|    210|#define gTrue 1
  ------------------
  945|  17.8k|      } else if (Lexer::isSpace(*p & 0xff)) {
  ------------------
  |  Branch (945:18): [True: 4.15k, False: 13.7k]
  ------------------
  946|  4.15k|	space = gTrue;
  ------------------
  |  |   17|  4.15k|#define gTrue 1
  ------------------
  947|  13.7k|      } else {
  948|  13.7k|	startOfLine = gFalse;
  ------------------
  |  |   18|  13.7k|#define gFalse 0
  ------------------
  949|  13.7k|	space = gFalse;
  ------------------
  |  |   18|  13.7k|#define gFalse 0
  ------------------
  950|  13.7k|      }
  951|  18.0k|      ++p;
  952|  18.0k|    }
  953|  18.1k|  }
  954|       |
  955|       |  // read each stream object, check for xref or object stream
  956|    159|  for (int i = 0; i < streamObjNumsLen; ++i) {
  ------------------
  |  Branch (956:19): [True: 0, False: 159]
  ------------------
  957|      0|    Object obj;
  958|      0|    fetch(streamObjNums[i], entries[streamObjNums[i]].gen, &obj);
  959|      0|    if (obj.isStream()) {
  ------------------
  |  Branch (959:9): [True: 0, False: 0]
  ------------------
  960|      0|      Dict *dict = obj.streamGetDict();
  961|      0|      Object type;
  962|      0|      dict->lookup("Type", &type);
  963|      0|      if (type.isName("XRef")) {
  ------------------
  |  Branch (963:11): [True: 0, False: 0]
  ------------------
  964|      0|	saveTrailerDict(dict, gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  965|      0|      } else if (type.isName("ObjStm")) {
  ------------------
  |  Branch (965:18): [True: 0, False: 0]
  ------------------
  966|      0|	constructObjectStreamEntries(&obj, streamObjNums[i]);
  967|      0|      }
  968|      0|      type.free();
  969|      0|    }
  970|      0|    obj.free();
  971|      0|  }
  972|       |
  973|    159|  gfree(streamObjNums);
  974|       |
  975|       |  // if the file is encrypted, then any objects fetched here will be
  976|       |  // incorrect (because decryption is not yet enabled), so clear the
  977|       |  // cache to avoid that problem
  978|  2.70k|  for (int i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  2.70k|#define xrefCacheSize 16
  ------------------
  |  Branch (978:19): [True: 2.54k, False: 159]
  ------------------
  979|  2.54k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (979:9): [True: 0, False: 2.54k]
  ------------------
  980|      0|      cache[i].obj.free();
  981|      0|      cache[i].num = -1;
  982|      0|    }
  983|  2.54k|  }
  984|       |
  985|    159|  if (rootNum < 0) {
  ------------------
  |  Branch (985:7): [True: 159, False: 0]
  ------------------
  986|    159|    error(errSyntaxError, -1, "Couldn't find trailer dictionary");
  987|    159|    return gFalse;
  ------------------
  |  |   18|    159|#define gFalse 0
  ------------------
  988|    159|  }
  989|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  990|    159|}
_ZN4XRef20constructTrailerDictEl:
  993|     11|void XRef::constructTrailerDict(GFileOffset pos) {
  994|     11|  Object newTrailerDict, obj;
  995|     11|  obj.initNull();
  996|     11|  Parser *parser =
  997|     11|      new Parser(NULL,
  998|     11|		 new Lexer(NULL,
  999|     11|			   str->makeSubStream(pos, gFalse, 0, &obj)),
  ------------------
  |  |   18|     11|#define gFalse 0
  ------------------
 1000|     11|		 gFalse);
  ------------------
  |  |   18|     11|#define gFalse 0
  ------------------
 1001|     11|  parser->getObj(&newTrailerDict);
 1002|     11|  if (newTrailerDict.isDict()) {
  ------------------
  |  Branch (1002:7): [True: 0, False: 11]
  ------------------
 1003|      0|    saveTrailerDict(newTrailerDict.getDict(), gFalse);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 1004|      0|  }
 1005|     11|  newTrailerDict.free();
 1006|     11|  delete parser;
 1007|     11|}
_ZN4XRef20constructObjectEntryEPclPi:
 1032|     43|char *XRef::constructObjectEntry(char *p, GFileOffset pos, int *objNum) {
 1033|       |  // we look for non-end-of-line space characters here, to deal with
 1034|       |  // situations like:
 1035|       |  //    nnn          <-- garbage digits on a line
 1036|       |  //    nnn nnn obj  <-- actual object
 1037|       |  // and we also ignore '\0' (because it's used to terminate the
 1038|       |  // buffer in this damage-scanning code)
 1039|     43|  int num = 0;
 1040|    176|  do {
 1041|    176|    num = (num * 10) + (*p - '0');
 1042|    176|    ++p;
 1043|    176|  } while (*p >= '0' && *p <= '9' && num < 100000000);
  ------------------
  |  Branch (1043:12): [True: 157, False: 19]
  |  Branch (1043:25): [True: 142, False: 15]
  |  Branch (1043:38): [True: 133, False: 9]
  ------------------
 1044|     43|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1044:7): [True: 43, False: 0]
  |  Branch (1044:21): [True: 42, False: 1]
  |  Branch (1044:37): [True: 42, False: 0]
  ------------------
 1045|     42|    return p;
 1046|     42|  }
 1047|     57|  do {
 1048|     57|    ++p;
 1049|     57|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1049:12): [True: 0, False: 57]
  |  Branch (1049:26): [True: 56, False: 1]
  |  Branch (1049:42): [True: 0, False: 1]
  ------------------
 1050|      1|  if (!(*p >= '0' && *p <= '9')) {
  ------------------
  |  Branch (1050:9): [True: 1, False: 0]
  |  Branch (1050:22): [True: 1, False: 0]
  ------------------
 1051|      0|    return p;
 1052|      0|  }
 1053|      1|  int gen = 0;
 1054|      3|  do {
 1055|      3|    gen = (gen * 10) + (*p - '0');
 1056|      3|    ++p;
 1057|      3|  } while (*p >= '0' && *p <= '9' && gen < 100000000);
  ------------------
  |  Branch (1057:12): [True: 2, False: 1]
  |  Branch (1057:25): [True: 2, False: 0]
  |  Branch (1057:38): [True: 2, False: 0]
  ------------------
 1058|      1|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1058:7): [True: 1, False: 0]
  |  Branch (1058:21): [True: 1, False: 0]
  |  Branch (1058:37): [True: 1, False: 0]
  ------------------
 1059|      1|    return p;
 1060|      1|  }
 1061|      0|  do {
 1062|      0|    ++p;
 1063|      0|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1063:12): [True: 0, False: 0]
  |  Branch (1063:26): [True: 0, False: 0]
  |  Branch (1063:42): [True: 0, False: 0]
  ------------------
 1064|      0|  if (strncmp(p, "obj", 3)) {
  ------------------
  |  Branch (1064:7): [True: 0, False: 0]
  ------------------
 1065|      0|    return p;
 1066|      0|  }
 1067|       |
 1068|      0|  if (constructXRefEntry(num, gen, pos - start, xrefEntryUncompressed)) {
  ------------------
  |  Branch (1068:7): [True: 0, False: 0]
  ------------------
 1069|      0|    *objNum = num;
 1070|      0|  }
 1071|       |
 1072|      0|  return p;
 1073|      0|}
_ZN4XRef15strToFileOffsetEPc:
 1435|     74|GFileOffset XRef::strToFileOffset(char *s) {
 1436|     74|  GFileOffset x, d;
 1437|     74|  char *p;
 1438|       |
 1439|     74|  x = 0;
 1440|    157|  for (p = s; *p && isdigit(*p & 0xff); ++p) {
  ------------------
  |  Branch (1440:15): [True: 95, False: 62]
  |  Branch (1440:21): [True: 83, False: 12]
  ------------------
 1441|     83|    d = *p - '0';
 1442|     83|    if (x > (GFILEOFFSET_MAX - d) / 10) {
  ------------------
  |  |  128|     83|#define GFILEOFFSET_MAX 0x7fffffffffffffffLL
  ------------------
  |  Branch (1442:9): [True: 0, False: 83]
  ------------------
 1443|      0|      break;
 1444|      0|    }
 1445|     83|    x = 10 * x + d;
 1446|     83|  }
 1447|     74|  return x;
 1448|     74|}
_ZN10XRefPosSet9getLengthEv:
   54|     64|  int getLength() { return len; }
_ZN10XRefPosSet3getEi:
   55|     64|  GFileOffset get(int idx) { return tab[idx]; }

_ZN4XRef4isOkEv:
   64|    318|  GBool isOk() { return ok; }
_ZN4XRef12getErrorCodeEv:
   67|    318|  int getErrorCode() { return errCode; }

