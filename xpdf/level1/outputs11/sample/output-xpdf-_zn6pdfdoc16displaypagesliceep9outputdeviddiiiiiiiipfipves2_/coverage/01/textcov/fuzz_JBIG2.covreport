LLVMFuzzerTestOneInput:
   27|    113|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   28|    113|  FuzzedDataProvider fdp(data, size);
   29|    113|  double hdpi = fdp.ConsumeFloatingPoint<double>();
   30|    113|  double vdpi = fdp.ConsumeFloatingPoint<double>();
   31|    113|  int rotate = fdp.ConsumeIntegral<int>();
   32|    113|  bool useMediaBox = fdp.ConsumeBool();
   33|    113|  bool crop = fdp.ConsumeBool();
   34|    113|  bool printing = fdp.ConsumeBool();
   35|    113|  std::vector<char> payload = fdp.ConsumeRemainingBytes<char>();
   36|       |
   37|    113|  Object xpdf_obj;
   38|    113|  xpdf_obj.initNull();
   39|    113|  BaseStream *stream = new MemStream(payload.data(), 0, payload.size(), &xpdf_obj);
   40|       |
   41|    113|  Object info, xfa;
   42|    113|  Object *acroForm;
   43|    113|  globalParams = new GlobalParams(NULL);
   44|    113|  globalParams->setErrQuiet(1);
   45|    113|  globalParams->setupBaseFonts(NULL);
   46|    113|  char yes[] = "yes";
   47|    113|  globalParams->setEnableFreeType(yes); // Yes, it's a string and not a bool.
   48|    113|  globalParams->setErrQuiet(1);
   49|       |
   50|    113|  PDFDoc *doc = NULL;
   51|    113|  try {
   52|    113|    PDFDoc doc(stream);
   53|    113|    if (doc.isOk() == gTrue) {
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  |  Branch (53:9): [True: 0, False: 113]
  ------------------
   54|      0|      doc.getNumPages();
   55|      0|      doc.getOutline();
   56|      0|      doc.getStructTreeRoot();
   57|      0|      doc.getXRef();
   58|      0|      doc.okToPrint(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   59|      0|      doc.okToCopy(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   60|      0|      doc.okToChange(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   61|      0|      doc.okToAddNotes(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   62|      0|      doc.isLinearized();
   63|      0|      doc.getPDFVersion();
   64|       |
   65|      0|      GString *metadata;
   66|      0|      if ((metadata = doc.readMetadata())) {
  ------------------
  |  Branch (66:11): [True: 0, False: 0]
  ------------------
   67|      0|        (void)metadata->getCString();
   68|      0|      }
   69|      0|      delete metadata;
   70|       |
   71|      0|      Object info;
   72|      0|      doc.getDocInfo(&info);
   73|      0|      if (info.isDict()) {
  ------------------
  |  Branch (73:11): [True: 0, False: 0]
  ------------------
   74|      0|        info.getDict();
   75|      0|      }
   76|      0|      info.free();
   77|       |
   78|      0|      if ((acroForm = doc.getCatalog()->getAcroForm())->isDict()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|        acroForm->dictLookup("XFA", &xfa);
   80|      0|        xfa.free();
   81|      0|      }
   82|       |
   83|      0|      for (size_t i = 1; i <= doc.getNumPages(); i++) {
  ------------------
  |  Branch (83:26): [True: 0, False: 0]
  ------------------
   84|      0|        doc.getLinks(i);
   85|      0|        auto page = doc.getCatalog()->getPage(i);
   86|      0|        if (!page->isOk()) {
  ------------------
  |  Branch (86:13): [True: 0, False: 0]
  ------------------
   87|      0|          continue;
   88|      0|        }
   89|      0|        page->getResourceDict();
   90|      0|        page->getMetadata();
   91|      0|        page->getResourceDict();
   92|      0|      }
   93|       |
   94|      0|      SplashColor paperColor = {0xff, 0xff, 0xff};
   95|      0|      SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 1, gFalse, paperColor);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   96|      0|      splashOut->setNoComposite(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   97|      0|      splashOut->startDoc(doc.getXRef());
   98|      0|      for (size_t i = 1; i <= doc.getNumPages(); ++i) {
  ------------------
  |  Branch (98:26): [True: 0, False: 0]
  ------------------
   99|      0|        doc.displayPageSlice(splashOut, i, hdpi, vdpi, rotate, useMediaBox, crop, printing, 0, 0, 0, 0, nullptr, nullptr);
  100|      0|      }
  101|      0|      (void)splashOut->getBitmap();
  102|       |
  103|      0|      delete splashOut;
  104|      0|    }
  105|    113|  } catch (...) {
  106|      0|  }
  107|       |
  108|    113|  delete globalParams;
  109|       |
  110|    113|  return 0;
  111|    113|}

_ZN5GHashC2Ei:
   34|  1.24k|GHash::GHash(GBool deleteKeysA) {
   35|  1.24k|  int h;
   36|       |
   37|  1.24k|  deleteKeys = deleteKeysA;
   38|  1.24k|  size = 7;
   39|  1.24k|  tab = (GHashBucket **)gmallocn(size, sizeof(GHashBucket *));
   40|  9.94k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (40:15): [True: 8.70k, False: 1.24k]
  ------------------
   41|  8.70k|    tab[h] = NULL;
   42|  8.70k|  }
   43|  1.24k|  len = 0;
   44|  1.24k|}
_ZN5GHashD2Ev:
   46|  1.24k|GHash::~GHash() {
   47|  1.24k|  GHashBucket *p;
   48|  1.24k|  int h;
   49|       |
   50|  9.94k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (50:15): [True: 8.70k, False: 1.24k]
  ------------------
   51|  9.49k|    while (tab[h]) {
  ------------------
  |  Branch (51:12): [True: 791, False: 8.70k]
  ------------------
   52|    791|      p = tab[h];
   53|    791|      tab[h] = p->next;
   54|    791|      if (deleteKeys) {
  ------------------
  |  Branch (54:11): [True: 113, False: 678]
  ------------------
   55|    113|	delete p->key;
   56|    113|      }
   57|    791|      delete p;
   58|    791|    }
   59|  8.70k|  }
   60|  1.24k|  gfree(tab);
   61|  1.24k|}
_ZN5GHash3addEP7GStringPv:
   63|    791|void GHash::add(GString *key, void *val) {
   64|    791|  GHashBucket *p;
   65|    791|  int h;
   66|       |
   67|       |  // expand the table if necessary
   68|    791|  if (len >= size) {
  ------------------
  |  Branch (68:7): [True: 0, False: 791]
  ------------------
   69|      0|    expand();
   70|      0|  }
   71|       |
   72|       |  // add the new symbol
   73|    791|  p = new GHashBucket;
   74|    791|  p->key = key;
   75|    791|  p->val.p = val;
   76|    791|  h = hash(key);
   77|    791|  p->next = tab[h];
   78|    791|  tab[h] = p;
   79|    791|  ++len;
   80|    791|}
_ZN5GHash6lookupEPKc:
  149|  5.19k|void *GHash::lookup(const char *key) {
  150|  5.19k|  GHashBucket *p;
  151|  5.19k|  int h;
  152|       |
  153|  5.19k|  if (!(p = find(key, &h))) {
  ------------------
  |  Branch (153:7): [True: 5.19k, False: 0]
  ------------------
  154|  5.19k|    return NULL;
  155|  5.19k|  }
  156|      0|  return p->val.p;
  157|  5.19k|}
_ZN5GHash9startIterEPP9GHashIter:
  261|  1.13k|void GHash::startIter(GHashIter **iter) {
  262|  1.13k|  *iter = new GHashIter;
  263|  1.13k|  (*iter)->h = -1;
  264|  1.13k|  (*iter)->p = NULL;
  265|  1.13k|}
_ZN5GHash7getNextEPP9GHashIterPP7GStringPPv:
  267|  1.92k|GBool GHash::getNext(GHashIter **iter, GString **key, void **val) {
  268|  1.92k|  if (!*iter) {
  ------------------
  |  Branch (268:7): [True: 0, False: 1.92k]
  ------------------
  269|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  270|      0|  }
  271|  1.92k|  if ((*iter)->p) {
  ------------------
  |  Branch (271:7): [True: 791, False: 1.13k]
  ------------------
  272|    791|    (*iter)->p = (*iter)->p->next;
  273|    791|  }
  274|  9.83k|  while (!(*iter)->p) {
  ------------------
  |  Branch (274:10): [True: 9.04k, False: 791]
  ------------------
  275|  9.04k|    if (++(*iter)->h == size) {
  ------------------
  |  Branch (275:9): [True: 1.13k, False: 7.91k]
  ------------------
  276|  1.13k|      delete *iter;
  277|  1.13k|      *iter = NULL;
  278|  1.13k|      return gFalse;
  ------------------
  |  |   18|  1.13k|#define gFalse 0
  ------------------
  279|  1.13k|    }
  280|  7.91k|    (*iter)->p = tab[(*iter)->h];
  281|  7.91k|  }
  282|    791|  *key = (*iter)->p->key;
  283|    791|  *val = (*iter)->p->val.p;
  284|    791|  return gTrue;
  ------------------
  |  |   17|    791|#define gTrue 1
  ------------------
  285|  1.92k|}
_ZN5GHash4findEPKcPi:
  348|  5.19k|GHashBucket *GHash::find(const char *key, int *h) {
  349|  5.19k|  GHashBucket *p;
  350|       |
  351|  5.19k|  *h = hash(key);
  352|  5.19k|  for (p = tab[*h]; p; p = p->next) {
  ------------------
  |  Branch (352:21): [True: 0, False: 5.19k]
  ------------------
  353|      0|    if (!p->key->cmp(key)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 0]
  ------------------
  354|      0|      return p;
  355|      0|    }
  356|      0|  }
  357|  5.19k|  return NULL;
  358|  5.19k|}
_ZN5GHash4hashEP7GString:
  360|    791|int GHash::hash(GString *key) {
  361|    791|  const char *p;
  362|    791|  unsigned int h;
  363|    791|  int i;
  364|       |
  365|    791|  h = 0;
  366|  6.10k|  for (p = key->getCString(), i = 0; i < key->getLength(); ++p, ++i) {
  ------------------
  |  Branch (366:38): [True: 5.31k, False: 791]
  ------------------
  367|  5.31k|    h = 17 * h + (int)(*p & 0xff);
  368|  5.31k|  }
  369|    791|  return (int)(h % size);
  370|    791|}
_ZN5GHash4hashEPKc:
  372|  5.19k|int GHash::hash(const char *key) {
  373|  5.19k|  const char *p;
  374|  5.19k|  unsigned int h;
  375|       |
  376|  5.19k|  h = 0;
  377|  71.3k|  for (p = key; *p; ++p) {
  ------------------
  |  Branch (377:17): [True: 66.1k, False: 5.19k]
  ------------------
  378|  66.1k|    h = 17 * h + (int)(*p & 0xff);
  379|  66.1k|  }
  380|  5.19k|  return (int)(h % size);
  381|  5.19k|}

_ZN5GListC2Ev:
   21|  7.79k|GList::GList() {
   22|  7.79k|  size = 8;
   23|  7.79k|  data = (void **)gmallocn(size, sizeof(void*));
   24|  7.79k|  length = 0;
   25|  7.79k|  inc = 0;
   26|  7.79k|}
_ZN5GListD2Ev:
   35|  7.79k|GList::~GList() {
   36|  7.79k|  gfree(data);
   37|  7.79k|}
_ZN5GList6appendEPv:
   49|  15.2k|void GList::append(void *p) {
   50|  15.2k|  if (length >= size) {
  ------------------
  |  Branch (50:7): [True: 452, False: 14.8k]
  ------------------
   51|    452|    expand();
   52|    452|  }
   53|  15.2k|  data[length++] = p;
   54|  15.2k|}
_ZN5GList6expandEv:
  116|    452|void GList::expand() {
  117|    452|  size += (inc > 0) ? inc : size;
  ------------------
  |  Branch (117:11): [True: 0, False: 452]
  ------------------
  118|    452|  data = (void **)greallocn(data, size, sizeof(void*));
  119|    452|}

_ZN5GList9getLengthEv:
   35|  23.0k|  int getLength() { return length; }
_ZN5GList3getEi:
   44|  15.2k|  void *get(int i) { return data[i]; }

_ZN7GStringC2EPKc:
  135|  20.3k|GString::GString(const char *sA) {
  136|  20.3k|  int n = (int)strlen(sA);
  137|       |
  138|  20.3k|  s = NULL;
  139|  20.3k|  resize(length = n);
  140|  20.3k|  memcpy(s, sA, n + 1);
  141|  20.3k|}
_ZN7GStringD2Ev:
  204|  20.3k|GString::~GString() {
  205|  20.3k|  delete[] s;
  206|  20.3k|}
_ZN7GString6appendEc:
  214|  8.47k|GString *GString::append(char c) {
  215|  8.47k|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 8.47k]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|  8.47k|  resize(length + 1);
  219|  8.47k|  s[length++] = c;
  220|  8.47k|  s[length] = '\0';
  221|  8.47k|  return this;
  222|  8.47k|}
_ZN7GString6appendEPKc:
  236|  8.47k|GString *GString::append(const char *str) {
  237|  8.47k|  int n = (int)strlen(str);
  238|       |
  239|  8.47k|  if (length > INT_MAX - n) {
  ------------------
  |  Branch (239:7): [True: 0, False: 8.47k]
  ------------------
  240|      0|    gMemError("Integer overflow in GString::append()");
  241|      0|  }
  242|  8.47k|  resize(length + n);
  243|  8.47k|  memcpy(s + length, str, n + 1);
  244|  8.47k|  length += n;
  245|  8.47k|  return this;
  246|  8.47k|}
_ZN7GString6resizeEi:
  108|  37.2k|inline void GString::resize(int length1) {
  109|  37.2k|  char *s1;
  110|       |
  111|  37.2k|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 37.2k]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|  37.2k|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 20.3k, False: 16.9k]
  ------------------
  115|  20.3k|    s = new char[size(length1)];
  116|  20.3k|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 5.31k, False: 11.6k]
  ------------------
  117|  5.31k|    s1 = new char[size(length1)];
  118|  5.31k|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 5.31k]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|  5.31k|    } else {
  122|  5.31k|      memcpy(s1, s, length + 1);
  123|  5.31k|    }
  124|  5.31k|    delete[] s;
  125|  5.31k|    s = s1;
  126|  5.31k|  }
  127|  37.2k|}
GString.cc:_ZL4sizei:
   98|  59.5k|static inline int size(int len) {
   99|  59.5k|  int delta;
  100|   181k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 122k, False: 59.5k]
  |  Branch (100:34): [True: 122k, False: 0]
  ------------------
  101|  59.5k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 59.5k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|  59.5k|  return (len + delta) & ~(delta - 1);
  106|  59.5k|}

_ZN7GString10getCStringEv:
   79|  8.92k|  char *getCString() { return s; }
_ZN7GString9getLengthEv:
   76|  23.0k|  int getLength() { return length; }
_ZN7GString7getCharEi:
   82|  8.47k|  char getChar(int i) { return s[i]; }

_Z10getHomeDirv:
   49|    565|GString *getHomeDir() {
   50|       |#ifdef VMS
   51|       |  //---------- VMS ----------
   52|       |  return new GString("SYS$LOGIN:");
   53|       |
   54|       |#elif defined(_WIN32)
   55|       |  //---------- Win32 ----------
   56|       |  char *s;
   57|       |  GString *ret;
   58|       |
   59|       |  if ((s = getenv("USERPROFILE")))
   60|       |    ret = new GString(s);
   61|       |  else
   62|       |    ret = new GString(".");
   63|       |  return ret;
   64|       |
   65|       |#elif defined(__EMX__)
   66|       |  //---------- OS/2+EMX ----------
   67|       |  char *s;
   68|       |  GString *ret;
   69|       |
   70|       |  if ((s = getenv("HOME")))
   71|       |    ret = new GString(s);
   72|       |  else
   73|       |    ret = new GString(".");
   74|       |  return ret;
   75|       |
   76|       |#elif defined(ACORN)
   77|       |  //---------- RISCOS ----------
   78|       |  return new GString("@");
   79|       |
   80|       |#else
   81|       |  //---------- Unix ----------
   82|    565|  char *s;
   83|    565|  struct passwd *pw;
   84|    565|  GString *ret;
   85|       |
   86|    565|  if ((s = getenv("HOME"))) {
  ------------------
  |  Branch (86:7): [True: 565, False: 0]
  ------------------
   87|    565|    ret = new GString(s);
   88|    565|  } else {
   89|      0|    if ((s = getenv("USER")))
  ------------------
  |  Branch (89:9): [True: 0, False: 0]
  ------------------
   90|      0|      pw = getpwnam(s);
   91|      0|    else
   92|      0|      pw = getpwuid(getuid());
   93|      0|    if (pw)
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      ret = new GString(pw->pw_dir);
   95|      0|    else
   96|      0|      ret = new GString(".");
   97|      0|  }
   98|    565|  return ret;
   99|    565|#endif
  100|    565|}
_Z12appendToPathP7GStringPKc:
  118|  8.47k|GString *appendToPath(GString *path, const char *fileName) {
  119|       |#if defined(VMS)
  120|       |  //---------- VMS ----------
  121|       |  //~ this should handle everything necessary for file
  122|       |  //~ requesters, but it's certainly not complete
  123|       |  char *p0, *p1, *p2;
  124|       |  char *q1;
  125|       |
  126|       |  p0 = path->getCString();
  127|       |  p1 = p0 + path->getLength() - 1;
  128|       |  if (!strcmp(fileName, "-")) {
  129|       |    if (*p1 == ']') {
  130|       |      for (p2 = p1; p2 > p0 && *p2 != '.' && *p2 != '['; --p2) ;
  131|       |      if (*p2 == '[')
  132|       |	++p2;
  133|       |      path->del(p2 - p0, p1 - p2);
  134|       |    } else if (*p1 == ':') {
  135|       |      path->append("[-]");
  136|       |    } else {
  137|       |      path->clear();
  138|       |      path->append("[-]");
  139|       |    }
  140|       |  } else if ((q1 = strrchr(fileName, '.')) && !strncmp(q1, ".DIR;", 5)) {
  141|       |    if (*p1 == ']') {
  142|       |      path->insert(p1 - p0, '.');
  143|       |      path->insert(p1 - p0 + 1, fileName, q1 - fileName);
  144|       |    } else if (*p1 == ':') {
  145|       |      path->append('[');
  146|       |      path->append(']');
  147|       |      path->append(fileName, q1 - fileName);
  148|       |    } else {
  149|       |      path->clear();
  150|       |      path->append(fileName, q1 - fileName);
  151|       |    }
  152|       |  } else {
  153|       |    if (*p1 != ']' && *p1 != ':')
  154|       |      path->clear();
  155|       |    path->append(fileName);
  156|       |  }
  157|       |  return path;
  158|       |
  159|       |#elif defined(_WIN32)
  160|       |  //---------- Win32 ----------
  161|       |  GString *tmp;
  162|       |  char buf[256];
  163|       |  char *fp;
  164|       |
  165|       |  tmp = new GString(path);
  166|       |  tmp->append('/');
  167|       |  tmp->append(fileName);
  168|       |  GetFullPathNameA(tmp->getCString(), sizeof(buf), buf, &fp);
  169|       |  delete tmp;
  170|       |  path->clear();
  171|       |  path->append(buf);
  172|       |  return path;
  173|       |
  174|       |#elif defined(ACORN)
  175|       |  //---------- RISCOS ----------
  176|       |  char *p;
  177|       |  int i;
  178|       |
  179|       |  path->append(".");
  180|       |  i = path->getLength();
  181|       |  path->append(fileName);
  182|       |  for (p = path->getCString() + i; *p; ++p) {
  183|       |    if (*p == '/') {
  184|       |      *p = '.';
  185|       |    } else if (*p == '.') {
  186|       |      *p = '/';
  187|       |    }
  188|       |  }
  189|       |  return path;
  190|       |
  191|       |#elif defined(__EMX__)
  192|       |  //---------- OS/2+EMX ----------
  193|       |  int i;
  194|       |
  195|       |  // appending "." does nothing
  196|       |  if (!strcmp(fileName, "."))
  197|       |    return path;
  198|       |
  199|       |  // appending ".." goes up one directory
  200|       |  if (!strcmp(fileName, "..")) {
  201|       |    for (i = path->getLength() - 2; i >= 0; --i) {
  202|       |      if (path->getChar(i) == '/' || path->getChar(i) == '\\' ||
  203|       |	  path->getChar(i) == ':')
  204|       |	break;
  205|       |    }
  206|       |    if (i <= 0) {
  207|       |      if (path->getChar(0) == '/' || path->getChar(0) == '\\') {
  208|       |	path->del(1, path->getLength() - 1);
  209|       |      } else if (path->getLength() >= 2 && path->getChar(1) == ':') {
  210|       |	path->del(2, path->getLength() - 2);
  211|       |      } else {
  212|       |	path->clear();
  213|       |	path->append("..");
  214|       |      }
  215|       |    } else {
  216|       |      if (path->getChar(i-1) == ':')
  217|       |	++i;
  218|       |      path->del(i, path->getLength() - i);
  219|       |    }
  220|       |    return path;
  221|       |  }
  222|       |
  223|       |  // otherwise, append "/" and new path component
  224|       |  if (path->getLength() > 0 &&
  225|       |      path->getChar(path->getLength() - 1) != '/' &&
  226|       |      path->getChar(path->getLength() - 1) != '\\')
  227|       |    path->append('/');
  228|       |  path->append(fileName);
  229|       |  return path;
  230|       |
  231|       |#else
  232|       |  //---------- Unix ----------
  233|  8.47k|  int i;
  234|       |
  235|       |  // appending "." does nothing
  236|  8.47k|  if (!strcmp(fileName, "."))
  ------------------
  |  Branch (236:7): [True: 0, False: 8.47k]
  ------------------
  237|      0|    return path;
  238|       |
  239|       |  // appending ".." goes up one directory
  240|  8.47k|  if (!strcmp(fileName, "..")) {
  ------------------
  |  Branch (240:7): [True: 0, False: 8.47k]
  ------------------
  241|      0|    for (i = path->getLength() - 2; i >= 0; --i) {
  ------------------
  |  Branch (241:37): [True: 0, False: 0]
  ------------------
  242|      0|      if (path->getChar(i) == '/')
  ------------------
  |  Branch (242:11): [True: 0, False: 0]
  ------------------
  243|      0|	break;
  244|      0|    }
  245|      0|    if (i <= 0) {
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|      if (path->getChar(0) == '/') {
  ------------------
  |  Branch (246:11): [True: 0, False: 0]
  ------------------
  247|      0|	path->del(1, path->getLength() - 1);
  248|      0|      } else {
  249|      0|	path->clear();
  250|      0|	path->append("..");
  251|      0|      }
  252|      0|    } else {
  253|      0|      path->del(i, path->getLength() - i);
  254|      0|    }
  255|      0|    return path;
  256|      0|  }
  257|       |
  258|       |  // otherwise, append "/" and new path component
  259|  8.47k|  if (path->getLength() > 0 &&
  ------------------
  |  Branch (259:7): [True: 8.47k, False: 0]
  ------------------
  260|  8.47k|      path->getChar(path->getLength() - 1) != '/')
  ------------------
  |  Branch (260:7): [True: 8.47k, False: 0]
  ------------------
  261|  8.47k|    path->append('/');
  262|  8.47k|  path->append(fileName);
  263|  8.47k|  return path;
  264|  8.47k|#endif
  265|  8.47k|}

_Z7gmalloci:
  139|   517k|void *gmalloc(int size) GMEM_EXCEP {
  140|   517k|  void *p;
  141|       |
  142|   517k|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 517k]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|   517k|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 517k]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|   517k|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 517k]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|   517k|  return p;
  152|   517k|}
_Z8greallocPvi:
  155|    467|void *grealloc(void *p, int size) GMEM_EXCEP {
  156|       |#ifdef DEBUG_MEM
  157|       |  GMemHdr *hdr;
  158|       |  void *q;
  159|       |  int oldSize;
  160|       |
  161|       |  if (size < 0) {
  162|       |    gMemError("Invalid memory allocation size");
  163|       |  }
  164|       |  if (size == 0) {
  165|       |    if (p) {
  166|       |      gfree(p);
  167|       |    }
  168|       |    return NULL;
  169|       |  }
  170|       |  if (p) {
  171|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  172|       |    oldSize = (int)hdr->size;
  173|       |    q = gmalloc(size);
  174|       |    memcpy(q, p, size < oldSize ? size : oldSize);
  175|       |    gfree(p);
  176|       |  } else {
  177|       |    q = gmalloc(size);
  178|       |  }
  179|       |  return q;
  180|       |#else
  181|    467|  void *q;
  182|       |
  183|    467|  if (size < 0) {
  ------------------
  |  Branch (183:7): [True: 0, False: 467]
  ------------------
  184|      0|    gMemError("Invalid memory allocation size");
  185|      0|  }
  186|    467|  if (size == 0) {
  ------------------
  |  Branch (186:7): [True: 0, False: 467]
  ------------------
  187|      0|    if (p) {
  ------------------
  |  Branch (187:9): [True: 0, False: 0]
  ------------------
  188|      0|      free(p);
  189|      0|    }
  190|      0|    return NULL;
  191|      0|  }
  192|    467|  if (p) {
  ------------------
  |  Branch (192:7): [True: 452, False: 15]
  ------------------
  193|    452|    q = realloc(p, size);
  194|    452|  } else {
  195|     15|    q = malloc(size);
  196|     15|  }
  197|    467|  if (!q) {
  ------------------
  |  Branch (197:7): [True: 0, False: 467]
  ------------------
  198|      0|    gMemError("Out of memory");
  199|      0|  }
  200|    467|  return q;
  201|    467|#endif
  202|    467|}
_Z8gmallocnii:
  204|  12.5k|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|  12.5k|  int n;
  206|       |
  207|  12.5k|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 12.5k]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|  12.5k|  n = nObjs * objSize;
  211|  12.5k|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 12.5k]
  |  Branch (211:23): [True: 0, False: 12.5k]
  |  Branch (211:36): [True: 0, False: 12.5k]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|  12.5k|  return gmalloc(n);
  215|  12.5k|}
_Z9greallocnPvii:
  291|    467|void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
  292|    467|  int n;
  293|       |
  294|    467|  if (nObjs == 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 467]
  ------------------
  295|      0|    if (p) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      gfree(p);
  297|      0|    }
  298|      0|    return NULL;
  299|      0|  }
  300|    467|  n = nObjs * objSize;
  301|    467|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (301:7): [True: 0, False: 467]
  |  Branch (301:23): [True: 0, False: 467]
  |  Branch (301:36): [True: 0, False: 467]
  ------------------
  302|      0|    gMemError("Bogus memory allocation size");
  303|      0|  }
  304|    467|  return grealloc(p, n);
  305|    467|}
_Z5gfreePv:
  307|   517k|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|   517k|  if (p) {
  ------------------
  |  Branch (348:7): [True: 517k, False: 452]
  ------------------
  349|   517k|    free(p);
  350|   517k|  }
  351|   517k|#endif
  352|   517k|}
_Z10copyStringPKc:
  390|   504k|char *copyString(const char *s) {
  391|   504k|  char *s1;
  392|       |
  393|   504k|  s1 = (char *)gmalloc((int)strlen(s) + 1);
  394|   504k|  strcpy(s1, s);
  395|   504k|  return s1;
  396|   504k|}

_ZN5ArrayC2EP4XRef:
   22|     15|Array::Array(XRef *xrefA) {
   23|     15|  xref = xrefA;
   24|     15|  elems = NULL;
   25|     15|  size = length = 0;
   26|     15|  ref = 1;
   27|     15|}
_ZN5ArrayD2Ev:
   29|     15|Array::~Array() {
   30|     15|  int i;
   31|       |
   32|     30|  for (i = 0; i < length; ++i)
  ------------------
  |  Branch (32:15): [True: 15, False: 15]
  ------------------
   33|     15|    elems[i].free();
   34|     15|  gfree(elems);
   35|     15|}
_ZN5Array3addEP6Object:
   37|     15|void Array::add(Object *elem) {
   38|     15|  if (length == size) {
  ------------------
  |  Branch (38:7): [True: 15, False: 0]
  ------------------
   39|     15|    if (length == 0) {
  ------------------
  |  Branch (39:9): [True: 15, False: 0]
  ------------------
   40|     15|      size = 8;
   41|     15|    } else {
   42|      0|      size *= 2;
   43|      0|    }
   44|     15|    elems = (Object *)greallocn(elems, size, sizeof(Object));
   45|     15|  }
   46|     15|  elems[length] = *elem;
   47|     15|  ++length;
   48|     15|}

_ZN17BuiltinFontWidthsC2EP16BuiltinFontWidthi:
   20|  1.58k|BuiltinFontWidths::BuiltinFontWidths(BuiltinFontWidth *widths, int sizeA) {
   21|  1.58k|  int i, h;
   22|       |
   23|  1.58k|  size = sizeA;
   24|  1.58k|  tab = (BuiltinFontWidth **)gmallocn(size, sizeof(BuiltinFontWidth *));
   25|   473k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (25:15): [True: 471k, False: 1.58k]
  ------------------
   26|   471k|    tab[i] = NULL;
   27|   471k|  }
   28|   473k|  for (i = 0; i < sizeA; ++i) {
  ------------------
  |  Branch (28:15): [True: 471k, False: 1.58k]
  ------------------
   29|   471k|    h = hash(widths[i].name);
   30|   471k|    widths[i].next = tab[h];
   31|   471k|    tab[h] = &widths[i];
   32|   471k|  }
   33|  1.58k|}
_ZN17BuiltinFontWidthsD2Ev:
   35|  1.58k|BuiltinFontWidths::~BuiltinFontWidths() {
   36|  1.58k|  gfree(tab);
   37|  1.58k|}
_ZN17BuiltinFontWidths4hashEPKc:
   54|   471k|int BuiltinFontWidths::hash(const char *name) {
   55|   471k|  const char *p;
   56|   471k|  unsigned int h;
   57|       |
   58|   471k|  h = 0;
   59|  3.50M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (59:18): [True: 3.03M, False: 471k]
  ------------------
   60|  3.03M|    h = 17 * h + (int)(*p & 0xff);
   61|  3.03M|  }
   62|   471k|  return (int)(h % size);
   63|   471k|}

_Z21initBuiltinFontTablesv:
 4262|    113|void initBuiltinFontTables() {
 4263|    113|  builtinFonts[0].widths = new BuiltinFontWidths(courierWidthsTab, 315);
 4264|    113|  builtinFonts[1].widths = new BuiltinFontWidths(courierBoldWidthsTab, 315);
 4265|    113|  builtinFonts[2].widths = new BuiltinFontWidths(courierBoldObliqueWidthsTab, 315);
 4266|    113|  builtinFonts[3].widths = new BuiltinFontWidths(courierObliqueWidthsTab, 315);
 4267|    113|  builtinFonts[4].widths = new BuiltinFontWidths(helveticaWidthsTab, 315);
 4268|    113|  builtinFonts[5].widths = new BuiltinFontWidths(helveticaBoldWidthsTab, 316);
 4269|    113|  builtinFonts[6].widths = new BuiltinFontWidths(helveticaBoldObliqueWidthsTab, 315);
 4270|    113|  builtinFonts[7].widths = new BuiltinFontWidths(helveticaObliqueWidthsTab, 315);
 4271|    113|  builtinFonts[8].widths = new BuiltinFontWidths(symbolWidthsTab, 190);
 4272|    113|  builtinFonts[9].widths = new BuiltinFontWidths(timesBoldWidthsTab, 315);
 4273|    113|  builtinFonts[10].widths = new BuiltinFontWidths(timesBoldItalicWidthsTab, 315);
 4274|    113|  builtinFonts[11].widths = new BuiltinFontWidths(timesItalicWidthsTab, 315);
 4275|    113|  builtinFonts[12].widths = new BuiltinFontWidths(timesRomanWidthsTab, 315);
 4276|    113|  builtinFonts[13].widths = new BuiltinFontWidths(zapfDingbatsWidthsTab, 202);
 4277|    113|}
_Z21freeBuiltinFontTablesv:
 4279|    113|void freeBuiltinFontTables() {
 4280|    113|  int i;
 4281|       |
 4282|  1.69k|  for (i = 0; i < 14; ++i) {
  ------------------
  |  Branch (4282:15): [True: 1.58k, False: 113]
  ------------------
 4283|  1.58k|    delete builtinFonts[i].widths;
 4284|  1.58k|  }
 4285|    113|}

_ZN9CMapCacheC2Ev:
  387|    113|CMapCache::CMapCache() {
  388|    113|  int i;
  389|       |
  390|    565|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    565|#define cMapCacheSize 4
  ------------------
  |  Branch (390:15): [True: 452, False: 113]
  ------------------
  391|    452|    cache[i] = NULL;
  392|    452|  }
  393|    113|}
_ZN9CMapCacheD2Ev:
  395|    113|CMapCache::~CMapCache() {
  396|    113|  int i;
  397|       |
  398|    565|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    565|#define cMapCacheSize 4
  ------------------
  |  Branch (398:15): [True: 452, False: 113]
  ------------------
  399|    452|    if (cache[i]) {
  ------------------
  |  Branch (399:9): [True: 0, False: 452]
  ------------------
  400|      0|      cache[i]->decRefCnt();
  401|      0|    }
  402|    452|  }
  403|    113|}

_ZN22CharCodeToUnicodeCacheC2Ei:
  709|    226|CharCodeToUnicodeCache::CharCodeToUnicodeCache(int sizeA) {
  710|    226|  int i;
  711|       |
  712|    226|  size = sizeA;
  713|    226|  cache = (CharCodeToUnicode **)gmallocn(size, sizeof(CharCodeToUnicode *));
  714|  1.13k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (714:15): [True: 904, False: 226]
  ------------------
  715|    904|    cache[i] = NULL;
  716|    904|  }
  717|    226|}
_ZN22CharCodeToUnicodeCacheD2Ev:
  719|    226|CharCodeToUnicodeCache::~CharCodeToUnicodeCache() {
  720|    226|  int i;
  721|       |
  722|  1.13k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (722:15): [True: 904, False: 226]
  ------------------
  723|    904|    if (cache[i]) {
  ------------------
  |  Branch (723:9): [True: 0, False: 904]
  ------------------
  724|      0|      cache[i]->decRefCnt();
  725|      0|    }
  726|    904|  }
  727|    226|  gfree(cache);
  728|    226|}

_Z5error13ErrorCategorylPKcz:
   46|  2.14k|		 const char *msg, ...) {
   47|  2.14k|  va_list args;
   48|  2.14k|  GString *s, *sanitized;
   49|  2.14k|  char c;
   50|  2.14k|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|  2.14k|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 2.14k, False: 0]
  |  Branch (53:20): [True: 2.14k, False: 0]
  |  Branch (53:36): [True: 2.14k, False: 0]
  ------------------
   54|  2.14k|    return;
   55|  2.14k|  }
   56|      0|  va_start(args, msg);
   57|      0|  s = GString::formatv(msg, args);
   58|      0|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|      0|  sanitized = new GString();
   63|      0|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 0, False: 0]
  ------------------
   64|      0|    c = s->getChar(i);
   65|      0|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 0, False: 0]
  |  Branch (65:22): [True: 0, False: 0]
  ------------------
   66|      0|      sanitized->append(c);
   67|      0|    } else {
   68|      0|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|      0|    }
   70|      0|  }
   71|       |
   72|      0|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 0]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|      0|  } else {
   75|      0|    fflush(stdout);
   76|      0|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 0]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|      0|    } else {
   80|      0|      fprintf(stderr, "%s: %s\n",
   81|      0|	      errorCategoryNames[category], sanitized->getCString());
   82|      0|    }
   83|      0|    fflush(stderr);
   84|      0|  }
   85|       |
   86|      0|  delete s;
   87|      0|  delete sanitized;
   88|      0|}

_ZN11SysFontListC2Ev:
  374|    113|SysFontList::SysFontList() {
  375|    113|  fonts = new GList();
  376|    113|}
_ZN11SysFontListD2Ev:
  378|    113|SysFontList::~SysFontList() {
  379|    113|  deleteGList(fonts, SysFontInfo);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  380|    113|}
_ZN10KeyBindingC2EiiiPKc:
  560|  6.89k|KeyBinding::KeyBinding(int codeA, int modsA, int contextA, const char *cmd0) {
  561|  6.89k|  code = codeA;
  562|  6.89k|  mods = modsA;
  563|  6.89k|  context = contextA;
  564|  6.89k|  cmds = new GList();
  565|  6.89k|  cmds->append(new GString(cmd0));
  566|  6.89k|}
_ZN10KeyBindingD2Ev:
  585|  6.89k|KeyBinding::~KeyBinding() {
  586|  6.89k|  deleteGList(cmds, GString);
  ------------------
  |  |   94|  6.89k|  do {                                              \
  |  |   95|  6.89k|    GList *_list = (list);                          \
  |  |   96|  6.89k|    {                                               \
  |  |   97|  6.89k|      int _i;                                       \
  |  |   98|  13.7k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 6.89k, False: 6.89k]
  |  |  ------------------
  |  |   99|  6.89k|        delete (T*)_list->get(_i);                  \
  |  |  100|  6.89k|      }                                             \
  |  |  101|  6.89k|      delete _list;                                 \
  |  |  102|  6.89k|    }                                               \
  |  |  103|  6.89k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  587|  6.89k|}
_ZN12GlobalParamsC2EPKc:
  607|    113|GlobalParams::GlobalParams(const char *cfgFileName) {
  608|    113|  UnicodeMap *map;
  609|    113|  GString *fileName;
  610|    113|  FILE *f;
  611|    113|  int i;
  612|       |
  613|    113|#if MULTITHREADED
  614|    113|  gInitMutex(&mutex);
  ------------------
  |  |   51|    113|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  615|    113|  gInitMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   51|    113|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  616|    113|  gInitMutex(&cMapCacheMutex);
  ------------------
  |  |   51|    113|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  617|    113|#endif
  618|       |
  619|       |#ifdef _WIN32
  620|       |  tlsWin32ErrorInfo = TlsAlloc();
  621|       |#endif
  622|       |
  623|    113|  initBuiltinFontTables();
  624|       |
  625|       |  // scan the encoding in reverse because we want the lowest-numbered
  626|       |  // index for each char name ('space' is encoded twice)
  627|    113|  macRomanReverseMap = new NameToCharCode();
  628|  29.0k|  for (i = 255; i >= 0; --i) {
  ------------------
  |  Branch (628:17): [True: 28.9k, False: 113]
  ------------------
  629|  28.9k|    if (macRomanEncoding[i]) {
  ------------------
  |  Branch (629:9): [True: 25.1k, False: 3.72k]
  ------------------
  630|  25.1k|      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);
  631|  25.1k|    }
  632|  28.9k|  }
  633|       |
  634|       |#ifdef _WIN32
  635|       |  // baseDir will be set by a call to setBaseDir
  636|       |  baseDir = new GString();
  637|       |#else
  638|    113|  baseDir = appendToPath(getHomeDir(), ".xpdf");
  639|    113|#endif
  640|    113|  configFileVars = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  641|    113|  setDataDirVar();
  642|    113|  nameToUnicode = new NameToCharCode();
  643|    113|  cidToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  644|    113|  unicodeToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  645|    113|  residentUnicodeMaps = new GHash();
  646|    113|  unicodeMaps = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  647|    113|  cMapDirs = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  648|    113|  toUnicodeDirs = new GList();
  649|    113|  unicodeRemapping = new UnicodeRemapping();
  650|    113|  fontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  651|    113|  fontDirs = new GList();
  652|    113|  ccFontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  653|    113|  base14SysFonts = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  654|    113|  sysFonts = new SysFontList();
  655|       |#if HAVE_PAPER_H
  656|       |  const char *paperName;
  657|       |  const struct paper *paperType;
  658|       |  paperinit();
  659|       |  if ((paperName = systempapername())) {
  660|       |    paperType = paperinfo(paperName);
  661|       |    psPaperWidth = (int)paperpswidth(paperType);
  662|       |    psPaperHeight = (int)paperpsheight(paperType);
  663|       |  } else {
  664|       |    error(errConfig, -1, "No paper information available - using defaults");
  665|       |    psPaperWidth = defPaperWidth;
  666|       |    psPaperHeight = defPaperHeight;
  667|       |  }
  668|       |  paperdone();
  669|       |#else
  670|    113|  psPaperWidth = defPaperWidth;
  ------------------
  |  |   46|    113|#define defPaperWidth  612    // American letter (8.5x11")
  ------------------
  671|    113|  psPaperHeight = defPaperHeight;
  ------------------
  |  |   47|    113|#define defPaperHeight 792
  ------------------
  672|    113|#endif
  673|    113|  psImageableLLX = psImageableLLY = 0;
  674|    113|  psImageableURX = psPaperWidth;
  675|    113|  psImageableURY = psPaperHeight;
  676|    113|  psCrop = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  677|    113|  psUseCropBoxAsPage = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  678|    113|  psExpandSmaller = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  679|    113|  psShrinkLarger = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  680|    113|  psCenter = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  681|    113|  psDuplex = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  682|    113|  psLevel = psLevel2;
  683|    113|  psResidentFonts = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  684|    113|  psResidentFonts16 = new GList();
  685|    113|  psResidentFontsCC = new GList();
  686|    113|  psEmbedType1 = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  687|    113|  psEmbedTrueType = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  688|    113|  psEmbedCIDPostScript = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  689|    113|  psEmbedCIDTrueType = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  690|    113|  psFontPassthrough = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  691|    113|  psPreload = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  692|    113|  psOPI = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  693|    113|  psASCIIHex = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  694|    113|  psLZW = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  695|    113|  psUncompressPreloadedImages = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  696|    113|  psMinLineWidth = 0;
  697|    113|  psRasterResolution = 300;
  698|    113|  psRasterMono = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  699|    113|  psRasterSliceSize = 20000000;
  700|    113|  psAlwaysRasterize = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  701|    113|  psNeverRasterize = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  702|    113|  textEncoding = new GString(defaultTextEncoding);
  703|       |#if defined(_WIN32)
  704|       |  textEOL = eolDOS;
  705|       |#else
  706|    113|  textEOL = eolUnix;
  707|    113|#endif
  708|    113|  textPageBreaks = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  709|    113|  textKeepTinyChars = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  710|    113|  initialZoom = new GString("125");
  711|    113|  defaultFitZoom = 0;
  712|    113|  zoomScaleFactor = 1;
  713|    113|  zoomValues = new GList();
  714|    113|  zoomValues->append(new GString("25"));
  715|    113|  zoomValues->append(new GString("50"));
  716|    113|  zoomValues->append(new GString("75"));
  717|    113|  zoomValues->append(new GString("100"));
  718|    113|  zoomValues->append(new GString("110"));
  719|    113|  zoomValues->append(new GString("125"));
  720|    113|  zoomValues->append(new GString("150"));
  721|    113|  zoomValues->append(new GString("175"));
  722|    113|  zoomValues->append(new GString("200"));
  723|    113|  zoomValues->append(new GString("300"));
  724|    113|  zoomValues->append(new GString("400"));
  725|    113|  zoomValues->append(new GString("600"));
  726|    113|  zoomValues->append(new GString("800"));
  727|    113|  initialDisplayMode = new GString("continuous");
  728|    113|  initialToolbarState = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  729|    113|  initialSidebarState = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  730|    113|  initialSidebarWidth = 0;
  731|    113|  initialSelectMode = new GString("linear");
  732|    113|  maxTileWidth = 1500;
  733|    113|  maxTileHeight = 1500;
  734|    113|  tileCacheSize = 10;
  735|    113|  workerThreads = 1;
  736|    113|  enableFreeType = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  737|    113|  disableFreeTypeHinting = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  738|    113|  antialias = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  739|    113|  vectorAntialias = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  740|    113|  imageMaskAntialias = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  741|    113|  antialiasPrinting = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  742|    113|  strokeAdjust = strokeAdjustNormal;
  743|    113|  screenType = screenUnset;
  744|    113|  screenSize = -1;
  745|    113|  screenDotRadius = -1;
  746|    113|  screenGamma = 1.0;
  747|    113|  screenBlackThreshold = 0.0;
  748|    113|  screenWhiteThreshold = 1.0;
  749|    113|  minLineWidth = 0.0;
  750|    113|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  751|    113|  drawAnnotations = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  752|    113|  drawFormFields = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  753|    113|  enableXFA = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  754|    113|  overprintPreview = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  755|    113|  paperColor = new GString("#ffffff");
  756|    113|  matteColor = new GString("#808080");
  757|    113|  fullScreenMatteColor = new GString("#000000");
  758|    113|  selectionColor = new GString("#8080ff");
  759|    113|  reverseVideoInvertImages = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  760|    113|  allowLinksToChangeZoom = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  761|    113|  launchCommand = NULL;
  762|    113|  movieCommand = NULL;
  763|    113|  defaultPrinter = NULL;
  764|    113|  mapNumericCharNames = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  765|    113|  mapUnknownCharNames = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  766|    113|  mapExtTrueTypeFontsViaUnicode = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  767|    113|  useTrueTypeUnicodeMapping = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  768|    113|  ignoreWrongSizeToUnicode = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  769|    113|  droppedFonts = new GHash(gTrue);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  770|    113|  separateRotatedText = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  771|    113|  createDefaultKeyBindings();
  772|    113|  popupMenuCmds = new GList();
  773|    113|  initStateFilePaths();
  774|    113|  saveSessionOnQuit = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  775|    113|  savePageNumbers = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  776|    113|  printCommands = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  777|    113|  printStatusInfo = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  778|    113|  errQuiet = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  779|    113|  debugLogFile = NULL;
  780|       |
  781|    113|  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);
  ------------------
  |  |   71|    113|#define cidToUnicodeCacheSize     4
  ------------------
  782|    113|  unicodeToUnicodeCache =
  783|    113|      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);
  ------------------
  |  |   72|    113|#define unicodeToUnicodeCacheSize 4
  ------------------
  784|    113|  unicodeMapCache = new UnicodeMapCache();
  785|    113|  cMapCache = new CMapCache();
  786|       |
  787|       |  // set up the initial nameToUnicode table
  788|   479k|  for (i = 0; nameToUnicodeTab[i].name; ++i) {
  ------------------
  |  Branch (788:15): [True: 479k, False: 113]
  ------------------
  789|   479k|    nameToUnicode->add(nameToUnicodeTab[i].name, nameToUnicodeTab[i].u);
  790|   479k|  }
  791|       |
  792|       |  // set up the residentUnicodeMaps table
  793|    113|  map = new UnicodeMap("Latin1", gFalse,
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  794|    113|		       latin1UnicodeMapRanges, latin1UnicodeMapLen);
  ------------------
  |  |   71|    113|#define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  795|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  796|    113|  map = new UnicodeMap("ASCII7", gFalse,
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  797|    113|		       ascii7UnicodeMapRanges, ascii7UnicodeMapLen);
  ------------------
  |  |  207|    113|#define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  798|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  799|    113|  map = new UnicodeMap("Symbol", gFalse,
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  800|    113|		       symbolUnicodeMapRanges, symbolUnicodeMapLen);
  ------------------
  |  |  332|    113|#define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  801|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  802|    113|  map = new UnicodeMap("ZapfDingbats", gFalse, zapfDingbatsUnicodeMapRanges,
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  803|    113|		       zapfDingbatsUnicodeMapLen);
  ------------------
  |  |  366|    113|#define zapfDingbatsUnicodeMapLen (sizeof(zapfDingbatsUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  804|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  805|    113|  map = new UnicodeMap("UTF-8", gTrue, &mapUTF8);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  806|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  807|    113|  map = new UnicodeMap("UCS-2", gTrue, &mapUCS2);
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  808|    113|  residentUnicodeMaps->add(map->getEncodingName(), map);
  809|       |
  810|       |  // look for a user config file, then a system-wide config file
  811|    113|  f = NULL;
  812|    113|  fileName = NULL;
  813|    113|  if (cfgFileName && cfgFileName[0]) {
  ------------------
  |  Branch (813:7): [True: 0, False: 113]
  |  Branch (813:22): [True: 0, False: 0]
  ------------------
  814|      0|    fileName = new GString(cfgFileName);
  815|      0|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (815:9): [True: 0, False: 0]
  ------------------
  816|      0|      delete fileName;
  817|      0|    }
  818|      0|  }
  819|    113|  if (!f) {
  ------------------
  |  Branch (819:7): [True: 113, False: 0]
  ------------------
  820|    113|    fileName = appendToPath(getHomeDir(), xpdfUserConfigFile);
  ------------------
  |  |   58|    113|#define xpdfUserConfigFile ".xpdfrc"
  ------------------
  821|    113|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (821:9): [True: 113, False: 0]
  ------------------
  822|    113|      delete fileName;
  823|    113|    }
  824|    113|  }
  825|    113|  if (!f) {
  ------------------
  |  Branch (825:7): [True: 113, False: 0]
  ------------------
  826|       |#ifdef _WIN32
  827|       |    char buf[512];
  828|       |    i = GetModuleFileNameA(NULL, buf, sizeof(buf));
  829|       |    if (i <= 0 || i >= sizeof(buf)) {
  830|       |      // error or path too long for buffer - just use the current dir
  831|       |      buf[0] = '\0';
  832|       |    }
  833|       |    fileName = grabPath(buf);
  834|       |    appendToPath(fileName, xpdfSysConfigFile);
  835|       |#else
  836|    113|    fileName = new GString(xpdfSysConfigFile);
  ------------------
  |  |   69|    113|#define xpdfSysConfigFile "/etc/xpdfrc"
  ------------------
  837|    113|#endif
  838|    113|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (838:9): [True: 113, False: 0]
  ------------------
  839|    113|      delete fileName;
  840|    113|    }
  841|    113|  }
  842|    113|  if (f) {
  ------------------
  |  Branch (842:7): [True: 0, False: 113]
  ------------------
  843|      0|    parseFile(fileName, f);
  844|      0|    delete fileName;
  845|      0|    fclose(f);
  846|      0|  }
  847|    113|}
_ZN12GlobalParams13setDataDirVarEv:
  849|    113|void GlobalParams::setDataDirVar() {
  850|    113|  GString *dir;
  851|       |
  852|       |#if defined(XPDFRC_DATADIR)
  853|       |  dir = new GString(XPDFRC_DATADIR);
  854|       |#elif defined(_WIN32)
  855|       |  wchar_t buf[512];
  856|       |  DWORD n = GetModuleFileNameW(NULL, buf, sizeof(buf) / sizeof(wchar_t));
  857|       |  if (n <= 0 || n >= sizeof(buf)) {
  858|       |    // error or path too long for buffer - just use the current dir
  859|       |    buf[0] = L'\0';
  860|       |  }
  861|       |  GString *path = fileNameToUTF8(buf);
  862|       |  dir = grabPath(path->getCString());
  863|       |  delete path;
  864|       |  appendToPath(dir, "data");
  865|       |#else
  866|       |  //~ may be useful to allow the options of using the install dir
  867|       |  //~   and/or the user's home dir (?)
  868|    113|  dir = new GString("./data");
  869|    113|#endif
  870|       |
  871|    113|  configFileVars->add(new GString("DATADIR"), dir);
  872|    113|}
_ZN12GlobalParams24createDefaultKeyBindingsEv:
  874|    113|void GlobalParams::createDefaultKeyBindings() {
  875|    113|  keyBindings = new GList();
  876|       |
  877|       |  //----- mouse buttons
  878|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  147|    113|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  879|    113|				     xpdfKeyContextAny, "startSelection"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  880|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  147|    113|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  193|    113|#define xpdfKeyModShift           (1 << 0)
  ------------------
  881|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  882|    113|				     "startExtendedSelection"));
  883|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  156|    113|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  884|    113|				     xpdfKeyContextAny, "endSelection"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  885|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  156|    113|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  193|    113|#define xpdfKeyModShift           (1 << 0)
  ------------------
  886|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  887|    113|				     "endSelection"));
  888|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseDoubleClick1,
  ------------------
  |  |  174|    113|#define xpdfKeyCodeMouseDoubleClick1  0x2301
  ------------------
  889|    113|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  890|    113|				     "selectWord"));
  891|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseTripleClick1,
  ------------------
  |  |  183|    113|#define xpdfKeyCodeMouseTripleClick1  0x2401
  ------------------
  892|    113|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  893|    113|				     "selectLine"));
  894|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  165|    113|#define xpdfKeyCodeMouseClick1        0x2201
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  895|    113|				     xpdfKeyContextAny, "followLinkNoSel"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  896|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  166|    113|#define xpdfKeyCodeMouseClick2        0x2202
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  897|    113|				     xpdfKeyContextOverLink,
  ------------------
  |  |  201|    113|#define xpdfKeyContextOverLink    (1 << 4)
  ------------------
  898|    113|				     "followLinkInNewTab"));
  899|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  148|    113|#define xpdfKeyCodeMousePress2        0x2002
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  900|    113|				     xpdfKeyContextAny, "startPan"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  901|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  157|    113|#define xpdfKeyCodeMouseRelease2      0x2102
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  902|    113|				     xpdfKeyContextAny, "endPan"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  903|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  149|    113|#define xpdfKeyCodeMousePress3        0x2003
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  904|    113|				     xpdfKeyContextAny, "postPopupMenu"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  905|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  150|    113|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  906|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  907|    113|				     "scrollUpPrevPage(16)"));
  908|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  151|    113|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  909|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  910|    113|				     "scrollDownNextPage(16)"));
  911|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  152|    113|#define xpdfKeyCodeMousePress6        0x2006
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  912|    113|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  913|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  153|    113|#define xpdfKeyCodeMousePress7        0x2007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  914|    113|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  915|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  150|    113|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  916|    113|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  917|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  151|    113|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  918|    113|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  919|       |
  920|       |  //----- control keys
  921|    113|  keyBindings->append(new KeyBinding('o', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  922|    113|				     xpdfKeyContextAny, "open"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  923|    113|  keyBindings->append(new KeyBinding('r', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  924|    113|				     xpdfKeyContextAny, "reload"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  925|    113|  keyBindings->append(new KeyBinding('f', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  926|    113|				     xpdfKeyContextAny, "find"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  927|    113|  keyBindings->append(new KeyBinding('g', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  928|    113|				     xpdfKeyContextAny, "findNext"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  929|    113|  keyBindings->append(new KeyBinding('c', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  930|    113|				     xpdfKeyContextAny, "copy"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  931|    113|  keyBindings->append(new KeyBinding('p', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  932|    113|				     xpdfKeyContextAny, "print"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  933|    113|  keyBindings->append(new KeyBinding('0', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  934|    113|				     xpdfKeyContextAny, "zoomPercent(125)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  935|    113|  keyBindings->append(new KeyBinding('+', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  936|    113|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  937|    113|  keyBindings->append(new KeyBinding('=', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  938|    113|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  939|    113|  keyBindings->append(new KeyBinding('-', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  940|    113|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  941|    113|  keyBindings->append(new KeyBinding('s', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  942|    113|				     xpdfKeyContextAny, "saveAs"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  943|    113|  keyBindings->append(new KeyBinding('t', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  944|    113|				     xpdfKeyContextAny, "newTab"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  945|    113|  keyBindings->append(new KeyBinding('n', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  946|    113|				     xpdfKeyContextAny, "newWindow"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  947|    113|  keyBindings->append(new KeyBinding('w', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  948|    113|				     xpdfKeyContextAny, "closeTabOrQuit"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  949|    113|  keyBindings->append(new KeyBinding('l', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  950|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  951|    113|				     "toggleFullScreenMode"));
  952|    113|  keyBindings->append(new KeyBinding('q', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  953|    113|				     xpdfKeyContextAny, "quit"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  954|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  130|    113|#define xpdfKeyCodeTab                0x1000
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  955|    113|				     xpdfKeyContextAny, "nextTab"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  956|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab,
  ------------------
  |  |  130|    113|#define xpdfKeyCodeTab                0x1000
  ------------------
  957|    113|				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  193|    113|#define xpdfKeyModShift           (1 << 0)
  ------------------
              				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  958|    113|				     xpdfKeyContextAny, "prevTab"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  959|    113|  keyBindings->append(new KeyBinding('?', xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  960|    113|				     xpdfKeyContextAny, "help"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  961|       |
  962|       |  //----- alt keys
  963|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  141|    113|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  195|    113|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  964|    113|				     xpdfKeyContextAny, "goBackward"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  965|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  142|    113|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  195|    113|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  966|    113|				     xpdfKeyContextAny, "goForward"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  967|       |
  968|       |  //----- home/end keys
  969|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  137|    113|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  970|    113|				     xpdfKeyContextAny, "gotoPage(1)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  971|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  137|    113|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  972|    113|				     xpdfKeyContextAny, "scrollToTopLeft"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  973|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  138|    113|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  974|    113|				     xpdfKeyContextAny, "gotoLastPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  975|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  138|    113|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  976|    113|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  977|    113|				     "scrollToBottomRight"));
  978|       |
  979|       |  //----- pgup/pgdn keys
  980|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  139|    113|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  981|    113|				     xpdfKeyContextAny, "pageUp"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  982|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  140|    113|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  983|    113|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  984|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    113|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  985|    113|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  986|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    113|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  987|    113|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
  988|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    113|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  989|    113|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    113|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  990|    113|				     "prevPageNoScroll"));
  991|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    113|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  992|    113|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    113|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  993|    113|				     "nextPageNoScroll"));
  994|       |
  995|       |  //----- esc key
  996|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  134|    113|#define xpdfKeyCodeEsc                0x1004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
  997|    113|				     xpdfKeyContextFullScreen,
  ------------------
  |  |  197|    113|#define xpdfKeyContextFullScreen  (1 << 0)
  ------------------
  998|    113|				     "windowMode"));
  999|       |
 1000|       |  //----- arrow keys
 1001|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  141|    113|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1002|    113|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1003|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  142|    113|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1004|    113|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1005|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  143|    113|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1006|    113|				     xpdfKeyContextAny, "scrollUp(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1007|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  144|    113|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1008|    113|				     xpdfKeyContextAny, "scrollDown(16)"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1009|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    113|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1010|    113|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1011|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    113|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1012|    113|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1013|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    113|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1014|    113|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    113|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1015|    113|				     "prevPageNoScroll"));
 1016|    113|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    113|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    113|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1017|    113|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    113|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1018|    113|				     "nextPageNoScroll"));
 1019|       |
 1020|       |  //----- letter keys
 1021|    113|  keyBindings->append(new KeyBinding(' ', xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1022|    113|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1023|    113|  keyBindings->append(new KeyBinding('g', xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1024|    113|				     xpdfKeyContextAny, "focusToPageNum"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1025|    113|  keyBindings->append(new KeyBinding('z', xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1026|    113|				     xpdfKeyContextAny, "zoomFitPage"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1027|    113|  keyBindings->append(new KeyBinding('w', xpdfKeyModNone,
  ------------------
  |  |  192|    113|#define xpdfKeyModNone            0
  ------------------
 1028|    113|				     xpdfKeyContextAny, "zoomFitWidth"));
  ------------------
  |  |  196|    113|#define xpdfKeyContextAny         0
  ------------------
 1029|    113|}
_ZN12GlobalParams18initStateFilePathsEv:
 1031|    113|void GlobalParams::initStateFilePaths() {
 1032|       |#ifdef _WIN32
 1033|       |  char path[MAX_PATH];
 1034|       |  if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL,
 1035|       |		       SHGFP_TYPE_CURRENT, path) != S_OK) {
 1036|       |    return;
 1037|       |  }
 1038|       |  GString *dir = appendToPath(new GString(path), "xpdf");
 1039|       |  CreateDirectoryA(dir->getCString(), NULL);
 1040|       |  pagesFile = appendToPath(dir->copy(), "xpdf.pages");
 1041|       |  tabStateFile = appendToPath(dir->copy(), "xpdf.tab-state");
 1042|       |  sessionFile = appendToPath(dir, "xpdf.session");
 1043|       |#else
 1044|    113|  pagesFile = appendToPath(getHomeDir(), ".xpdf.pages");
 1045|    113|  tabStateFile = appendToPath(getHomeDir(), ".xpdf.tab-state");
 1046|    113|  sessionFile = appendToPath(getHomeDir(), ".xpdf.session");
 1047|    113|#endif
 1048|    113|}
_ZN12GlobalParams11parseYesNo2EPcPi:
 2092|    113|GBool GlobalParams::parseYesNo2(char *token, GBool *flag) {
 2093|    113|  if (!strcmp(token, "yes")) {
  ------------------
  |  Branch (2093:7): [True: 113, False: 0]
  ------------------
 2094|    113|    *flag = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
 2095|    113|  } else if (!strcmp(token, "no")) {
  ------------------
  |  Branch (2095:14): [True: 0, False: 0]
  ------------------
 2096|      0|    *flag = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2097|      0|  } else {
 2098|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2099|      0|  }
 2100|    113|  return gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
 2101|    113|}
_ZN12GlobalParamsD2Ev:
 2179|    113|GlobalParams::~GlobalParams() {
 2180|    113|  GHashIter *iter;
 2181|    113|  GString *key;
 2182|    113|  GList *list;
 2183|       |
 2184|    113|  freeBuiltinFontTables();
 2185|       |
 2186|    113|  delete macRomanReverseMap;
 2187|       |
 2188|    113|  delete baseDir;
 2189|    113|  deleteGHash(configFileVars, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    226|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 113, False: 113]
  |  |  ------------------
  |  |   68|    113|        delete (T*)_p;                             \
  |  |   69|    113|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2190|    113|  delete nameToUnicode;
 2191|    113|  deleteGHash(cidToUnicodes, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2192|    113|  deleteGHash(unicodeToUnicodes, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2193|    113|  deleteGHash(residentUnicodeMaps, UnicodeMap);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    791|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 678, False: 113]
  |  |  ------------------
  |  |   68|    678|        delete (T*)_p;                             \
  |  |   69|    678|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2194|    113|  deleteGHash(unicodeMaps, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2195|    113|  deleteGList(toUnicodeDirs, GString);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2196|    113|  delete unicodeRemapping;
 2197|    113|  deleteGHash(fontFiles, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2198|    113|  deleteGList(fontDirs, GString);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2199|    113|  deleteGHash(ccFontFiles, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2200|    113|  deleteGHash(base14SysFonts, Base14FontInfo);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2201|    113|  delete sysFonts;
 2202|    113|  deleteGHash(psResidentFonts, GString);
  ------------------
  |  |   60|    113|  do {                                             \
  |  |   61|    113|    GHash *_hash = (hash);                         \
  |  |   62|    113|    {                                              \
  |  |   63|    113|      GHashIter *_iter;                            \
  |  |   64|    113|      GString *_key;                               \
  |  |   65|    113|      void *_p;                                    \
  |  |   66|    113|      _hash->startIter(&_iter);                    \
  |  |   67|    113|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 113]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    113|      delete _hash;                                \
  |  |   71|    113|    }                                              \
  |  |   72|    113|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2203|    113|  deleteGList(psResidentFonts16, PSFontParam16);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2204|    113|  deleteGList(psResidentFontsCC, PSFontParam16);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2205|    113|  delete textEncoding;
 2206|    113|  delete initialZoom;
 2207|    113|  deleteGList(zoomValues, GString);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|  1.58k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 1.46k, False: 113]
  |  |  ------------------
  |  |   99|  1.46k|        delete (T*)_list->get(_i);                  \
  |  |  100|  1.46k|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2208|    113|  delete initialDisplayMode;
 2209|    113|  delete initialSelectMode;
 2210|    113|  if (paperColor) {
  ------------------
  |  Branch (2210:7): [True: 113, False: 0]
  ------------------
 2211|    113|    delete paperColor;
 2212|    113|  }
 2213|    113|  if (matteColor) {
  ------------------
  |  Branch (2213:7): [True: 113, False: 0]
  ------------------
 2214|    113|    delete matteColor;
 2215|    113|  }
 2216|    113|  if (fullScreenMatteColor) {
  ------------------
  |  Branch (2216:7): [True: 113, False: 0]
  ------------------
 2217|    113|    delete fullScreenMatteColor;
 2218|    113|  }
 2219|    113|  if (selectionColor) {
  ------------------
  |  Branch (2219:7): [True: 113, False: 0]
  ------------------
 2220|    113|    delete selectionColor;
 2221|    113|  }
 2222|    113|  if (launchCommand) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 113]
  ------------------
 2223|      0|    delete launchCommand;
 2224|      0|  }
 2225|    113|  if (movieCommand) {
  ------------------
  |  Branch (2225:7): [True: 0, False: 113]
  ------------------
 2226|      0|    delete movieCommand;
 2227|      0|  }
 2228|    113|  if (defaultPrinter) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 113]
  ------------------
 2229|      0|    delete defaultPrinter;
 2230|      0|  }
 2231|    113|  delete droppedFonts;
 2232|    113|  deleteGList(keyBindings, KeyBinding);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|  7.00k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 6.89k, False: 113]
  |  |  ------------------
  |  |   99|  6.89k|        delete (T*)_list->get(_i);                  \
  |  |  100|  6.89k|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2233|    113|  deleteGList(popupMenuCmds, PopupMenuCmd);
  ------------------
  |  |   94|    113|  do {                                              \
  |  |   95|    113|    GList *_list = (list);                          \
  |  |   96|    113|    {                                               \
  |  |   97|    113|      int _i;                                       \
  |  |   98|    113|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 113]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    113|      delete _list;                                 \
  |  |  102|    113|    }                                               \
  |  |  103|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2234|    113|  delete pagesFile;
 2235|    113|  delete tabStateFile;
 2236|    113|  delete sessionFile;
 2237|    113|  delete debugLogFile;
 2238|       |
 2239|    113|  cMapDirs->startIter(&iter);
 2240|    113|  while (cMapDirs->getNext(&iter, &key, (void **)&list)) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 113]
  ------------------
 2241|      0|    deleteGList(list, GString);
  ------------------
  |  |   94|      0|  do {                                              \
  |  |   95|      0|    GList *_list = (list);                          \
  |  |   96|      0|    {                                               \
  |  |   97|      0|      int _i;                                       \
  |  |   98|      0|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 0]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|      0|      delete _list;                                 \
  |  |  102|      0|    }                                               \
  |  |  103|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2242|      0|  }
 2243|    113|  delete cMapDirs;
 2244|       |
 2245|    113|  delete cidToUnicodeCache;
 2246|    113|  delete unicodeToUnicodeCache;
 2247|    113|  delete unicodeMapCache;
 2248|    113|  delete cMapCache;
 2249|       |
 2250|    113|#if MULTITHREADED
 2251|    113|  gDestroyMutex(&mutex);
  ------------------
  |  |   52|    113|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2252|    113|  gDestroyMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   52|    113|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2253|    113|  gDestroyMutex(&cMapCacheMutex);
  ------------------
  |  |   52|    113|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2254|    113|#endif
 2255|    113|}
_ZN12GlobalParams14setupBaseFontsEPKc:
 2347|    113|void GlobalParams::setupBaseFonts(const char *dir) {
 2348|    113|  GString *fontName;
 2349|    113|  GString *fileName;
 2350|    113|  int fontNum;
 2351|    113|  const char *s;
 2352|    113|  Base14FontInfo *base14;
 2353|       |#ifdef _WIN32
 2354|       |  char winFontDir[MAX_PATH];
 2355|       |#endif
 2356|       |#ifdef __APPLE__
 2357|       |  static const char *macFontExts[3] = { "dfont", "ttc", "ttf" };
 2358|       |  GList *dfontFontNames;
 2359|       |  GBool found;
 2360|       |  int k;
 2361|       |#endif
 2362|    113|  FILE *f;
 2363|    113|  int i, j;
 2364|       |
 2365|       |#ifdef _WIN32
 2366|       |  getWinFontDir(winFontDir);
 2367|       |#endif
 2368|       |#ifdef __APPLE__
 2369|       |  dfontFontNames = NULL;
 2370|       |#endif
 2371|  1.69k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2371:15): [True: 1.58k, False: 113]
  ------------------
 2372|  1.58k|    if (fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 1.58k]
  ------------------
 2373|      0|      continue;
 2374|      0|    }
 2375|  1.58k|    fontName = new GString(displayFontTab[i].name);
 2376|  1.58k|    fileName = NULL;
 2377|  1.58k|    fontNum = 0;
 2378|  1.58k|    if (dir) {
  ------------------
  |  Branch (2378:9): [True: 0, False: 1.58k]
  ------------------
 2379|      0|      fileName = appendToPath(new GString(dir), displayFontTab[i].t1FileName);
 2380|      0|      if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2380:11): [True: 0, False: 0]
  ------------------
 2381|      0|	fclose(f);
 2382|      0|      } else {
 2383|      0|	delete fileName;
 2384|      0|	fileName = NULL;
 2385|      0|      }
 2386|      0|    }
 2387|       |#ifdef _WIN32
 2388|       |    if (!fileName && winFontDir[0] && displayFontTab[i].ttFileName) {
 2389|       |      fileName = appendToPath(new GString(winFontDir),
 2390|       |			      displayFontTab[i].ttFileName);
 2391|       |      if ((f = fopen(fileName->getCString(), "rb"))) {
 2392|       |	fclose(f);
 2393|       |      } else {
 2394|       |	delete fileName;
 2395|       |	fileName = NULL;
 2396|       |      }
 2397|       |    }
 2398|       |#endif
 2399|       |#ifdef __APPLE__
 2400|       |    // Check for Mac OS X system fonts.
 2401|       |    s = displayFontTab[i].macFileName;
 2402|       |    if (dfontFontNames && i > 0 &&
 2403|       |	(!s || strcmp(s, displayFontTab[i-1].macFileName))) {
 2404|       |      deleteGList(dfontFontNames, GString);
 2405|       |      dfontFontNames = NULL;
 2406|       |    }
 2407|       |    if (!fileName && s) {
 2408|       |      for (j = 0; j < 3; ++j) {
 2409|       |	fileName = GString::format("{0:s}/{1:s}.{2:s}",
 2410|       |				   macSystemFontPath, s, macFontExts[j]);
 2411|       |	if (!(f = fopen(fileName->getCString(), "rb"))) {
 2412|       |	  delete fileName;
 2413|       |	  fileName = NULL;
 2414|       |	} else {
 2415|       |	  fclose(f);
 2416|       |	  found = gFalse;
 2417|       |	  // for .dfont or .ttc, we need to scan the font list
 2418|       |	  if (j < 2) {
 2419|       |	    if (!dfontFontNames) {
 2420|       |	      dfontFontNames =
 2421|       |	          FoFiIdentifier::getFontList(fileName->getCString());
 2422|       |	    }
 2423|       |	    if (dfontFontNames) {
 2424|       |	      for (k = 0; k < dfontFontNames->getLength(); ++k) {
 2425|       |		if (macFontNameMatches((GString *)dfontFontNames->get(k),
 2426|       |				       displayFontTab[i].macFontName)) {
 2427|       |		  fontNum = k;
 2428|       |		  found = gTrue;
 2429|       |		  break;
 2430|       |		}
 2431|       |	      }
 2432|       |	    }
 2433|       |	  // for .ttf, we just use the font
 2434|       |	  } else {
 2435|       |	    found = gTrue;
 2436|       |	  }
 2437|       |	  if (!found) {
 2438|       |	    delete fileName;
 2439|       |	    fileName = NULL;
 2440|       |	  }
 2441|       |	  break;
 2442|       |	}
 2443|       |      }
 2444|       |    }
 2445|       |#endif // __APPLE__
 2446|       |    // On Linux, this checks the "standard" ghostscript font
 2447|       |    // directories.  On Windows, it checks the "standard" system font
 2448|       |    // directories (because SHGetSpecialFolderPath(CSIDL_FONTS)
 2449|       |    // doesn't work on Win 2k Server or Win2003 Server, or with older
 2450|       |    // versions of shell32.dll).
 2451|       |#ifdef _WIN32
 2452|       |    s = displayFontTab[i].ttFileName;
 2453|       |#else
 2454|  1.58k|    s = displayFontTab[i].t1FileName;
 2455|  1.58k|#endif
 2456|  1.58k|    if (!fileName && s) {
  ------------------
  |  Branch (2456:9): [True: 1.58k, False: 0]
  |  Branch (2456:22): [True: 1.58k, False: 0]
  ------------------
 2457|  9.49k|      for (j = 0; !fileName && displayFontDirs[j]; ++j) {
  ------------------
  |  Branch (2457:19): [True: 9.49k, False: 0]
  |  Branch (2457:32): [True: 7.91k, False: 1.58k]
  ------------------
 2458|  7.91k|	fileName = appendToPath(new GString(displayFontDirs[j]), s);
 2459|  7.91k|	if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2459:6): [True: 0, False: 7.91k]
  ------------------
 2460|      0|	  fclose(f);
 2461|  7.91k|	} else {
 2462|  7.91k|	  delete fileName;
 2463|  7.91k|	  fileName = NULL;
 2464|  7.91k|	}
 2465|  7.91k|      }
 2466|  1.58k|    }
 2467|  1.58k|    if (!fileName) {
  ------------------
  |  Branch (2467:9): [True: 1.58k, False: 0]
  ------------------
 2468|  1.58k|      delete fontName;
 2469|  1.58k|      continue;
 2470|  1.58k|    }
 2471|      0|    base14SysFonts->add(fontName, new Base14FontInfo(fileName, fontNum, 0));
 2472|      0|  }
 2473|       |#ifdef __APPLE__
 2474|       |  if (dfontFontNames) {
 2475|       |    deleteGList(dfontFontNames, GString);
 2476|       |  }
 2477|       |#endif
 2478|  1.69k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2478:15): [True: 1.58k, False: 113]
  ------------------
 2479|  1.58k|    if (!base14SysFonts->lookup(displayFontTab[i].name) &&
  ------------------
  |  Branch (2479:9): [True: 1.58k, False: 0]
  ------------------
 2480|  1.58k|	!fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2480:2): [True: 1.58k, False: 0]
  ------------------
 2481|  1.58k|      if (displayFontTab[i].obliqueFont &&
  ------------------
  |  Branch (2481:11): [True: 452, False: 1.13k]
  ------------------
 2482|  1.58k|	  ((base14 = (Base14FontInfo *)base14SysFonts
  ------------------
  |  Branch (2482:4): [True: 0, False: 452]
  ------------------
 2483|    452|	                 ->lookup(displayFontTab[i].obliqueFont)))) {
 2484|      0|	base14SysFonts->add(
 2485|      0|	        new GString(displayFontTab[i].name),
 2486|      0|		new Base14FontInfo(base14->fileName->copy(),
 2487|      0|				   base14->fontNum,
 2488|      0|				   displayFontTab[i].obliqueFactor));
 2489|  1.58k|      } else {
 2490|  1.58k|	error(errConfig, -1, "No display font for '{0:s}'",
 2491|  1.58k|	      displayFontTab[i].name);
 2492|  1.58k|      }
 2493|  1.58k|    }
 2494|  1.58k|  }
 2495|       |#ifdef _WIN32
 2496|       |  if (winFontDir[0]) {
 2497|       |    sysFonts->scanWindowsFonts(winFontDir);
 2498|       |  }
 2499|       |#endif
 2500|       |#if HAVE_FONTCONFIG
 2501|       |  sysFonts->scanFontconfigFonts();
 2502|       |#endif
 2503|    113|}
_ZN12GlobalParams11getErrQuietEv:
 3562|  2.14k|GBool GlobalParams::getErrQuiet() {
 3563|       |  // no locking -- this function may get called from inside a locked
 3564|       |  // section
 3565|  2.14k|  return errQuiet;
 3566|  2.14k|}
_ZN12GlobalParams17setEnableFreeTypeEPc:
 3888|    113|GBool GlobalParams::setEnableFreeType(char *s) {
 3889|    113|  GBool ok;
 3890|       |
 3891|    113|  lockGlobalParams;
  ------------------
  |  |   50|    113|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    113|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3892|    113|  ok = parseYesNo2(s, &enableFreeType);
 3893|    113|  unlockGlobalParams;
  ------------------
  |  |   53|    113|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    113|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3894|    113|  return ok;
 3895|    113|}
_ZN12GlobalParams11setErrQuietEi:
 4010|    226|void GlobalParams::setErrQuiet(GBool errQuietA) {
 4011|    226|  lockGlobalParams;
  ------------------
  |  |   50|    226|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    226|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 4012|    226|  errQuiet = errQuietA;
 4013|    226|  unlockGlobalParams;
  ------------------
  |  |   53|    226|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    226|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 4014|    226|}

_ZN5LexerC2EP4XRefP6Stream:
   46|     15|Lexer::Lexer(XRef *xref, Stream *str) {
   47|     15|  Object obj;
   48|       |
   49|     15|  curStr.initStream(str);
   50|     15|  streams = new Array(xref);
   51|     15|  streams->add(curStr.copy(&obj));
   52|     15|  strPtr = 0;
   53|     15|  freeArray = gTrue;
  ------------------
  |  |   17|     15|#define gTrue 1
  ------------------
   54|     15|  curStr.streamReset();
   55|     15|}
_ZN5LexerD2Ev:
   75|     15|Lexer::~Lexer() {
   76|     15|  if (!curStr.isNone()) {
  ------------------
  |  Branch (76:7): [True: 15, False: 0]
  ------------------
   77|     15|    curStr.streamClose();
   78|     15|    curStr.free();
   79|     15|  }
   80|     15|  if (freeArray) {
  ------------------
  |  Branch (80:7): [True: 15, False: 0]
  ------------------
   81|     15|    delete streams;
   82|     15|  }
   83|     15|}
_ZN5Lexer7getCharEv:
   85|  1.16k|int Lexer::getChar() {
   86|  1.16k|  int c;
   87|       |
   88|  1.16k|  c = EOF;
   89|  1.16k|  while (!curStr.isNone() && (c = curStr.streamGetChar()) == EOF) {
  ------------------
  |  Branch (89:10): [True: 1.16k, False: 0]
  |  Branch (89:30): [True: 0, False: 1.16k]
  ------------------
   90|      0|    curStr.streamClose();
   91|      0|    curStr.free();
   92|      0|    ++strPtr;
   93|      0|    if (strPtr < streams->getLength()) {
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      streams->get(strPtr, &curStr);
   95|      0|      curStr.streamReset();
   96|      0|    }
   97|      0|  }
   98|  1.16k|  return c;
   99|  1.16k|}
_ZN5Lexer8lookCharEv:
  101|    440|int Lexer::lookChar() {
  102|    440|  if (curStr.isNone()) {
  ------------------
  |  Branch (102:7): [True: 0, False: 440]
  ------------------
  103|      0|    return EOF;
  104|      0|  }
  105|    440|  return curStr.streamLookChar();
  106|    440|}
_ZN5Lexer6getObjEP6Object:
  108|     45|Object *Lexer::getObj(Object *obj) {
  109|     45|  char *p;
  110|     45|  int c, c2;
  111|     45|  GBool comment, neg, doubleMinus, done, invalid;
  112|     45|  int numParen, nErrors;
  113|     45|  int xi;
  114|     45|  double xf, scale;
  115|     45|  GString *s;
  116|     45|  int n, m;
  117|       |
  118|       |  // skip whitespace and comments
  119|     45|  comment = gFalse;
  ------------------
  |  |   18|     45|#define gFalse 0
  ------------------
  120|    769|  while (1) {
  ------------------
  |  Branch (120:10): [Folded - Ignored]
  ------------------
  121|    769|    if ((c = getChar()) == EOF) {
  ------------------
  |  Branch (121:9): [True: 0, False: 769]
  ------------------
  122|      0|      return obj->initEOF();
  123|      0|    }
  124|    769|    if (comment) {
  ------------------
  |  Branch (124:9): [True: 32, False: 737]
  ------------------
  125|     32|      if (c == '\r' || c == '\n')
  ------------------
  |  Branch (125:11): [True: 0, False: 32]
  |  Branch (125:24): [True: 1, False: 31]
  ------------------
  126|      1|	comment = gFalse;
  ------------------
  |  |   18|      1|#define gFalse 0
  ------------------
  127|    737|    } else if (c == '%') {
  ------------------
  |  Branch (127:16): [True: 1, False: 736]
  ------------------
  128|      1|      comment = gTrue;
  ------------------
  |  |   17|      1|#define gTrue 1
  ------------------
  129|    736|    } else if (specialChars[c] != 1) {
  ------------------
  |  Branch (129:16): [True: 45, False: 691]
  ------------------
  130|     45|      break;
  131|     45|    }
  132|    769|  }
  133|       |
  134|       |  // start reading token
  135|     45|  switch (c) {
  136|       |
  137|       |  // number
  138|      1|  case '0': case '1': case '2': case '3': case '4':
  ------------------
  |  Branch (138:3): [True: 0, False: 45]
  |  Branch (138:13): [True: 0, False: 45]
  |  Branch (138:23): [True: 0, False: 45]
  |  Branch (138:33): [True: 0, False: 45]
  |  Branch (138:43): [True: 1, False: 44]
  ------------------
  139|      6|  case '5': case '6': case '7': case '8': case '9':
  ------------------
  |  Branch (139:3): [True: 0, False: 45]
  |  Branch (139:13): [True: 1, False: 44]
  |  Branch (139:23): [True: 1, False: 44]
  |  Branch (139:33): [True: 3, False: 42]
  |  Branch (139:43): [True: 0, False: 45]
  ------------------
  140|      6|  case '+': case '-': case '.':
  ------------------
  |  Branch (140:3): [True: 0, False: 45]
  |  Branch (140:13): [True: 0, False: 45]
  |  Branch (140:23): [True: 0, False: 45]
  ------------------
  141|       |    // Adobe's number lexer has some "interesting" behavior:
  142|       |    // "--123" is interpreted as 0
  143|       |    // "--123.4" is interpreted as -123.4 [I've seen this in the wild]
  144|       |    // "50-100" is interpreted as 50 [I've seen this in the wild]
  145|       |    // "50--100" is interpreted as 50
  146|       |    // "50-100.0" is an error -- but older versions of Acrobat may
  147|       |    //   have interpreted it as 50100.0 (?)
  148|       |    // "50--100.0" is an error -- but older versions of Acrobat may
  149|       |    //   have interpreted it as 50100.0 (?)
  150|       |    // "50.0-100" is interpreted as 50.0 (or maybe 50.0100?)
  151|       |    // "50.0--100" is interpreted as 50.0 (or maybe 50.0100?)
  152|       |    // "-50-100" is interpreted as -50
  153|       |    // "-" is interpreted as 0
  154|       |    // "-." is interpreted as 0.0
  155|      6|    neg = gFalse;
  ------------------
  |  |   18|      6|#define gFalse 0
  ------------------
  156|      6|    doubleMinus = gFalse;
  ------------------
  |  |   18|      6|#define gFalse 0
  ------------------
  157|      6|    xf = xi = 0;
  158|      6|    if (c == '+') {
  ------------------
  |  Branch (158:9): [True: 0, False: 6]
  ------------------
  159|       |      // just ignore it
  160|      6|    } else if (c == '-') {
  ------------------
  |  Branch (160:16): [True: 0, False: 6]
  ------------------
  161|      0|      neg = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  162|      0|      if (lookChar() == '-') {
  ------------------
  |  Branch (162:11): [True: 0, False: 0]
  ------------------
  163|      0|	doubleMinus = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  164|      0|	do {
  165|      0|	  getChar();
  166|      0|	} while (lookChar() == '-');
  ------------------
  |  Branch (166:11): [True: 0, False: 0]
  ------------------
  167|      0|      }
  168|      6|    } else if (c == '.') {
  ------------------
  |  Branch (168:16): [True: 0, False: 6]
  ------------------
  169|      0|      goto doReal;
  170|      6|    } else {
  171|      6|      xf = xi = c - '0';
  172|      6|    }
  173|      6|    while (1) {
  ------------------
  |  Branch (173:12): [Folded - Ignored]
  ------------------
  174|      6|      c = lookChar();
  175|      6|      if (isdigit(c)) {
  ------------------
  |  Branch (175:11): [True: 0, False: 6]
  ------------------
  176|      0|	getChar();
  177|      0|	xi = xi * 10 + (c - '0');
  178|      0|	if (xf < 1e20) {
  ------------------
  |  Branch (178:6): [True: 0, False: 0]
  ------------------
  179|      0|	  xf = xf * 10 + (c - '0');
  180|      0|	}
  181|      6|      } else if (c == '.') {
  ------------------
  |  Branch (181:18): [True: 0, False: 6]
  ------------------
  182|      0|	getChar();
  183|      0|	goto doReal;
  184|      6|      } else {
  185|      6|	break;
  186|      6|      }
  187|      6|    }
  188|      6|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (188:12): [True: 0, False: 6]
  |  Branch (188:39): [True: 0, False: 6]
  ------------------
  189|      0|      getChar();
  190|      0|    }
  191|      6|    if (neg) {
  ------------------
  |  Branch (191:9): [True: 0, False: 6]
  ------------------
  192|      0|      xi = -xi;
  193|      0|    }
  194|      6|    if (doubleMinus) {
  ------------------
  |  Branch (194:9): [True: 0, False: 6]
  ------------------
  195|      0|      xi = 0;
  196|      0|    }
  197|      6|    obj->initInt(xi);
  198|      6|    break;
  199|      0|  doReal:
  200|      0|    scale = 0.1;
  201|      0|    while (1) {
  ------------------
  |  Branch (201:12): [Folded - Ignored]
  ------------------
  202|      0|      c = lookChar();
  203|      0|      if (c == '-') {
  ------------------
  |  Branch (203:11): [True: 0, False: 0]
  ------------------
  204|      0|	error(errSyntaxWarning, getPos(), "Badly formatted number");
  205|      0|	getChar();
  206|      0|	continue;
  207|      0|      }
  208|      0|      if (!isdigit(c)) {
  ------------------
  |  Branch (208:11): [True: 0, False: 0]
  ------------------
  209|      0|	break;
  210|      0|      }
  211|      0|      getChar();
  212|      0|      xf = xf + scale * (c - '0');
  213|      0|      scale *= 0.1;
  214|      0|    }
  215|      0|    while ((c = lookChar()) == '-' || isdigit(c)) {
  ------------------
  |  Branch (215:12): [True: 0, False: 0]
  |  Branch (215:39): [True: 0, False: 0]
  ------------------
  216|      0|      getChar();
  217|      0|    }
  218|      0|    if (neg) {
  ------------------
  |  Branch (218:9): [True: 0, False: 0]
  ------------------
  219|      0|      xf = -xf;
  220|      0|    }
  221|      0|    obj->initReal(xf);
  222|      0|    break;
  223|       |
  224|       |  // string
  225|      0|  case '(':
  ------------------
  |  Branch (225:3): [True: 0, False: 45]
  ------------------
  226|      0|    p = tokBuf;
  227|      0|    n = 0;
  228|      0|    numParen = 1;
  229|      0|    done = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  230|      0|    s = NULL;
  231|      0|    do {
  232|      0|      c2 = EOF;
  233|      0|      switch (c = getChar()) {
  234|       |
  235|      0|      case EOF:
  ------------------
  |  Branch (235:7): [True: 0, False: 0]
  ------------------
  236|      0|	error(errSyntaxError, getPos(), "Unterminated string");
  237|      0|	done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  238|      0|	break;
  239|       |
  240|      0|      case '(':
  ------------------
  |  Branch (240:7): [True: 0, False: 0]
  ------------------
  241|      0|	++numParen;
  242|      0|	c2 = c;
  243|      0|	break;
  244|       |
  245|      0|      case ')':
  ------------------
  |  Branch (245:7): [True: 0, False: 0]
  ------------------
  246|      0|	if (--numParen == 0) {
  ------------------
  |  Branch (246:6): [True: 0, False: 0]
  ------------------
  247|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  248|      0|	} else {
  249|      0|	  c2 = c;
  250|      0|	}
  251|      0|	break;
  252|       |
  253|      0|      case '\r':
  ------------------
  |  Branch (253:7): [True: 0, False: 0]
  ------------------
  254|       |	// The PDF spec says that any literal end-of-line sequence
  255|       |	// (LF, CR, CR+LF) is translated to a single LF char.
  256|      0|	c = lookChar();
  257|      0|	if (c == '\n') {
  ------------------
  |  Branch (257:6): [True: 0, False: 0]
  ------------------
  258|      0|	  getChar();
  259|      0|	}
  260|      0|	c2 = '\n';
  261|      0|	break;
  262|       |
  263|      0|      case '\\':
  ------------------
  |  Branch (263:7): [True: 0, False: 0]
  ------------------
  264|      0|	switch (c = getChar()) {
  265|      0|	case 'n':
  ------------------
  |  Branch (265:2): [True: 0, False: 0]
  ------------------
  266|      0|	  c2 = '\n';
  267|      0|	  break;
  268|      0|	case 'r':
  ------------------
  |  Branch (268:2): [True: 0, False: 0]
  ------------------
  269|      0|	  c2 = '\r';
  270|      0|	  break;
  271|      0|	case 't':
  ------------------
  |  Branch (271:2): [True: 0, False: 0]
  ------------------
  272|      0|	  c2 = '\t';
  273|      0|	  break;
  274|      0|	case 'b':
  ------------------
  |  Branch (274:2): [True: 0, False: 0]
  ------------------
  275|      0|	  c2 = '\b';
  276|      0|	  break;
  277|      0|	case 'f':
  ------------------
  |  Branch (277:2): [True: 0, False: 0]
  ------------------
  278|      0|	  c2 = '\f';
  279|      0|	  break;
  280|      0|	case '\\':
  ------------------
  |  Branch (280:2): [True: 0, False: 0]
  ------------------
  281|      0|	case '(':
  ------------------
  |  Branch (281:2): [True: 0, False: 0]
  ------------------
  282|      0|	case ')':
  ------------------
  |  Branch (282:2): [True: 0, False: 0]
  ------------------
  283|      0|	  c2 = c;
  284|      0|	  break;
  285|      0|	case '0': case '1': case '2': case '3':
  ------------------
  |  Branch (285:2): [True: 0, False: 0]
  |  Branch (285:12): [True: 0, False: 0]
  |  Branch (285:22): [True: 0, False: 0]
  |  Branch (285:32): [True: 0, False: 0]
  ------------------
  286|      0|	case '4': case '5': case '6': case '7':
  ------------------
  |  Branch (286:2): [True: 0, False: 0]
  |  Branch (286:12): [True: 0, False: 0]
  |  Branch (286:22): [True: 0, False: 0]
  |  Branch (286:32): [True: 0, False: 0]
  ------------------
  287|      0|	  c2 = c - '0';
  288|      0|	  c = lookChar();
  289|      0|	  if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (289:8): [True: 0, False: 0]
  |  Branch (289:20): [True: 0, False: 0]
  ------------------
  290|      0|	    getChar();
  291|      0|	    c2 = (c2 << 3) + (c - '0');
  292|      0|	    c = lookChar();
  293|      0|	    if (c >= '0' && c <= '7') {
  ------------------
  |  Branch (293:10): [True: 0, False: 0]
  |  Branch (293:22): [True: 0, False: 0]
  ------------------
  294|      0|	      getChar();
  295|      0|	      c2 = (c2 << 3) + (c - '0');
  296|      0|	    }
  297|      0|	  }
  298|      0|	  break;
  299|      0|	case '\r':
  ------------------
  |  Branch (299:2): [True: 0, False: 0]
  ------------------
  300|      0|	  c = lookChar();
  301|      0|	  if (c == '\n') {
  ------------------
  |  Branch (301:8): [True: 0, False: 0]
  ------------------
  302|      0|	    getChar();
  303|      0|	  }
  304|      0|	  break;
  305|      0|	case '\n':
  ------------------
  |  Branch (305:2): [True: 0, False: 0]
  ------------------
  306|      0|	  break;
  307|      0|	case EOF:
  ------------------
  |  Branch (307:2): [True: 0, False: 0]
  ------------------
  308|      0|	  error(errSyntaxError, getPos(), "Unterminated string");
  309|      0|	  done = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  310|      0|	  break;
  311|      0|	default:
  ------------------
  |  Branch (311:2): [True: 0, False: 0]
  ------------------
  312|      0|	  c2 = c;
  313|      0|	  break;
  314|      0|	}
  315|      0|	break;
  316|       |
  317|      0|      default:
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|	c2 = c;
  319|      0|	break;
  320|      0|      }
  321|       |
  322|      0|      if (c2 != EOF) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  ------------------
  323|      0|	if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (323:6): [True: 0, False: 0]
  ------------------
  324|      0|	  if (!s)
  ------------------
  |  Branch (324:8): [True: 0, False: 0]
  ------------------
  325|      0|	    s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  326|      0|	  else
  327|      0|	    s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  328|      0|	  p = tokBuf;
  329|      0|	  n = 0;
  330|      0|	}
  331|      0|	*p++ = (char)c2;
  332|      0|	++n;
  333|      0|      }
  334|      0|    } while (!done);
  ------------------
  |  Branch (334:14): [True: 0, False: 0]
  ------------------
  335|      0|    if (!s)
  ------------------
  |  Branch (335:9): [True: 0, False: 0]
  ------------------
  336|      0|      s = new GString(tokBuf, n);
  337|      0|    else
  338|      0|      s->append(tokBuf, n);
  339|      0|    obj->initString(s);
  340|      0|    break;
  341|       |
  342|       |  // name
  343|      0|  case '/':
  ------------------
  |  Branch (343:3): [True: 0, False: 45]
  ------------------
  344|      0|    p = tokBuf;
  345|      0|    n = 0;
  346|      0|    s = NULL;
  347|      0|    invalid = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  348|      0|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (348:12): [True: 0, False: 0]
  |  Branch (348:39): [True: 0, False: 0]
  ------------------
  349|      0|      getChar();
  350|      0|      if (c == '#') {
  ------------------
  |  Branch (350:11): [True: 0, False: 0]
  ------------------
  351|      0|	c2 = lookChar();
  352|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (352:6): [True: 0, False: 0]
  |  Branch (352:19): [True: 0, False: 0]
  ------------------
  353|      0|	  c = c2 - '0';
  354|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (354:13): [True: 0, False: 0]
  |  Branch (354:26): [True: 0, False: 0]
  ------------------
  355|      0|	  c = c2 - 'A' + 10;
  356|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (356:13): [True: 0, False: 0]
  |  Branch (356:26): [True: 0, False: 0]
  ------------------
  357|      0|	  c = c2 - 'a' + 10;
  358|      0|	} else {
  359|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  360|      0|	  goto notEscChar;
  361|      0|	}
  362|      0|	getChar();
  363|      0|	c2 = lookChar();
  364|      0|	if (c2 >= '0' && c2 <= '9') {
  ------------------
  |  Branch (364:6): [True: 0, False: 0]
  |  Branch (364:19): [True: 0, False: 0]
  ------------------
  365|      0|	  c = (c << 4) + (c2 - '0');
  366|      0|	} else if (c2 >= 'A' && c2 <= 'F') {
  ------------------
  |  Branch (366:13): [True: 0, False: 0]
  |  Branch (366:26): [True: 0, False: 0]
  ------------------
  367|      0|	  c = (c << 4) + (c2 - 'A' + 10);
  368|      0|	} else if (c2 >= 'a' && c2 <= 'f') {
  ------------------
  |  Branch (368:13): [True: 0, False: 0]
  |  Branch (368:26): [True: 0, False: 0]
  ------------------
  369|      0|	  c = (c << 4) + (c2 - 'a' + 10);
  370|      0|	} else {
  371|      0|	  error(errSyntaxError, getPos(), "Invalid hex escape in name");
  372|      0|	  goto notEscChar;
  373|      0|	}
  374|      0|	getChar();
  375|      0|	if (c == 0) {
  ------------------
  |  Branch (375:6): [True: 0, False: 0]
  ------------------
  376|      0|	  invalid = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  377|      0|	}
  378|      0|      }
  379|      0|     notEscChar:
  380|       |      // the PDF spec claims that names are limited to 127 chars, but
  381|       |      // Distiller 8 will produce longer names, and Acrobat 8 will
  382|       |      // accept longer names
  383|      0|      ++n;
  384|      0|      if (n < tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (384:11): [True: 0, False: 0]
  ------------------
  385|      0|	*p++ = (char)c;
  386|      0|      } else if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (386:18): [True: 0, False: 0]
  ------------------
  387|      0|	*p = (char)c;
  388|      0|	s = new GString(tokBuf, n);
  389|      0|      } else {
  390|      0|	s->append((char)c);
  391|      0|      }
  392|      0|    }
  393|      0|    if (invalid) {
  ------------------
  |  Branch (393:9): [True: 0, False: 0]
  ------------------
  394|      0|      error(errSyntaxError, getPos(), "Null character in name");
  395|      0|      obj->initError();
  396|      0|      if (s) {
  ------------------
  |  Branch (396:11): [True: 0, False: 0]
  ------------------
  397|      0|	delete s;
  398|      0|      }
  399|      0|    } else if (n < tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (399:16): [True: 0, False: 0]
  ------------------
  400|      0|      *p = '\0';
  401|      0|      obj->initName(tokBuf);
  402|      0|    } else {
  403|      0|      obj->initName(s->getCString());
  404|      0|      delete s;
  405|      0|    }
  406|      0|    break;
  407|       |
  408|       |  // array punctuation
  409|      0|  case '[':
  ------------------
  |  Branch (409:3): [True: 0, False: 45]
  ------------------
  410|      2|  case ']':
  ------------------
  |  Branch (410:3): [True: 2, False: 43]
  ------------------
  411|      2|    tokBuf[0] = (char)c;
  412|      2|    tokBuf[1] = '\0';
  413|      2|    obj->initCmd(tokBuf);
  414|      2|    break;
  415|       |
  416|       |  // hex string or dict punctuation
  417|      0|  case '<':
  ------------------
  |  Branch (417:3): [True: 0, False: 45]
  ------------------
  418|      0|    c = lookChar();
  419|       |
  420|       |    // dict punctuation
  421|      0|    if (c == '<') {
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|      getChar();
  423|      0|      tokBuf[0] = tokBuf[1] = '<';
  424|      0|      tokBuf[2] = '\0';
  425|      0|      obj->initCmd(tokBuf);
  426|       |
  427|       |    // hex string
  428|      0|    } else {
  429|      0|      p = tokBuf;
  430|      0|      m = n = 0;
  431|      0|      c2 = 0;
  432|      0|      s = NULL;
  433|      0|      nErrors = 0;
  434|      0|      while (nErrors < 100) {
  ------------------
  |  Branch (434:14): [True: 0, False: 0]
  ------------------
  435|      0|	c = getChar();
  436|      0|	if (c == '>') {
  ------------------
  |  Branch (436:6): [True: 0, False: 0]
  ------------------
  437|      0|	  break;
  438|      0|	} else if (c == EOF) {
  ------------------
  |  Branch (438:13): [True: 0, False: 0]
  ------------------
  439|      0|	  error(errSyntaxError, getPos(), "Unterminated hex string");
  440|      0|	  break;
  441|      0|	} else if (specialChars[c] != 1) {
  ------------------
  |  Branch (441:13): [True: 0, False: 0]
  ------------------
  442|      0|	  c2 = c2 << 4;
  443|      0|	  if (c >= '0' && c <= '9') {
  ------------------
  |  Branch (443:8): [True: 0, False: 0]
  |  Branch (443:20): [True: 0, False: 0]
  ------------------
  444|      0|	    c2 += c - '0';
  445|      0|	  } else if (c >= 'A' && c <= 'F') {
  ------------------
  |  Branch (445:15): [True: 0, False: 0]
  |  Branch (445:27): [True: 0, False: 0]
  ------------------
  446|      0|	    c2 += c - 'A' + 10;
  447|      0|	  } else if (c >= 'a' && c <= 'f') {
  ------------------
  |  Branch (447:15): [True: 0, False: 0]
  |  Branch (447:27): [True: 0, False: 0]
  ------------------
  448|      0|	    c2 += c - 'a' + 10;
  449|      0|	  } else {
  450|      0|	    error(errSyntaxError, getPos(),
  451|      0|		  "Illegal character <{0:02x}> in hex string", c);
  452|      0|	    ++nErrors;
  453|      0|	  }
  454|      0|	  if (++m == 2) {
  ------------------
  |  Branch (454:8): [True: 0, False: 0]
  ------------------
  455|      0|	    if (n == tokBufSize) {
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (455:10): [True: 0, False: 0]
  ------------------
  456|      0|	      if (!s)
  ------------------
  |  Branch (456:12): [True: 0, False: 0]
  ------------------
  457|      0|		s = new GString(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  458|      0|	      else
  459|      0|		s->append(tokBuf, tokBufSize);
  ------------------
  |  |   19|      0|#define tokBufSize 128		// size of token buffer
  ------------------
  460|      0|	      p = tokBuf;
  461|      0|	      n = 0;
  462|      0|	    }
  463|      0|	    *p++ = (char)c2;
  464|      0|	    ++n;
  465|      0|	    c2 = 0;
  466|      0|	    m = 0;
  467|      0|	  }
  468|      0|	}
  469|      0|      }
  470|      0|      if (!s)
  ------------------
  |  Branch (470:11): [True: 0, False: 0]
  ------------------
  471|      0|	s = new GString(tokBuf, n);
  472|      0|      else
  473|      0|	s->append(tokBuf, n);
  474|      0|      if (m == 1)
  ------------------
  |  Branch (474:11): [True: 0, False: 0]
  ------------------
  475|      0|	s->append((char)(c2 << 4));
  476|      0|      obj->initString(s);
  477|      0|    }
  478|      0|    break;
  479|       |
  480|       |  // dict punctuation
  481|      0|  case '>':
  ------------------
  |  Branch (481:3): [True: 0, False: 45]
  ------------------
  482|      0|    c = lookChar();
  483|      0|    if (c == '>') {
  ------------------
  |  Branch (483:9): [True: 0, False: 0]
  ------------------
  484|      0|      getChar();
  485|      0|      tokBuf[0] = tokBuf[1] = '>';
  486|      0|      tokBuf[2] = '\0';
  487|      0|      obj->initCmd(tokBuf);
  488|      0|    } else {
  489|      0|      error(errSyntaxError, getPos(), "Illegal character '>'");
  490|      0|      obj->initError();
  491|      0|    }
  492|      0|    break;
  493|       |
  494|       |  // error
  495|      0|  case ')':
  ------------------
  |  Branch (495:3): [True: 0, False: 45]
  ------------------
  496|      1|  case '{':
  ------------------
  |  Branch (496:3): [True: 1, False: 44]
  ------------------
  497|      1|  case '}':
  ------------------
  |  Branch (497:3): [True: 0, False: 45]
  ------------------
  498|      1|    error(errSyntaxError, getPos(), "Illegal character '{0:c}'", c);
  499|      1|    obj->initError();
  500|      1|    break;
  501|       |
  502|       |  // command
  503|     36|  default:
  ------------------
  |  Branch (503:3): [True: 36, False: 9]
  ------------------
  504|     36|    p = tokBuf;
  505|     36|    *p++ = (char)c;
  506|     36|    n = 1;
  507|    428|    while ((c = lookChar()) != EOF && !specialChars[c]) {
  ------------------
  |  Branch (507:12): [True: 428, False: 0]
  |  Branch (507:39): [True: 393, False: 35]
  ------------------
  508|    393|      getChar();
  509|    393|      if (++n == tokBufSize) {
  ------------------
  |  |   19|    393|#define tokBufSize 128		// size of token buffer
  ------------------
  |  Branch (509:11): [True: 1, False: 392]
  ------------------
  510|      1|	error(errSyntaxError, getPos(), "Command token too long");
  511|      1|	break;
  512|      1|      }
  513|    392|      *p++ = (char)c;
  514|    392|    }
  515|     36|    *p = '\0';
  516|     36|    if (tokBuf[0] == 't' && !strcmp(tokBuf, "true")) {
  ------------------
  |  Branch (516:9): [True: 1, False: 35]
  |  Branch (516:29): [True: 0, False: 1]
  ------------------
  517|      0|      obj->initBool(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  518|     36|    } else if (tokBuf[0] == 'f' && !strcmp(tokBuf, "false")) {
  ------------------
  |  Branch (518:16): [True: 0, False: 36]
  |  Branch (518:36): [True: 0, False: 0]
  ------------------
  519|      0|      obj->initBool(gFalse);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  520|     36|    } else if (tokBuf[0] == 'n' && !strcmp(tokBuf, "null")) {
  ------------------
  |  Branch (520:16): [True: 0, False: 36]
  |  Branch (520:36): [True: 0, False: 0]
  ------------------
  521|      0|      obj->initNull();
  522|     36|    } else {
  523|     36|      obj->initCmd(tokBuf);
  524|     36|    }
  525|     36|    break;
  526|     45|  }
  527|       |
  528|     45|  return obj;
  529|     45|}
_ZN5Lexer7isSpaceEi:
  552|  32.4k|GBool Lexer::isSpace(int c) {
  553|  32.4k|  return c >= 0 && c <= 0xff && specialChars[c] == 1;
  ------------------
  |  Branch (553:10): [True: 32.4k, False: 1]
  |  Branch (553:20): [True: 32.4k, False: 0]
  |  Branch (553:33): [True: 22.2k, False: 10.1k]
  ------------------
  554|  32.4k|}

_ZN5Lexer6getPosEv:
   60|      2|    { return curStr.isNone() ? -1 : curStr.streamGetPos(); }
  ------------------
  |  Branch (60:14): [True: 0, False: 2]
  ------------------

_ZN14NameToCharCodeC2Ev:
   25|    226|NameToCharCode::NameToCharCode() {
   26|    226|  int i;
   27|       |
   28|    226|  size = 31;
   29|    226|  len = 0;
   30|    226|  tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   31|  7.23k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (31:15): [True: 7.00k, False: 226]
  ------------------
   32|  7.00k|    tab[i].name = NULL;
   33|  7.00k|  }
   34|    226|}
_ZN14NameToCharCodeD2Ev:
   36|    226|NameToCharCode::~NameToCharCode() {
   37|    226|  int i;
   38|       |
   39|  1.90M|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (39:15): [True: 1.90M, False: 226]
  ------------------
   40|  1.90M|    if (tab[i].name) {
  ------------------
  |  Branch (40:9): [True: 504k, False: 1.40M]
  ------------------
   41|   504k|      gfree(tab[i].name);
   42|   504k|    }
   43|  1.90M|  }
   44|    226|  gfree(tab);
   45|    226|}
_ZN14NameToCharCode3addEPKcj:
   47|   504k|void NameToCharCode::add(const char *name, CharCode c) {
   48|   504k|  NameToCharCodeEntry *oldTab;
   49|   504k|  int h, i, oldSize;
   50|       |
   51|       |  // expand the table if necessary
   52|   504k|  if (len >= size / 2) {
  ------------------
  |  Branch (52:7): [True: 1.46k, False: 503k]
  ------------------
   53|  1.46k|    oldSize = size;
   54|  1.46k|    oldTab = tab;
   55|  1.46k|    size = 2*size + 1;
   56|  1.46k|    tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   57|  3.80M|    for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (57:17): [True: 3.80M, False: 1.46k]
  ------------------
   58|  3.80M|      tab[h].name = NULL;
   59|  3.80M|    }
   60|  1.90M|    for (i = 0; i < oldSize; ++i) {
  ------------------
  |  Branch (60:17): [True: 1.90M, False: 1.46k]
  ------------------
   61|  1.90M|      if (oldTab[i].name) {
  ------------------
  |  Branch (61:11): [True: 949k, False: 951k]
  ------------------
   62|   949k|	h = hash(oldTab[i].name);
   63|  1.38M|	while (tab[h].name) {
  ------------------
  |  Branch (63:9): [True: 437k, False: 949k]
  ------------------
   64|   437k|	  if (++h == size) {
  ------------------
  |  Branch (64:8): [True: 0, False: 437k]
  ------------------
   65|      0|	    h = 0;
   66|      0|	  }
   67|   437k|	}
   68|   949k|	tab[h] = oldTab[i];
   69|   949k|      }
   70|  1.90M|    }
   71|  1.46k|    gfree(oldTab);
   72|  1.46k|  }
   73|       |
   74|       |  // add the new name
   75|   504k|  h = hash(name);
   76|  2.09M|  while (tab[h].name && strcmp(tab[h].name, name)) {
  ------------------
  |  Branch (76:10): [True: 1.59M, False: 504k]
  |  Branch (76:25): [True: 1.59M, False: 113]
  ------------------
   77|  1.59M|    if (++h == size) {
  ------------------
  |  Branch (77:9): [True: 339, False: 1.59M]
  ------------------
   78|    339|      h = 0;
   79|    339|    }
   80|  1.59M|  }
   81|   504k|  if (!tab[h].name) {
  ------------------
  |  Branch (81:7): [True: 504k, False: 113]
  ------------------
   82|   504k|    tab[h].name = copyString(name);
   83|   504k|  }
   84|   504k|  tab[h].c = c;
   85|       |
   86|   504k|  ++len;
   87|   504k|}
_ZN14NameToCharCode4hashEPKc:
  104|  1.45M|int NameToCharCode::hash(const char *name) {
  105|  1.45M|  const char *p;
  106|  1.45M|  unsigned int h;
  107|       |
  108|  1.45M|  h = 0;
  109|  17.0M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (109:18): [True: 15.6M, False: 1.45M]
  ------------------
  110|  15.6M|    h = 17 * h + (int)(*p & 0xff);
  111|  15.6M|  }
  112|  1.45M|  return (int)(h % size);
  113|  1.45M|}

_ZN6Object10initStreamEP6Stream:
   70|     15|Object *Object::initStream(Stream *streamA) {
   71|     15|  initObj(objStream);
  ------------------
  |  |   77|     15|#define initObj(t) type = t
  ------------------
   72|     15|  stream = streamA;
   73|     15|  return this;
   74|     15|}
_ZN6Object4copyEPS_:
   76|     45|Object *Object::copy(Object *obj) {
   77|     45|  *obj = *this;
   78|     45|  switch (type) {
   79|      0|  case objString:
  ------------------
  |  Branch (79:3): [True: 0, False: 45]
  ------------------
   80|      0|    obj->string = string->copy();
   81|      0|    break;
   82|      0|  case objName:
  ------------------
  |  Branch (82:3): [True: 0, False: 45]
  ------------------
   83|      0|    obj->name = copyString(name);
   84|      0|    break;
   85|      0|  case objArray:
  ------------------
  |  Branch (85:3): [True: 0, False: 45]
  ------------------
   86|      0|    array->incRef();
   87|      0|    break;
   88|      0|  case objDict:
  ------------------
  |  Branch (88:3): [True: 0, False: 45]
  ------------------
   89|      0|    dict->incRef();
   90|      0|    break;
   91|     15|  case objStream:
  ------------------
  |  Branch (91:3): [True: 15, False: 30]
  ------------------
   92|     15|    obj->stream = stream->copy();
   93|     15|    break;
   94|     14|  case objCmd:
  ------------------
  |  Branch (94:3): [True: 14, False: 31]
  ------------------
   95|     14|    obj->cmd = copyString(cmd);
   96|     14|    break;
   97|     16|  default:
  ------------------
  |  Branch (97:3): [True: 16, False: 29]
  ------------------
   98|     16|    break;
   99|     45|  }
  100|       |#ifdef DEBUG_OBJECT_MEM
  101|       |#if MULTITHREADED
  102|       |  gAtomicIncrement(&numAlloc[type]);
  103|       |#else
  104|       |  ++numAlloc[type];
  105|       |#endif
  106|       |#endif
  107|     45|  return obj;
  108|     45|}
_ZN6Object4freeEv:
  115|    459|void Object::free() {
  116|    459|  switch (type) {
  117|      0|  case objString:
  ------------------
  |  Branch (117:3): [True: 0, False: 459]
  ------------------
  118|      0|    delete string;
  119|      0|    break;
  120|      0|  case objName:
  ------------------
  |  Branch (120:3): [True: 0, False: 459]
  ------------------
  121|      0|    gfree(name);
  122|      0|    break;
  123|      0|  case objArray:
  ------------------
  |  Branch (123:3): [True: 0, False: 459]
  ------------------
  124|      0|    if (!array->decRef()) {
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|      delete array;
  126|      0|    }
  127|      0|    break;
  128|      0|  case objDict:
  ------------------
  |  Branch (128:3): [True: 0, False: 459]
  ------------------
  129|      0|    if (!dict->decRef()) {
  ------------------
  |  Branch (129:9): [True: 0, False: 0]
  ------------------
  130|      0|      delete dict;
  131|      0|    }
  132|      0|    break;
  133|     30|  case objStream:
  ------------------
  |  Branch (133:3): [True: 30, False: 429]
  ------------------
  134|     30|    delete stream;
  135|     30|    break;
  136|     52|  case objCmd:
  ------------------
  |  Branch (136:3): [True: 52, False: 407]
  ------------------
  137|     52|    gfree(cmd);
  138|     52|    break;
  139|    377|  default:
  ------------------
  |  Branch (139:3): [True: 377, False: 82]
  ------------------
  140|    377|    break;
  141|    459|  }
  142|       |#ifdef DEBUG_OBJECT_MEM
  143|       |#if MULTITHREADED
  144|       |  gAtomicDecrement(&numAlloc[type]);
  145|       |#else
  146|       |  --numAlloc[type];
  147|       |#endif
  148|       |#endif
  149|    459|  type = objNone;
  150|    459|}

_ZN6ObjectC2Ev:
   85|  4.65k|    type(objNone) {}
_ZN6Object8initNullEv:
   99|    128|    { initObj(objNull); return this; }
  ------------------
  |  |   77|    128|#define initObj(t) type = t
  ------------------
_ZN6Object7initIntEi:
   91|      6|    { initObj(objInt); intg = intgA; return this; }
  ------------------
  |  |   77|      6|#define initObj(t) type = t
  ------------------
_ZN6Object7initCmdEPc:
  107|     38|    { initObj(objCmd); cmd = copyString(cmdA); return this; }
  ------------------
  |  |   77|     38|#define initObj(t) type = t
  ------------------
_ZN6Object9initErrorEv:
  109|      1|    { initObj(objError); return this; }
  ------------------
  |  |   77|      1|#define initObj(t) type = t
  ------------------
_ZN6Object5isIntEv:
  126|     30|  GBool isInt() { return type == objInt; }
_ZN6Object8isStringEv:
  129|     15|  GBool isString() { return type == objString; }
_ZN6Object6isNoneEv:
  139|  1.61k|  GBool isNone() { return type == objNone; }
_ZN6Object5isCmdEPKc:
  147|     15|    { return type == objCmd && !strcmp(cmd, cmdA); }
  ------------------
  |  Branch (147:14): [True: 11, False: 4]
  |  Branch (147:32): [True: 0, False: 11]
  ------------------
_ZN6Object11streamResetEv:
  290|     15|  { stream->reset(); }
_ZN6Object11streamCloseEv:
  293|     15|  { stream->close(); }
_ZN6Object13streamGetCharEv:
  296|  1.16k|  { return stream->getChar(); }
_ZN6Object14streamLookCharEv:
  299|    440|  { return stream->lookChar(); }
_ZN6Object12streamGetPosEv:
  308|      2|  { return stream->getPos(); }

_ZN6PDFDocC2EP10BaseStreamP7GStringS3_P7PDFCore:
  219|    113|	       GString *userPassword, PDFCore *coreA) {
  220|       |#ifdef _WIN32
  221|       |  int n, i;
  222|       |#endif
  223|       |
  224|    113|  init(coreA);
  225|       |
  226|    113|  if (strA->getFileName()) {
  ------------------
  |  Branch (226:7): [True: 0, False: 113]
  ------------------
  227|      0|    fileName = strA->getFileName()->copy();
  228|       |#ifdef _WIN32
  229|       |    n = fileName->getLength();
  230|       |    fileNameU = (wchar_t *)gmallocn(n + 1, sizeof(wchar_t));
  231|       |    for (i = 0; i < n; ++i) {
  232|       |      fileNameU[i] = (wchar_t)(fileName->getChar(i) & 0xff);
  233|       |    }
  234|       |    fileNameU[n] = L'\0';
  235|       |#endif
  236|    113|  } else {
  237|    113|    fileName = NULL;
  238|       |#ifdef _WIN32
  239|       |    fileNameU = NULL;
  240|       |#endif
  241|    113|  }
  242|    113|  str = strA;
  243|    113|  ok = setup(ownerPassword, userPassword);
  244|    113|}
_ZN6PDFDoc4initEP7PDFCore:
  246|    113|void PDFDoc::init(PDFCore *coreA) {
  247|    113|  ok = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  248|    113|  errCode = errNone;
  ------------------
  |  |   12|    113|#define errNone             0	// no error
  ------------------
  249|    113|  core = coreA;
  250|    113|  file = NULL;
  251|    113|  str = NULL;
  252|    113|  xref = NULL;
  253|    113|  catalog = NULL;
  254|    113|  annots = NULL;
  255|    113|#ifndef DISABLE_OUTLINE
  256|    113|  outline = NULL;
  257|    113|#endif
  258|    113|  optContent = NULL;
  259|    113|}
_ZN6PDFDoc5setupEP7GStringS1_:
  261|    113|GBool PDFDoc::setup(GString *ownerPassword, GString *userPassword) {
  262|       |
  263|    113|  str->reset();
  264|       |
  265|       |  // check header
  266|    113|  checkHeader();
  267|       |
  268|       |  // read the xref and catalog
  269|    113|  if (!PDFDoc::setup2(ownerPassword, userPassword, gFalse)) {
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  |  Branch (269:7): [True: 113, False: 0]
  ------------------
  270|    113|    if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   18|    226|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
                  if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  |  Branch (270:9): [True: 113, False: 0]
  |  Branch (270:34): [True: 0, False: 0]
  ------------------
  271|       |      // try repairing the xref table
  272|    113|      error(errSyntaxWarning, -1,
  273|    113|	    "PDF file is damaged - attempting to reconstruct xref table...");
  274|    113|      if (!PDFDoc::setup2(ownerPassword, userPassword, gTrue)) {
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  |  Branch (274:11): [True: 113, False: 0]
  ------------------
  275|    113|	return gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  276|    113|      }
  277|    113|    } else {
  278|      0|      return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  279|      0|    }
  280|    113|  }
  281|       |
  282|      0|#ifndef DISABLE_OUTLINE
  283|       |  // read outline
  284|      0|  outline = new Outline(catalog->getOutline(), xref);
  285|      0|#endif
  286|       |
  287|       |  // read the optional content info
  288|      0|  optContent = new OptionalContent(this);
  289|       |
  290|       |
  291|       |  // done
  292|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  293|    113|}
_ZN6PDFDoc6setup2EP7GStringS1_i:
  296|    226|		     GBool repairXRef) {
  297|       |  // read xref table
  298|    226|  xref = new XRef(str, repairXRef);
  299|    226|  if (!xref->isOk()) {
  ------------------
  |  Branch (299:7): [True: 226, False: 0]
  ------------------
  300|    226|    error(errSyntaxError, -1, "Couldn't read xref table");
  301|    226|    errCode = xref->getErrorCode();
  302|    226|    delete xref;
  303|    226|    xref = NULL;
  304|    226|    return gFalse;
  ------------------
  |  |   18|    226|#define gFalse 0
  ------------------
  305|    226|  }
  306|       |
  307|       |  // check for encryption
  308|      0|  if (!checkEncryption(ownerPassword, userPassword)) {
  ------------------
  |  Branch (308:7): [True: 0, False: 0]
  ------------------
  309|      0|    errCode = errEncrypted;
  ------------------
  |  |   21|      0|#define errEncrypted        4	// file was encrypted and password was
  ------------------
  310|      0|    delete xref;
  311|      0|    xref = NULL;
  312|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  313|      0|  }
  314|       |
  315|       |  // read catalog
  316|      0|  catalog = new Catalog(this);
  317|      0|  if (!catalog->isOk()) {
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|    error(errSyntaxError, -1, "Couldn't read page catalog");
  319|      0|    errCode = errBadCatalog;
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  320|      0|    delete catalog;
  321|      0|    catalog = NULL;
  322|      0|    delete xref;
  323|      0|    xref = NULL;
  324|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  325|      0|  }
  326|       |
  327|       |  // initialize the Annots object
  328|      0|  annots = new Annots(this);
  329|       |
  330|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  331|      0|}
_ZN6PDFDocD2Ev:
  333|    113|PDFDoc::~PDFDoc() {
  334|    113|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 113]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|    113|#ifndef DISABLE_OUTLINE
  338|    113|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 113]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|    113|#endif
  342|    113|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 113]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|    113|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 113]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|    113|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 113]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|    113|  if (str) {
  ------------------
  |  Branch (351:7): [True: 113, False: 0]
  ------------------
  352|    113|    delete str;
  353|    113|  }
  354|    113|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 113]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|    113|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 0, False: 113]
  ------------------
  358|      0|    delete fileName;
  359|      0|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|    113|}
_ZN6PDFDoc11checkHeaderEv:
  369|    113|void PDFDoc::checkHeader() {
  370|    113|  char hdrBuf[headerSearchSize+1];
  371|    113|  char *p;
  372|    113|  int i;
  373|       |
  374|    113|  pdfVersion = 0;
  375|    113|  memset(hdrBuf, 0, headerSearchSize + 1);
  ------------------
  |  |   44|    113|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  376|    113|  str->getBlock(hdrBuf, headerSearchSize);
  ------------------
  |  |   44|    113|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  377|   110k|  for (i = 0; i < headerSearchSize - 5; ++i) {
  ------------------
  |  |   44|   110k|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (377:15): [True: 110k, False: 108]
  ------------------
  378|   110k|    if (!strncmp(&hdrBuf[i], "%PDF-", 5)) {
  ------------------
  |  Branch (378:9): [True: 5, False: 110k]
  ------------------
  379|      5|      break;
  380|      5|    }
  381|   110k|  }
  382|    113|  if (i >= headerSearchSize - 5) {
  ------------------
  |  |   44|    113|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (382:7): [True: 108, False: 5]
  ------------------
  383|    108|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  384|    108|    return;
  385|    108|  }
  386|      5|  str->moveStart(i);
  387|      5|  if (!(p = strtok(&hdrBuf[i+5], " \t\n\r"))) {
  ------------------
  |  Branch (387:7): [True: 2, False: 3]
  ------------------
  388|      2|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  389|      2|    return;
  390|      2|  }
  391|      3|  pdfVersion = atof(p);
  392|      3|  if (!(hdrBuf[i+5] >= '0' && hdrBuf[i+5] <= '9') ||
  ------------------
  |  Branch (392:9): [True: 1, False: 2]
  |  Branch (392:31): [True: 0, False: 1]
  ------------------
  393|      3|      pdfVersion > supportedPDFVersionNum + 0.0001) {
  ------------------
  |  |   28|      0|#define supportedPDFVersionNum 2.0
  ------------------
  |  Branch (393:7): [True: 0, False: 0]
  ------------------
  394|      3|    error(errSyntaxWarning, -1,
  395|      3|	  "PDF version {0:s} -- xpdf supports version {1:s} (continuing anyway)",
  396|      3|	  p, supportedPDFVersionStr);
  ------------------
  |  |   27|      3|#define supportedPDFVersionStr "2.0"
  ------------------
  397|      3|  }
  398|      3|}

_ZN6PDFDoc4isOkEv:
   57|    113|  GBool isOk() { return ok; }

_ZN6ParserC2EP4XRefP5Lexeri:
   26|     15|Parser::Parser(XRef *xrefA, Lexer *lexerA, GBool allowStreamsA) {
   27|     15|  xref = xrefA;
   28|     15|  lexer = lexerA;
   29|     15|  inlineImg = 0;
   30|     15|  allowStreams = allowStreamsA;
   31|     15|  lexer->getObj(&buf1);
   32|     15|  lexer->getObj(&buf2);
   33|     15|}
_ZN6ParserD2Ev:
   35|     15|Parser::~Parser() {
   36|     15|  buf1.free();
   37|     15|  buf2.free();
   38|     15|  delete lexer;
   39|     15|}
_ZN6Parser6getObjEP6ObjectiPh14CryptAlgorithmiiii:
   44|     15|		       int objNum, int objGen, int recursion) {
   45|     15|  char *key;
   46|     15|  Stream *str;
   47|     15|  Object obj2;
   48|     15|  int num;
   49|     15|  DecryptStream *decrypt;
   50|     15|  GString *s, *s2;
   51|     15|  int c;
   52|       |
   53|       |  // refill buffer after inline image data
   54|     15|  if (inlineImg == 2) {
  ------------------
  |  Branch (54:7): [True: 0, False: 15]
  ------------------
   55|      0|    buf1.free();
   56|      0|    buf2.free();
   57|      0|    lexer->getObj(&buf1);
   58|      0|    lexer->getObj(&buf2);
   59|      0|    inlineImg = 0;
   60|      0|  }
   61|       |
   62|       |  // array
   63|     15|  if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("[")) {
  ------------------
  |  |   24|     15|#define recursionLimit 500
  ------------------
  |  Branch (63:7): [True: 0, False: 15]
  |  Branch (63:22): [True: 0, False: 0]
  |  Branch (63:52): [True: 0, False: 0]
  ------------------
   64|      0|    shift();
   65|      0|    obj->initArray(xref);
   66|      0|    while (!buf1.isCmd("]") && !buf1.isEOF())
  ------------------
  |  Branch (66:12): [True: 0, False: 0]
  |  Branch (66:32): [True: 0, False: 0]
  ------------------
   67|      0|      obj->arrayAdd(getObj(&obj2, gFalse, fileKey, encAlgorithm, keyLength,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   68|      0|			   objNum, objGen, recursion + 1));
   69|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (69:9): [True: 0, False: 0]
  ------------------
   70|      0|      error(errSyntaxError, getPos(), "End of file inside array");
   71|      0|    shift();
   72|       |
   73|       |  // dictionary or stream
   74|     15|  } else if (!simpleOnly && recursion < recursionLimit && buf1.isCmd("<<")) {
  ------------------
  |  |   24|     15|#define recursionLimit 500
  ------------------
  |  Branch (74:14): [True: 0, False: 15]
  |  Branch (74:29): [True: 0, False: 0]
  |  Branch (74:59): [True: 0, False: 0]
  ------------------
   75|      0|    shift();
   76|      0|    obj->initDict(xref);
   77|      0|    while (!buf1.isCmd(">>") && !buf1.isEOF()) {
  ------------------
  |  Branch (77:12): [True: 0, False: 0]
  |  Branch (77:33): [True: 0, False: 0]
  ------------------
   78|      0|      if (!buf1.isName()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|	error(errSyntaxError, getPos(),
   80|      0|	      "Dictionary key must be a name object");
   81|      0|	shift();
   82|      0|      } else {
   83|      0|	key = copyString(buf1.getName());
   84|      0|	shift();
   85|      0|	if (buf1.isEOF() || buf1.isError()) {
  ------------------
  |  Branch (85:6): [True: 0, False: 0]
  |  Branch (85:22): [True: 0, False: 0]
  ------------------
   86|      0|	  gfree(key);
   87|      0|	  break;
   88|      0|	}
   89|      0|	obj->dictAdd(key, getObj(&obj2, gFalse,
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   90|      0|				 fileKey, encAlgorithm, keyLength,
   91|      0|				 objNum, objGen, recursion + 1));
   92|      0|      }
   93|      0|    }
   94|      0|    if (buf1.isEOF())
  ------------------
  |  Branch (94:9): [True: 0, False: 0]
  ------------------
   95|      0|      error(errSyntaxError, getPos(), "End of file inside dictionary");
   96|       |    // stream objects are not allowed inside content streams or
   97|       |    // object streams
   98|      0|    if (allowStreams && buf2.isCmd("stream")) {
  ------------------
  |  Branch (98:9): [True: 0, False: 0]
  |  Branch (98:25): [True: 0, False: 0]
  ------------------
   99|      0|      if ((str = makeStream(obj, fileKey, encAlgorithm, keyLength,
  ------------------
  |  Branch (99:11): [True: 0, False: 0]
  ------------------
  100|      0|			    objNum, objGen, recursion + 1))) {
  101|      0|	obj->initStream(str);
  102|      0|      } else {
  103|      0|	obj->free();
  104|      0|	obj->initError();
  105|      0|      }
  106|      0|    } else {
  107|      0|      shift();
  108|      0|    }
  109|       |
  110|       |  // indirect reference or integer
  111|     15|  } else if (buf1.isInt()) {
  ------------------
  |  Branch (111:14): [True: 0, False: 15]
  ------------------
  112|      0|    num = buf1.getInt();
  113|      0|    shift();
  114|      0|    if (buf1.isInt() && buf2.isCmd("R")) {
  ------------------
  |  Branch (114:9): [True: 0, False: 0]
  |  Branch (114:25): [True: 0, False: 0]
  ------------------
  115|      0|      obj->initRef(num, buf1.getInt());
  116|      0|      shift();
  117|      0|      shift();
  118|      0|    } else {
  119|      0|      obj->initInt(num);
  120|      0|    }
  121|       |
  122|       |  // string
  123|     15|  } else if (buf1.isString() && fileKey) {
  ------------------
  |  Branch (123:14): [True: 0, False: 15]
  |  Branch (123:33): [True: 0, False: 0]
  ------------------
  124|      0|    s = buf1.getString();
  125|      0|    s2 = new GString();
  126|      0|    obj2.initNull();
  127|      0|    decrypt = new DecryptStream(new MemStream(s->getCString(), 0,
  128|      0|					      s->getLength(), &obj2),
  129|      0|				fileKey, encAlgorithm, keyLength,
  130|      0|				objNum, objGen);
  131|      0|    decrypt->reset();
  132|      0|    while ((c = decrypt->getChar()) != EOF) {
  ------------------
  |  Branch (132:12): [True: 0, False: 0]
  ------------------
  133|      0|      s2->append((char)c);
  134|      0|    }
  135|      0|    delete decrypt;
  136|      0|    obj->initString(s2);
  137|      0|    shift();
  138|       |
  139|       |  // simple object
  140|     15|  } else {
  141|     15|    buf1.copy(obj);
  142|     15|    shift();
  143|     15|  }
  144|       |
  145|     15|  return obj;
  146|     15|}
_ZN6Parser5shiftEv:
  293|     15|void Parser::shift() {
  294|     15|  if (inlineImg > 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 15]
  ------------------
  295|      0|    if (inlineImg < 2) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      ++inlineImg;
  297|      0|    } else {
  298|       |      // in a damaged content stream, if 'ID' shows up in the middle
  299|       |      // of a dictionary, we need to reset
  300|      0|      inlineImg = 0;
  301|      0|    }
  302|     15|  } else if (buf2.isCmd("ID")) {
  ------------------
  |  Branch (302:14): [True: 0, False: 15]
  ------------------
  303|      0|    lexer->skipChar();		// skip char after 'ID' command
  304|      0|    inlineImg = 1;
  305|      0|  }
  306|     15|  buf1.free();
  307|     15|  buf1 = buf2;
  308|     15|  if (inlineImg > 0)		// don't buffer inline image data
  ------------------
  |  Branch (308:7): [True: 0, False: 15]
  ------------------
  309|      0|    buf2.initNull();
  310|     15|  else
  311|     15|    lexer->getObj(&buf2);
  312|     15|}

_ZN6StreamC2Ev:
   62|    143|Stream::Stream() {
   63|    143|}
_ZN6StreamD2Ev:
   65|    143|Stream::~Stream() {
   66|    143|}
_ZN10BaseStreamC2EP6Object:
  325|    143|BaseStream::BaseStream(Object *dictA) {
  326|    143|  dict = *dictA;
  327|    143|}
_ZN10BaseStreamD2Ev:
  329|    143|BaseStream::~BaseStream() {
  330|    143|  dict.free();
  331|    143|}
_ZN9MemStreamC2EPcjjP6Object:
  873|    143|    BaseStream(dictA) {
  874|    143|  buf = bufA;
  875|    143|  start = startA;
  876|    143|  length = lengthA;
  877|    143|  bufEnd = buf + start + length;
  878|    143|  bufPtr = buf + start;
  879|    143|  needFree = gFalse;
  ------------------
  |  |   18|    143|#define gFalse 0
  ------------------
  880|    143|}
_ZN9MemStreamD2Ev:
  882|    143|MemStream::~MemStream() {
  883|    143|  if (needFree) {
  ------------------
  |  Branch (883:7): [True: 0, False: 143]
  ------------------
  884|      0|    gfree(buf);
  885|      0|  }
  886|    143|}
_ZN9MemStream4copyEv:
  888|     15|Stream *MemStream::copy() {
  889|     15|  Object dictA;
  890|       |
  891|     15|  dict.copy(&dictA);
  892|     15|  return new MemStream(buf, start, length, &dictA);
  893|     15|}
_ZN9MemStream13makeSubStreamElilP6Object:
  896|     15|				 GFileOffset lengthA, Object *dictA) {
  897|     15|  MemStream *subStr;
  898|     15|  Guint newStart, newLength;
  899|       |
  900|     15|  if (startA < start) {
  ------------------
  |  Branch (900:7): [True: 0, False: 15]
  ------------------
  901|      0|    newStart = start;
  902|     15|  } else if (startA > start + length) {
  ------------------
  |  Branch (902:14): [True: 0, False: 15]
  ------------------
  903|      0|    newStart = start + (int)length;
  904|     15|  } else {
  905|     15|    newStart = (int)startA;
  906|     15|  }
  907|     15|  if (!limited || newStart + lengthA > start + length) {
  ------------------
  |  Branch (907:7): [True: 15, False: 0]
  |  Branch (907:19): [True: 0, False: 0]
  ------------------
  908|     15|    newLength = start + length - newStart;
  909|     15|  } else {
  910|      0|    newLength = (Guint)lengthA;
  911|      0|  }
  912|     15|  subStr = new MemStream(buf, newStart, newLength, dictA);
  913|     15|  return subStr;
  914|     15|}
_ZN9MemStream5resetEv:
  916|    241|void MemStream::reset() {
  917|    241|  bufPtr = buf + start;
  918|    241|}
_ZN9MemStream5closeEv:
  920|     15|void MemStream::close() {
  921|     15|}
_ZN9MemStream8getBlockEPci:
  923|    354|int MemStream::getBlock(char *blk, int size) {
  924|    354|  int n;
  925|       |
  926|    354|  if (size <= 0) {
  ------------------
  |  Branch (926:7): [True: 0, False: 354]
  ------------------
  927|      0|    return 0;
  928|      0|  }
  929|    354|  if (bufEnd - bufPtr < size) {
  ------------------
  |  Branch (929:7): [True: 317, False: 37]
  ------------------
  930|    317|    n = (int)(bufEnd - bufPtr);
  931|    317|  } else {
  932|     37|    n = size;
  933|     37|  }
  934|    354|  memcpy(blk, bufPtr, n);
  935|    354|  bufPtr += n;
  936|    354|  return n;
  937|    354|}
_ZN9MemStream6setPosEli:
  939|    128|void MemStream::setPos(GFileOffset pos, int dir) {
  940|    128|  Guint i;
  941|       |
  942|    128|  if (dir >= 0) {
  ------------------
  |  Branch (942:7): [True: 15, False: 113]
  ------------------
  943|     15|    i = (Guint)pos;
  944|    113|  } else {
  945|    113|    if (pos > start + length) {
  ------------------
  |  Branch (945:9): [True: 102, False: 11]
  ------------------
  946|    102|      i = 0;
  947|    102|    } else {
  948|     11|      i = (Guint)(start + length - pos);
  949|     11|    }
  950|    113|  }
  951|    128|  if (i < start) {
  ------------------
  |  Branch (951:7): [True: 5, False: 123]
  ------------------
  952|      5|    i = start;
  953|    123|  } else if (i > start + length) {
  ------------------
  |  Branch (953:14): [True: 0, False: 123]
  ------------------
  954|      0|    i = start + length;
  955|      0|  }
  956|    128|  bufPtr = buf + i;
  957|    128|}
_ZN9MemStream9moveStartEi:
  959|      5|void MemStream::moveStart(int delta) {
  960|      5|  start += delta;
  961|      5|  length -= delta;
  962|      5|  bufPtr = buf + start;
  963|      5|}

_ZN10BaseStream11getFileNameEv:
  180|    113|  virtual GString *getFileName() { return NULL; }
_ZN9MemStream7getCharEv:
  365|  1.16k|    { return (bufPtr < bufEnd) ? (*bufPtr++ & 0xff) : EOF; }
  ------------------
  |  Branch (365:14): [True: 1.16k, False: 0]
  ------------------
_ZN9MemStream8lookCharEv:
  367|    440|    { return (bufPtr < bufEnd) ? (*bufPtr & 0xff) : EOF; }
  ------------------
  |  Branch (367:14): [True: 440, False: 0]
  ------------------
_ZN9MemStream6getPosEv:
  369|     24|  virtual GFileOffset getPos() { return (GFileOffset)(bufPtr - buf); }
_ZN9MemStream8getStartEv:
  371|    226|  virtual GFileOffset getStart() { return start; }

_ZN10UnicodeMapC2EPKciP15UnicodeMapRangei:
  122|    452|		       UnicodeMapRange *rangesA, int lenA) {
  123|    452|  encodingName = new GString(encodingNameA);
  124|    452|  unicodeOut = unicodeOutA;
  125|    452|  kind = unicodeMapResident;
  126|    452|  ranges = rangesA;
  127|    452|  len = lenA;
  128|    452|  eMaps = NULL;
  129|    452|  eMapsLen = 0;
  130|    452|  refCnt = 1;
  131|    452|}
_ZN10UnicodeMapC2EPKciPFijPciE:
  134|    226|		       UnicodeMapFunc funcA) {
  135|    226|  encodingName = new GString(encodingNameA);
  136|    226|  unicodeOut = unicodeOutA;
  137|    226|  kind = unicodeMapFunc;
  138|    226|  func = funcA;
  139|    226|  eMaps = NULL;
  140|    226|  eMapsLen = 0;
  141|    226|  refCnt = 1;
  142|    226|}
_ZN10UnicodeMapD2Ev:
  144|    678|UnicodeMap::~UnicodeMap() {
  145|    678|  delete encodingName;
  146|    678|  if (kind == unicodeMapUser && ranges) {
  ------------------
  |  Branch (146:7): [True: 0, False: 678]
  |  Branch (146:33): [True: 0, False: 0]
  ------------------
  147|      0|    gfree(ranges);
  148|      0|  }
  149|    678|  if (eMaps) {
  ------------------
  |  Branch (149:7): [True: 0, False: 678]
  ------------------
  150|      0|    gfree(eMaps);
  151|      0|  }
  152|    678|}
_ZN15UnicodeMapCacheC2Ev:
  228|    113|UnicodeMapCache::UnicodeMapCache() {
  229|    113|  int i;
  230|       |
  231|    565|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    565|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (231:15): [True: 452, False: 113]
  ------------------
  232|    452|    cache[i] = NULL;
  233|    452|  }
  234|    113|}
_ZN15UnicodeMapCacheD2Ev:
  236|    113|UnicodeMapCache::~UnicodeMapCache() {
  237|    113|  int i;
  238|       |
  239|    565|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    565|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (239:15): [True: 452, False: 113]
  ------------------
  240|    452|    if (cache[i]) {
  ------------------
  |  Branch (240:9): [True: 0, False: 452]
  ------------------
  241|      0|      cache[i]->decRefCnt();
  242|      0|    }
  243|    452|  }
  244|    113|}

_ZN10UnicodeMap15getEncodingNameEv:
   65|    678|  GString *getEncodingName() { return encodingName; }

_ZN16UnicodeRemappingC2Ev:
   69|    113|UnicodeRemapping::UnicodeRemapping() {
   70|  29.0k|  for (int i = 0; i < 256; ++i) {
  ------------------
  |  Branch (70:19): [True: 28.9k, False: 113]
  ------------------
   71|  28.9k|    page0[i] = (Unicode)i;
   72|  28.9k|  }
   73|    113|  sMap = NULL;
   74|    113|  sMapLen = sMapSize = 0;
   75|    113|}
_ZN16UnicodeRemappingD2Ev:
   77|    113|UnicodeRemapping::~UnicodeRemapping() {
   78|    113|  gfree(sMap);
   79|    113|}

_ZN10XRefPosSetC2Ev:
   66|     15|XRefPosSet::XRefPosSet() {
   67|     15|  size = 16;
   68|     15|  len = 0;
   69|     15|  tab = (GFileOffset *)gmallocn(size, sizeof(GFileOffset));
   70|     15|}
_ZN10XRefPosSetD2Ev:
   72|     15|XRefPosSet::~XRefPosSet() {
   73|     15|  gfree(tab);
   74|     15|}
_ZN10XRefPosSet3addEl:
   76|     15|void XRefPosSet::add(GFileOffset pos) {
   77|     15|  int i;
   78|       |
   79|     15|  i = find(pos);
   80|     15|  if (i < len && tab[i] == pos) {
  ------------------
  |  Branch (80:7): [True: 0, False: 15]
  |  Branch (80:18): [True: 0, False: 0]
  ------------------
   81|      0|    return;
   82|      0|  }
   83|     15|  if (len == size) {
  ------------------
  |  Branch (83:7): [True: 0, False: 15]
  ------------------
   84|      0|    if (size > INT_MAX / 2) {
  ------------------
  |  Branch (84:9): [True: 0, False: 0]
  ------------------
   85|      0|      gMemError("Integer overflow in XRefPosSet::add()");
   86|      0|    }
   87|      0|    size *= 2;
   88|      0|    tab = (GFileOffset *)greallocn(tab, size, sizeof(GFileOffset));
   89|      0|  }
   90|     15|  if (i < len) {
  ------------------
  |  Branch (90:7): [True: 0, False: 15]
  ------------------
   91|      0|    memmove(&tab[i + 1], &tab[i], (len - i) * sizeof(GFileOffset));
   92|      0|  }
   93|     15|  tab[i] = pos;
   94|     15|  ++len;
   95|     15|}
_ZN10XRefPosSet5checkEl:
   97|     15|GBool XRefPosSet::check(GFileOffset pos) {
   98|     15|  int i;
   99|       |
  100|     15|  i = find(pos);
  101|     15|  return i < len && tab[i] == pos;
  ------------------
  |  Branch (101:10): [True: 0, False: 15]
  |  Branch (101:21): [True: 0, False: 0]
  ------------------
  102|     15|}
_ZN10XRefPosSet4findEl:
  104|     30|int XRefPosSet::find(GFileOffset pos) {
  105|     30|  int a, b, m;
  106|       |
  107|     30|  a = - 1;
  108|     30|  b = len;
  109|       |  // invariant: tab[a] < pos < tab[b]
  110|     30|  while (b - a > 1) {
  ------------------
  |  Branch (110:10): [True: 0, False: 30]
  ------------------
  111|      0|    m = (a + b) / 2;
  112|      0|    if (tab[m] < pos) {
  ------------------
  |  Branch (112:9): [True: 0, False: 0]
  ------------------
  113|      0|      a = m;
  114|      0|    } else if (tab[m] > pos) {
  ------------------
  |  Branch (114:16): [True: 0, False: 0]
  ------------------
  115|      0|      b = m;
  116|      0|    } else {
  117|      0|      return m;
  118|      0|    }
  119|      0|  }
  120|     30|  return b;
  121|     30|}
_ZN4XRefC2EP10BaseStreami:
  289|    226|XRef::XRef(BaseStream *strA, GBool repair) {
  290|    226|  GFileOffset pos;
  291|    226|  Object obj;
  292|    226|  XRefPosSet *posSet;
  293|    226|  int i;
  294|       |
  295|    226|  ok = gTrue;
  ------------------
  |  |   17|    226|#define gTrue 1
  ------------------
  296|    226|  errCode = errNone;
  ------------------
  |  |   12|    226|#define errNone             0	// no error
  ------------------
  297|    226|  repaired = gFalse;
  ------------------
  |  |   18|    226|#define gFalse 0
  ------------------
  298|    226|  size = 0;
  299|    226|  last = -1;
  300|    226|  entries = NULL;
  301|    226|  lastStartxrefPos = 0;
  302|    226|  xrefTablePos = NULL;
  303|    226|  xrefTablePosLen = 0;
  304|    226|  streamEnds = NULL;
  305|    226|  streamEndsLen = 0;
  306|  29.1k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  29.1k|#define objStrCacheSize 128
  ------------------
  |  Branch (306:15): [True: 28.9k, False: 226]
  ------------------
  307|  28.9k|    objStrs[i] = NULL;
  308|  28.9k|    objStrLastUse[i] = 0;
  309|  28.9k|  }
  310|    226|  objStrCacheLength = 0;
  311|    226|  objStrTime = 0;
  312|       |
  313|    226|  encrypted = gFalse;
  ------------------
  |  |   18|    226|#define gFalse 0
  ------------------
  314|    226|  permFlags = defPermFlags;
  ------------------
  |  |   41|    226|#define defPermFlags 0xfffc
  ------------------
  315|    226|  ownerPasswordOk = gFalse;
  ------------------
  |  |   18|    226|#define gFalse 0
  ------------------
  316|       |
  317|  3.84k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  3.84k|#define xrefCacheSize 16
  ------------------
  |  Branch (317:15): [True: 3.61k, False: 226]
  ------------------
  318|  3.61k|    cache[i].num = -1;
  319|  3.61k|  }
  320|       |
  321|    226|#if MULTITHREADED
  322|    226|  gInitMutex(&objStrsMutex);
  ------------------
  |  |   51|    226|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  323|    226|  gInitMutex(&cacheMutex);
  ------------------
  |  |   51|    226|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  324|    226|#endif
  325|       |
  326|    226|  str = strA;
  327|    226|  start = str->getStart();
  328|       |
  329|       |  // if the 'repair' flag is set, try to reconstruct the xref table
  330|    226|  if (repair) {
  ------------------
  |  Branch (330:7): [True: 113, False: 113]
  ------------------
  331|    113|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (331:9): [True: 113, False: 0]
  ------------------
  332|    113|      errCode = errDamaged;
  ------------------
  |  |   18|    113|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  333|    113|      return;
  334|    113|    }
  335|      0|    repaired = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  336|       |
  337|       |  // if the 'repair' flag is not set, read the xref table
  338|    113|  } else {
  339|       |
  340|       |    // read the trailer
  341|    113|    pos = getStartXref();
  342|    113|    if (pos == 0) {
  ------------------
  |  Branch (342:9): [True: 98, False: 15]
  ------------------
  343|     98|      errCode = errDamaged;
  ------------------
  |  |   18|     98|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  344|     98|      ok = gFalse;
  ------------------
  |  |   18|     98|#define gFalse 0
  ------------------
  345|     98|      return;
  346|     98|    }
  347|       |
  348|       |    // read the xref table
  349|     15|    posSet = new XRefPosSet();
  350|     15|    while (readXRef(&pos, posSet, gFalse)) ;
  ------------------
  |  |   18|     15|#define gFalse 0
  ------------------
  |  Branch (350:12): [True: 0, False: 15]
  ------------------
  351|     15|    xrefTablePosLen = posSet->getLength();
  352|     15|    xrefTablePos = (GFileOffset *)gmallocn(xrefTablePosLen,
  353|     15|					   sizeof(GFileOffset));
  354|     30|    for (i = 0; i < xrefTablePosLen; ++i)  {
  ------------------
  |  Branch (354:17): [True: 15, False: 15]
  ------------------
  355|     15|      xrefTablePos[i] = posSet->get(i);
  356|     15|    }
  357|     15|    delete posSet;
  358|     15|    if (!ok) {
  ------------------
  |  Branch (358:9): [True: 15, False: 0]
  ------------------
  359|     15|      errCode = errDamaged;
  ------------------
  |  |   18|     15|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  360|     15|      return;
  361|     15|    }
  362|     15|  }
  363|       |
  364|       |  // get the root dictionary (catalog) object
  365|      0|  trailerDict.dictLookupNF("Root", &obj);
  366|      0|  if (obj.isRef()) {
  ------------------
  |  Branch (366:7): [True: 0, False: 0]
  ------------------
  367|      0|    rootNum = obj.getRefNum();
  368|      0|    rootGen = obj.getRefGen();
  369|      0|    obj.free();
  370|      0|  } else {
  371|      0|    obj.free();
  372|      0|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (372:9): [True: 0, False: 0]
  ------------------
  373|      0|      errCode = errDamaged;
  ------------------
  |  |   18|      0|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  374|      0|      return;
  375|      0|    }
  376|      0|  }
  377|       |
  378|       |  // now set the trailer dictionary's xref pointer so we can fetch
  379|       |  // indirect objects from it
  380|      0|  trailerDict.getDict()->setXRef(this);
  381|      0|}
_ZN4XRefD2Ev:
  383|    226|XRef::~XRef() {
  384|    226|  int i;
  385|       |
  386|  3.84k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  3.84k|#define xrefCacheSize 16
  ------------------
  |  Branch (386:15): [True: 3.61k, False: 226]
  ------------------
  387|  3.61k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (387:9): [True: 0, False: 3.61k]
  ------------------
  388|      0|      cache[i].obj.free();
  389|      0|    }
  390|  3.61k|  }
  391|    226|  gfree(entries);
  392|    226|  trailerDict.free();
  393|    226|  if (xrefTablePos) {
  ------------------
  |  Branch (393:7): [True: 15, False: 211]
  ------------------
  394|     15|    gfree(xrefTablePos);
  395|     15|  }
  396|    226|  if (streamEnds) {
  ------------------
  |  Branch (396:7): [True: 0, False: 226]
  ------------------
  397|      0|    gfree(streamEnds);
  398|      0|  }
  399|  29.1k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  29.1k|#define objStrCacheSize 128
  ------------------
  |  Branch (399:15): [True: 28.9k, False: 226]
  ------------------
  400|  28.9k|    if (objStrs[i]) {
  ------------------
  |  Branch (400:9): [True: 0, False: 28.9k]
  ------------------
  401|      0|      delete objStrs[i];
  402|      0|    }
  403|  28.9k|  }
  404|    226|#if MULTITHREADED
  405|    226|  gDestroyMutex(&objStrsMutex);
  ------------------
  |  |   52|    226|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  406|    226|  gDestroyMutex(&cacheMutex);
  ------------------
  |  |   52|    226|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  407|    226|#endif
  408|    226|}
_ZN4XRef12getStartXrefEv:
  411|    113|GFileOffset XRef::getStartXref() {
  412|    113|  char buf[xrefSearchSize+1];
  413|    113|  char *p;
  414|    113|  int n, i;
  415|       |
  416|       |  // read last xrefSearchSize bytes
  417|    113|  str->setPos(xrefSearchSize, -1);
  ------------------
  |  |   30|    113|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  418|    113|  n = str->getBlock(buf, xrefSearchSize);
  ------------------
  |  |   30|    113|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  419|    113|  buf[n] = '\0';
  420|       |
  421|       |  // find startxref
  422|  25.1k|  for (i = n - 9; i >= 0; --i) {
  ------------------
  |  Branch (422:19): [True: 25.0k, False: 91]
  ------------------
  423|  25.0k|    if (!strncmp(&buf[i], "startxref", 9)) {
  ------------------
  |  Branch (423:9): [True: 22, False: 24.9k]
  ------------------
  424|     22|      break;
  425|     22|    }
  426|  25.0k|  }
  427|    113|  if (i < 0) {
  ------------------
  |  Branch (427:7): [True: 91, False: 22]
  ------------------
  428|     91|    return 0;
  429|     91|  }
  430|     23|  for (p = &buf[i+9]; isspace(*p & 0xff); ++p) ;
  ------------------
  |  Branch (430:23): [True: 1, False: 22]
  ------------------
  431|     22|  lastXRefPos = strToFileOffset(p);
  432|     22|  lastStartxrefPos = str->getPos() - n + i;
  433|       |
  434|     22|  return lastXRefPos;
  435|    113|}
_ZN4XRef8readXRefEPlP10XRefPosSeti:
  441|     15|GBool XRef::readXRef(GFileOffset *pos, XRefPosSet *posSet, GBool hybrid) {
  442|     15|  Parser *parser;
  443|     15|  Object obj;
  444|     15|  GBool more;
  445|     15|  char buf[100];
  446|     15|  int n, i;
  447|       |
  448|       |  // check for a loop in the xref tables
  449|     15|  if (posSet->check(*pos)) {
  ------------------
  |  Branch (449:7): [True: 0, False: 15]
  ------------------
  450|      0|    error(errSyntaxWarning, -1, "Infinite loop in xref table");
  451|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  452|      0|  }
  453|     15|  posSet->add(*pos);
  454|       |
  455|       |  // the xref data should either be "xref ..." (for an xref table) or
  456|       |  // "nn gg obj << ... >> stream ..." (for an xref stream); possibly
  457|       |  // preceded by whitespace
  458|     15|  str->setPos(start + *pos);
  459|     15|  n = str->getBlock(buf, 100);
  460|     35|  for (i = 0; i < n && Lexer::isSpace(buf[i]); ++i) ;
  ------------------
  |  Branch (460:15): [True: 35, False: 0]
  |  Branch (460:24): [True: 20, False: 15]
  ------------------
  461|       |
  462|       |  // parse an old-style xref table
  463|     15|  if (!hybrid &&
  ------------------
  |  Branch (463:7): [True: 15, False: 0]
  ------------------
  464|     15|      i + 4 < n &&
  ------------------
  |  Branch (464:7): [True: 15, False: 0]
  ------------------
  465|     15|      buf[i] == 'x' && buf[i+1] == 'r' && buf[i+2] == 'e' && buf[i+3] == 'f' &&
  ------------------
  |  Branch (465:7): [True: 0, False: 15]
  |  Branch (465:24): [True: 0, False: 0]
  |  Branch (465:43): [True: 0, False: 0]
  |  Branch (465:62): [True: 0, False: 0]
  ------------------
  466|     15|      Lexer::isSpace(buf[i+4])) {
  ------------------
  |  Branch (466:7): [True: 0, False: 0]
  ------------------
  467|      0|    more = readXRefTable(pos, i + 5, posSet);
  468|       |
  469|       |  // parse an xref stream
  470|     15|  } else {
  471|     15|    obj.initNull();
  472|     15|    parser = new Parser(NULL,
  473|     15|	       new Lexer(NULL,
  474|     15|		 str->makeSubStream(start + *pos, gFalse, 0, &obj)),
  ------------------
  |  |   18|     15|#define gFalse 0
  ------------------
  475|     15|	       gTrue);
  ------------------
  |  |   17|     15|#define gTrue 1
  ------------------
  476|     15|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|     15|#define gTrue 1
  ------------------
  |  Branch (476:9): [True: 15, False: 0]
  ------------------
  477|     15|      goto err;
  478|     15|    }
  479|      0|    obj.free();
  480|      0|    if (!parser->getObj(&obj, gTrue)->isInt()) {
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  |  Branch (480:9): [True: 0, False: 0]
  ------------------
  481|      0|      goto err;
  482|      0|    }
  483|      0|    obj.free();
  484|      0|    if (!parser->getObj(&obj, gTrue)->isCmd("obj")) {
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  |  Branch (484:9): [True: 0, False: 0]
  ------------------
  485|      0|      goto err;
  486|      0|    }
  487|      0|    obj.free();
  488|      0|    if (!parser->getObj(&obj)->isStream()) {
  ------------------
  |  Branch (488:9): [True: 0, False: 0]
  ------------------
  489|      0|      goto err;
  490|      0|    }
  491|      0|    more = readXRefStream(obj.getStream(), pos, hybrid);
  492|      0|    obj.free();
  493|      0|    delete parser;
  494|      0|  }
  495|       |
  496|      0|  return more;
  497|       |
  498|     15| err:
  499|     15|  obj.free();
  500|     15|  delete parser;
  501|     15|  ok = gFalse;
  ------------------
  |  |   18|     15|#define gFalse 0
  ------------------
  502|     15|  return gFalse;
  ------------------
  |  |   18|     15|#define gFalse 0
  ------------------
  503|     15|}
_ZN4XRef13constructXRefEv:
  864|    113|GBool XRef::constructXRef() {
  865|    113|  int *streamObjNums = NULL;
  866|    113|  int streamObjNumsLen = 0;
  867|    113|  int streamObjNumsSize = 0;
  868|    113|  int lastObjNum = -1;
  869|    113|  rootNum = -1;
  870|    113|  int streamEndsSize = 0;
  871|    113|  streamEndsLen = 0;
  872|    113|  char buf[4096 + 1];
  873|    113|  str->reset();
  874|    113|  GFileOffset bufPos = start;
  875|    113|  char *p = buf;
  876|    113|  char *end = buf;
  877|    113|  GBool startOfLine = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  878|    113|  GBool space = gTrue;
  ------------------
  |  |   17|    113|#define gTrue 1
  ------------------
  879|    113|  GBool eof = gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  880|  34.3k|  while (1) {
  ------------------
  |  Branch (880:10): [Folded - Ignored]
  ------------------
  881|  34.3k|    if (end - p < 256 && !eof) {
  ------------------
  |  Branch (881:9): [True: 13.7k, False: 20.5k]
  |  Branch (881:26): [True: 113, False: 13.6k]
  ------------------
  882|    113|      memcpy(buf, p, end - p);
  883|    113|      bufPos += p - buf;
  884|    113|      p = buf + (end - p);
  885|    113|      int n = (int)(buf + 4096 - p);
  886|    113|      int m = str->getBlock(p, n);
  887|    113|      end = p + m;
  888|    113|      *end = '\0';
  889|    113|      p = buf;
  890|    113|      eof = m < n;
  891|    113|    }
  892|  34.3k|    if (p == end && eof) {
  ------------------
  |  Branch (892:9): [True: 113, False: 34.2k]
  |  Branch (892:21): [True: 113, False: 0]
  ------------------
  893|    113|      break;
  894|    113|    }
  895|  34.2k|    if (startOfLine && !strncmp(p, "trailer", 7)) {
  ------------------
  |  Branch (895:9): [True: 2.20k, False: 32.0k]
  |  Branch (895:24): [True: 0, False: 2.20k]
  ------------------
  896|      0|      constructTrailerDict((GFileOffset)(bufPos + (p + 7 - buf)));
  897|      0|      p += 7;
  898|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  899|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  900|  34.2k|    } else if (startOfLine && !strncmp(p, "endstream", 9)) {
  ------------------
  |  Branch (900:16): [True: 2.20k, False: 32.0k]
  |  Branch (900:31): [True: 0, False: 2.20k]
  ------------------
  901|      0|      if (streamEndsLen == streamEndsSize) {
  ------------------
  |  Branch (901:11): [True: 0, False: 0]
  ------------------
  902|      0|	streamEndsSize += 64;
  903|      0|	streamEnds = (GFileOffset *)greallocn(streamEnds, streamEndsSize,
  904|      0|					      sizeof(GFileOffset));
  905|      0|      }
  906|      0|      streamEnds[streamEndsLen++] = (GFileOffset)(bufPos + (p - buf));
  907|      0|      p += 9;
  908|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  909|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  910|  34.2k|    } else if (space && *p >= '0' && *p <= '9') {
  ------------------
  |  Branch (910:16): [True: 23.4k, False: 10.7k]
  |  Branch (910:25): [True: 637, False: 22.8k]
  |  Branch (910:38): [True: 390, False: 247]
  ------------------
  911|    390|      p = constructObjectEntry(p, (GFileOffset)(bufPos + (p - buf)),
  912|    390|			       &lastObjNum);
  913|    390|      startOfLine = gFalse;
  ------------------
  |  |   18|    390|#define gFalse 0
  ------------------
  914|    390|      space = gFalse;
  ------------------
  |  |   18|    390|#define gFalse 0
  ------------------
  915|  33.8k|    } else if (p[0] == '>' && p[1] == '>') {
  ------------------
  |  Branch (915:16): [True: 301, False: 33.5k]
  |  Branch (915:31): [True: 244, False: 57]
  ------------------
  916|    244|      p += 2;
  917|    244|      startOfLine = gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  918|    244|      space = gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  919|       |      // skip any PDF whitespace except for '\0'
  920|    244|      while (*p == '\t' || *p == '\n' || *p == '\x0c' ||
  ------------------
  |  Branch (920:14): [True: 0, False: 244]
  |  Branch (920:28): [True: 0, False: 244]
  |  Branch (920:42): [True: 0, False: 244]
  ------------------
  921|    244|	     *p == '\r' || *p == ' ') {
  ------------------
  |  Branch (921:7): [True: 0, False: 244]
  |  Branch (921:21): [True: 0, False: 244]
  ------------------
  922|      0|	if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (922:6): [True: 0, False: 0]
  |  Branch (922:20): [True: 0, False: 0]
  ------------------
  923|      0|	  startOfLine = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  924|      0|	}
  925|      0|	space = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  926|      0|	++p;
  927|      0|      }
  928|    244|      if (!strncmp(p, "stream", 6)) {
  ------------------
  |  Branch (928:11): [True: 0, False: 244]
  ------------------
  929|      0|	if (lastObjNum >= 0) {
  ------------------
  |  Branch (929:6): [True: 0, False: 0]
  ------------------
  930|      0|	  if (streamObjNumsLen == streamObjNumsSize) {
  ------------------
  |  Branch (930:8): [True: 0, False: 0]
  ------------------
  931|      0|	    streamObjNumsSize += 64;
  932|      0|	    streamObjNums = (int *)greallocn(streamObjNums, streamObjNumsSize,
  933|      0|					     sizeof(int));
  934|      0|	  }
  935|      0|	  streamObjNums[streamObjNumsLen++] = lastObjNum;
  936|      0|	}
  937|      0|	p += 6;
  938|      0|	startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  939|      0|	space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  940|      0|      }
  941|  33.5k|    } else {
  942|  33.5k|      if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (942:11): [True: 1.11k, False: 32.4k]
  |  Branch (942:25): [True: 57, False: 32.4k]
  ------------------
  943|  1.17k|	startOfLine = gTrue;
  ------------------
  |  |   17|  1.17k|#define gTrue 1
  ------------------
  944|  1.17k|	space = gTrue;
  ------------------
  |  |   17|  1.17k|#define gTrue 1
  ------------------
  945|  32.4k|      } else if (Lexer::isSpace(*p & 0xff)) {
  ------------------
  |  Branch (945:18): [True: 22.2k, False: 10.1k]
  ------------------
  946|  22.2k|	space = gTrue;
  ------------------
  |  |   17|  22.2k|#define gTrue 1
  ------------------
  947|  22.2k|      } else {
  948|  10.1k|	startOfLine = gFalse;
  ------------------
  |  |   18|  10.1k|#define gFalse 0
  ------------------
  949|  10.1k|	space = gFalse;
  ------------------
  |  |   18|  10.1k|#define gFalse 0
  ------------------
  950|  10.1k|      }
  951|  33.5k|      ++p;
  952|  33.5k|    }
  953|  34.2k|  }
  954|       |
  955|       |  // read each stream object, check for xref or object stream
  956|    113|  for (int i = 0; i < streamObjNumsLen; ++i) {
  ------------------
  |  Branch (956:19): [True: 0, False: 113]
  ------------------
  957|      0|    Object obj;
  958|      0|    fetch(streamObjNums[i], entries[streamObjNums[i]].gen, &obj);
  959|      0|    if (obj.isStream()) {
  ------------------
  |  Branch (959:9): [True: 0, False: 0]
  ------------------
  960|      0|      Dict *dict = obj.streamGetDict();
  961|      0|      Object type;
  962|      0|      dict->lookup("Type", &type);
  963|      0|      if (type.isName("XRef")) {
  ------------------
  |  Branch (963:11): [True: 0, False: 0]
  ------------------
  964|      0|	saveTrailerDict(dict, gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  965|      0|      } else if (type.isName("ObjStm")) {
  ------------------
  |  Branch (965:18): [True: 0, False: 0]
  ------------------
  966|      0|	constructObjectStreamEntries(&obj, streamObjNums[i]);
  967|      0|      }
  968|      0|      type.free();
  969|      0|    }
  970|      0|    obj.free();
  971|      0|  }
  972|       |
  973|    113|  gfree(streamObjNums);
  974|       |
  975|       |  // if the file is encrypted, then any objects fetched here will be
  976|       |  // incorrect (because decryption is not yet enabled), so clear the
  977|       |  // cache to avoid that problem
  978|  1.92k|  for (int i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  1.92k|#define xrefCacheSize 16
  ------------------
  |  Branch (978:19): [True: 1.80k, False: 113]
  ------------------
  979|  1.80k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (979:9): [True: 0, False: 1.80k]
  ------------------
  980|      0|      cache[i].obj.free();
  981|      0|      cache[i].num = -1;
  982|      0|    }
  983|  1.80k|  }
  984|       |
  985|    113|  if (rootNum < 0) {
  ------------------
  |  Branch (985:7): [True: 113, False: 0]
  ------------------
  986|    113|    error(errSyntaxError, -1, "Couldn't find trailer dictionary");
  987|    113|    return gFalse;
  ------------------
  |  |   18|    113|#define gFalse 0
  ------------------
  988|    113|  }
  989|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  990|    113|}
_ZN4XRef20constructObjectEntryEPclPi:
 1032|    390|char *XRef::constructObjectEntry(char *p, GFileOffset pos, int *objNum) {
 1033|       |  // we look for non-end-of-line space characters here, to deal with
 1034|       |  // situations like:
 1035|       |  //    nnn          <-- garbage digits on a line
 1036|       |  //    nnn nnn obj  <-- actual object
 1037|       |  // and we also ignore '\0' (because it's used to terminate the
 1038|       |  // buffer in this damage-scanning code)
 1039|    390|  int num = 0;
 1040|    474|  do {
 1041|    474|    num = (num * 10) + (*p - '0');
 1042|    474|    ++p;
 1043|    474|  } while (*p >= '0' && *p <= '9' && num < 100000000);
  ------------------
  |  Branch (1043:12): [True: 122, False: 352]
  |  Branch (1043:25): [True: 90, False: 32]
  |  Branch (1043:38): [True: 84, False: 6]
  ------------------
 1044|    390|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1044:7): [True: 390, False: 0]
  |  Branch (1044:21): [True: 390, False: 0]
  |  Branch (1044:37): [True: 389, False: 1]
  ------------------
 1045|    389|    return p;
 1046|    389|  }
 1047|      1|  do {
 1048|      1|    ++p;
 1049|      1|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1049:12): [True: 0, False: 1]
  |  Branch (1049:26): [True: 0, False: 1]
  |  Branch (1049:42): [True: 0, False: 1]
  ------------------
 1050|      1|  if (!(*p >= '0' && *p <= '9')) {
  ------------------
  |  Branch (1050:9): [True: 0, False: 1]
  |  Branch (1050:22): [True: 0, False: 0]
  ------------------
 1051|      1|    return p;
 1052|      1|  }
 1053|      0|  int gen = 0;
 1054|      0|  do {
 1055|      0|    gen = (gen * 10) + (*p - '0');
 1056|      0|    ++p;
 1057|      0|  } while (*p >= '0' && *p <= '9' && gen < 100000000);
  ------------------
  |  Branch (1057:12): [True: 0, False: 0]
  |  Branch (1057:25): [True: 0, False: 0]
  |  Branch (1057:38): [True: 0, False: 0]
  ------------------
 1058|      0|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1058:7): [True: 0, False: 0]
  |  Branch (1058:21): [True: 0, False: 0]
  |  Branch (1058:37): [True: 0, False: 0]
  ------------------
 1059|      0|    return p;
 1060|      0|  }
 1061|      0|  do {
 1062|      0|    ++p;
 1063|      0|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1063:12): [True: 0, False: 0]
  |  Branch (1063:26): [True: 0, False: 0]
  |  Branch (1063:42): [True: 0, False: 0]
  ------------------
 1064|      0|  if (strncmp(p, "obj", 3)) {
  ------------------
  |  Branch (1064:7): [True: 0, False: 0]
  ------------------
 1065|      0|    return p;
 1066|      0|  }
 1067|       |
 1068|      0|  if (constructXRefEntry(num, gen, pos - start, xrefEntryUncompressed)) {
  ------------------
  |  Branch (1068:7): [True: 0, False: 0]
  ------------------
 1069|      0|    *objNum = num;
 1070|      0|  }
 1071|       |
 1072|      0|  return p;
 1073|      0|}
_ZN4XRef15strToFileOffsetEPc:
 1435|     22|GFileOffset XRef::strToFileOffset(char *s) {
 1436|     22|  GFileOffset x, d;
 1437|     22|  char *p;
 1438|       |
 1439|     22|  x = 0;
 1440|     37|  for (p = s; *p && isdigit(*p & 0xff); ++p) {
  ------------------
  |  Branch (1440:15): [True: 31, False: 6]
  |  Branch (1440:21): [True: 15, False: 16]
  ------------------
 1441|     15|    d = *p - '0';
 1442|     15|    if (x > (GFILEOFFSET_MAX - d) / 10) {
  ------------------
  |  |  128|     15|#define GFILEOFFSET_MAX 0x7fffffffffffffffLL
  ------------------
  |  Branch (1442:9): [True: 0, False: 15]
  ------------------
 1443|      0|      break;
 1444|      0|    }
 1445|     15|    x = 10 * x + d;
 1446|     15|  }
 1447|     22|  return x;
 1448|     22|}
_ZN10XRefPosSet9getLengthEv:
   54|     15|  int getLength() { return len; }
_ZN10XRefPosSet3getEi:
   55|     15|  GFileOffset get(int idx) { return tab[idx]; }

_ZN4XRef4isOkEv:
   64|    226|  GBool isOk() { return ok; }
_ZN4XRef12getErrorCodeEv:
   67|    226|  int getErrorCode() { return errCode; }

