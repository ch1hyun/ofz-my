LLVMFuzzerTestOneInput:
   22|      4|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   23|      4|auto start_target = std::chrono::high_resolution_clock::now();
   24|      4|    FuzzedDataProvider fuzzed_data(data, size);
   25|       |
   26|       |    // Prepare the parameters for the function call
   27|       |    // Use ConsumeRandomLengthString for creating buffers
   28|      4|    std::string output_dev_data = fuzzed_data.ConsumeRandomLengthString(sizeof(OutputDev));
   29|      4|    if (output_dev_data.size() != sizeof(OutputDev)) {
  ------------------
  |  Branch (29:9): [True: 4, False: 0]
  ------------------
   30|      4|        return 0; // Invalid size, skip the test
   31|      4|    }
   32|      0|    OutputDev* output_dev = reinterpret_cast<OutputDev*>(output_dev_data.data());
   33|       |
   34|      0|    int page_start = fuzzed_data.ConsumeIntegral<int>();
   35|      0|    int page_end = fuzzed_data.ConsumeIntegral<int>();
   36|      0|    double x = fuzzed_data.ConsumeFloatingPoint<double>();
   37|      0|    double y = fuzzed_data.ConsumeFloatingPoint<double>();
   38|      0|    int flags = fuzzed_data.ConsumeIntegral<int>();
   39|       |    // Replacing GBool with a simple bool
   40|      0|    bool bool1 = fuzzed_data.ConsumeBool();
   41|      0|    bool bool2 = fuzzed_data.ConsumeBool();
   42|      0|    bool bool3 = fuzzed_data.ConsumeBool();
   43|       |    
   44|       |    // Create a pointer for the expected type
   45|      0|    std::string subroutine_data = fuzzed_data.ConsumeRandomLengthString(sizeof(void*)); // Adjusted to use void* size
   46|       |    // Cast to the correct function pointer type
   47|      0|    GBool (*subroutine_ptr)(void*) = reinterpret_cast<GBool (*)(void*)>(subroutine_data.data());
   48|       |
   49|       |    // Prepare a void pointer
   50|      0|    std::string user_data_string = fuzzed_data.ConsumeRandomLengthString(sizeof(void*));
   51|      0|    void* user_data = reinterpret_cast<void*>(user_data_string.data());
   52|       |
   53|       |    // Create a valid GString for the PDFDoc constructor
   54|      0|    GString *file_name = new GString("dummy.pdf"); // Use a dummy file name
   55|      0|    PDFDoc pdf_doc(file_name); // Use the constructor that takes a GString
   56|       |
   57|       |    // Call the function under test
   58|      0|	auto start_func = std::chrono::high_resolution_clock::now();
   59|      0|    pdf_doc.displayPages(output_dev, page_start, page_end, x, y, flags, bool1, bool2, bool3, subroutine_ptr, user_data);
   60|      0|	auto end_func = std::chrono::high_resolution_clock::now();
   61|       |
   62|       |    // Clean up
   63|      0|    delete file_name;
   64|      0|auto end_target = std::chrono::high_resolution_clock::now();
   65|      0|std::cout<<"Target runtime : "<<std::chrono::duration_cast<std::chrono::nanoseconds>(end_target-start_target).count()<<", Function runtime : "<<std::chrono::duration_cast<std::chrono::nanoseconds>(end_func - start_func).count()<<std::endl;
   66|       |
   67|      0|    return 0;
   68|      4|}

