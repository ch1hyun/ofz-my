LLVMFuzzerTestOneInput:
    5|     20|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    6|     20|    FuzzedDataProvider stream(data, size);
    7|       |
    8|       |    // Initialize parameters for PDFDoc::displayPageSlice
    9|     20|    OutputDev* outputDev = nullptr; // Initialize with a non-NULL value
   10|     20|    int param1 = stream.ConsumeIntegral<int>();
   11|     20|    double param2 = stream.ConsumeFloatingPoint<double>();
   12|     20|    double param3 = stream.ConsumeFloatingPoint<double>();
   13|     20|    int param4 = stream.ConsumeIntegral<int>();
   14|     20|    GBool param5 = stream.ConsumeBool();
   15|     20|    GBool param6 = stream.ConsumeBool();
   16|     20|    GBool param7 = stream.ConsumeBool();
   17|     20|    int param8 = stream.ConsumeIntegral<int>();
   18|     20|    int param9 = stream.ConsumeIntegral<int>();
   19|     20|    int param10 = stream.ConsumeIntegral<int>();
   20|     20|    int param11 = stream.ConsumeIntegral<int>();
   21|       |    // DW_TAG_subroutine_type* param12 = nullptr; // Initialize with a non-NULL value (commented out due to non-existent header file)
   22|     20|    void* param13 = nullptr; // Initialize with a non-NULL value
   23|       |
   24|       |    // Call the function-under-test
   25|     20|    PDFDoc pdfDoc("example.pdf"); // Assuming a filename is needed for PDFDoc creation
   26|       |    // pdfDoc.displayPageSlice(outputDev, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13); // Commented out due to non-existent type
   27|       |
   28|     20|    return 0;
   29|     20|}

_ZN7GStringC2Ev:
  129|     40|GString::GString() {
  130|     40|  s = NULL;
  131|     40|  resize(length = 0);
  132|     40|  s[0] = '\0';
  133|     40|}
_ZN7GStringC2EPKc:
  135|     20|GString::GString(const char *sA) {
  136|     20|  int n = (int)strlen(sA);
  137|       |
  138|     20|  s = NULL;
  139|     20|  resize(length = n);
  140|     20|  memcpy(s, sA, n + 1);
  141|     20|}
_ZN7GString7formatvEPKcP13__va_list_tag:
  196|     20|GString *GString::formatv(const char *fmt, va_list argList) {
  197|     20|  GString *s;
  198|       |
  199|     20|  s = new GString();
  200|     20|  s->appendfv(fmt, argList);
  201|     20|  return s;
  202|     20|}
_ZN7GStringD2Ev:
  204|     60|GString::~GString() {
  205|     60|  delete[] s;
  206|     60|}
_ZN7GString6appendEc:
  214|    640|GString *GString::append(char c) {
  215|    640|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 640]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|    640|  resize(length + 1);
  219|    640|  s[length++] = c;
  220|    640|  s[length] = '\0';
  221|    640|  return this;
  222|    640|}
_ZN7GString6appendEPKci:
  248|     60|GString *GString::append(const char *str, int lengthA) {
  249|     60|  if (lengthA < 0 || length > INT_MAX - lengthA) {
  ------------------
  |  Branch (249:7): [True: 0, False: 60]
  |  Branch (249:22): [True: 0, False: 60]
  ------------------
  250|      0|    gMemError("Integer overflow in GString::append()");
  251|      0|  }
  252|     60|  resize(length + lengthA);
  253|     60|  memcpy(s + length, str, lengthA);
  254|     60|  length += lengthA;
  255|     60|  s[length] = '\0';
  256|     60|  return this;
  257|     60|}
_ZN7GString8appendfvEPKcP13__va_list_tag:
  268|     20|GString *GString::appendfv(const char *fmt, va_list argList) {
  269|     20|  GStringFormatArg *args;
  270|     20|  int argsLen, argsSize;
  271|     20|  GStringFormatArg arg;
  272|     20|  int idx, width, prec;
  273|     20|  GBool reverseAlign, zeroFill;
  274|     20|  GStringFormatType ft;
  275|     20|  char buf[65];
  276|     20|  int len, i;
  277|     20|  const char *p0, *p1;
  278|     20|  const char *str;
  279|       |
  280|     20|  argsLen = 0;
  281|     20|  argsSize = 8;
  282|     20|  args = (GStringFormatArg *)gmallocn(argsSize, sizeof(GStringFormatArg));
  283|       |
  284|     20|  p0 = fmt;
  285|     80|  while (*p0) {
  ------------------
  |  Branch (285:10): [True: 60, False: 20]
  ------------------
  286|     60|    if (*p0 == '{') {
  ------------------
  |  Branch (286:9): [True: 20, False: 40]
  ------------------
  287|     20|      ++p0;
  288|     20|      if (*p0 == '{') {
  ------------------
  |  Branch (288:11): [True: 0, False: 20]
  ------------------
  289|      0|	++p0;
  290|      0|	append('{');
  291|     20|      } else {
  292|       |
  293|       |	// parse the format string
  294|     20|	if (!(*p0 >= '0' && *p0 <= '9')) {
  ------------------
  |  Branch (294:8): [True: 20, False: 0]
  |  Branch (294:22): [True: 20, False: 0]
  ------------------
  295|      0|	  break;
  296|      0|	}
  297|     20|	idx = *p0 - '0';
  298|     20|	for (++p0; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (298:13): [True: 20, False: 0]
  |  Branch (298:27): [True: 0, False: 20]
  ------------------
  299|      0|	  idx = 10 * idx + (*p0 - '0');
  300|      0|	}
  301|     20|	if (*p0 != ':') {
  ------------------
  |  Branch (301:6): [True: 0, False: 20]
  ------------------
  302|      0|	  break;
  303|      0|	}
  304|     20|	++p0;
  305|     20|	if (*p0 == '-') {
  ------------------
  |  Branch (305:6): [True: 0, False: 20]
  ------------------
  306|      0|	  reverseAlign = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  307|      0|	  ++p0;
  308|     20|	} else {
  309|     20|	  reverseAlign = gFalse;
  ------------------
  |  |   18|     20|#define gFalse 0
  ------------------
  310|     20|	}
  311|     20|	width = 0;
  312|     20|	zeroFill = *p0 == '0';
  313|     20|	for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (313:9): [True: 20, False: 0]
  |  Branch (313:23): [True: 0, False: 20]
  ------------------
  314|      0|	  width = 10 * width + (*p0 - '0');
  315|      0|	}
  316|     20|	if (width < 0) {
  ------------------
  |  Branch (316:6): [True: 0, False: 20]
  ------------------
  317|      0|	  width = 0;
  318|      0|	}
  319|     20|	if (*p0 == '.') {
  ------------------
  |  Branch (319:6): [True: 0, False: 20]
  ------------------
  320|      0|	  ++p0;
  321|      0|	  prec = 0;
  322|      0|	  for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  |  Branch (322:25): [True: 0, False: 0]
  ------------------
  323|      0|	    prec = 10 * prec + (*p0 - '0');
  324|      0|	  }
  325|     20|	} else {
  326|     20|	  prec = 0;
  327|     20|	}
  328|     20|	for (ft = (GStringFormatType)0;
  329|    580|	     formatStrings[ft];
  ------------------
  |  Branch (329:7): [True: 580, False: 0]
  ------------------
  330|    580|	     ft = (GStringFormatType)(ft + 1)) {
  331|    580|	  if (!strncmp(p0, formatStrings[ft], strlen(formatStrings[ft]))) {
  ------------------
  |  Branch (331:8): [True: 20, False: 560]
  ------------------
  332|     20|	    break;
  333|     20|	  }
  334|    580|	}
  335|     20|	if (!formatStrings[ft]) {
  ------------------
  |  Branch (335:6): [True: 0, False: 20]
  ------------------
  336|      0|	  break;
  337|      0|	}
  338|     20|	p0 += strlen(formatStrings[ft]);
  339|     20|	if (*p0 != '}') {
  ------------------
  |  Branch (339:6): [True: 0, False: 20]
  ------------------
  340|      0|	  break;
  341|      0|	}
  342|     20|	++p0;
  343|       |
  344|       |	// fetch the argument
  345|     20|	if (idx > argsLen) {
  ------------------
  |  Branch (345:6): [True: 0, False: 20]
  ------------------
  346|      0|	  break;
  347|      0|	}
  348|     20|	if (idx == argsLen) {
  ------------------
  |  Branch (348:6): [True: 20, False: 0]
  ------------------
  349|     20|	  if (argsLen == argsSize) {
  ------------------
  |  Branch (349:8): [True: 0, False: 20]
  ------------------
  350|      0|	    argsSize *= 2;
  351|      0|	    args = (GStringFormatArg *)greallocn(args, argsSize,
  352|      0|						 sizeof(GStringFormatArg));
  353|      0|	  }
  354|     20|	  switch (ft) {
  ------------------
  |  Branch (354:12): [True: 0, False: 20]
  ------------------
  355|      0|	  case fmtIntDecimal:
  ------------------
  |  Branch (355:4): [True: 0, False: 20]
  ------------------
  356|      0|	  case fmtIntHex:
  ------------------
  |  Branch (356:4): [True: 0, False: 20]
  ------------------
  357|      0|	  case fmtIntOctal:
  ------------------
  |  Branch (357:4): [True: 0, False: 20]
  ------------------
  358|      0|	  case fmtIntBinary:
  ------------------
  |  Branch (358:4): [True: 0, False: 20]
  ------------------
  359|      0|	  case fmtSpace:
  ------------------
  |  Branch (359:4): [True: 0, False: 20]
  ------------------
  360|      0|	    args[argsLen].i = va_arg(argList, int);
  361|      0|	    break;
  362|      0|	  case fmtUIntDecimal:
  ------------------
  |  Branch (362:4): [True: 0, False: 20]
  ------------------
  363|      0|	  case fmtUIntHex:
  ------------------
  |  Branch (363:4): [True: 0, False: 20]
  ------------------
  364|      0|	  case fmtUIntOctal:
  ------------------
  |  Branch (364:4): [True: 0, False: 20]
  ------------------
  365|      0|	  case fmtUIntBinary:
  ------------------
  |  Branch (365:4): [True: 0, False: 20]
  ------------------
  366|      0|	    args[argsLen].ui = va_arg(argList, Guint);
  367|      0|	    break;
  368|      0|	  case fmtLongDecimal:
  ------------------
  |  Branch (368:4): [True: 0, False: 20]
  ------------------
  369|      0|	  case fmtLongHex:
  ------------------
  |  Branch (369:4): [True: 0, False: 20]
  ------------------
  370|      0|	  case fmtLongOctal:
  ------------------
  |  Branch (370:4): [True: 0, False: 20]
  ------------------
  371|      0|	  case fmtLongBinary:
  ------------------
  |  Branch (371:4): [True: 0, False: 20]
  ------------------
  372|      0|	    args[argsLen].l = va_arg(argList, long);
  373|      0|	    break;
  374|      0|	  case fmtULongDecimal:
  ------------------
  |  Branch (374:4): [True: 0, False: 20]
  ------------------
  375|      0|	  case fmtULongHex:
  ------------------
  |  Branch (375:4): [True: 0, False: 20]
  ------------------
  376|      0|	  case fmtULongOctal:
  ------------------
  |  Branch (376:4): [True: 0, False: 20]
  ------------------
  377|      0|	  case fmtULongBinary:
  ------------------
  |  Branch (377:4): [True: 0, False: 20]
  ------------------
  378|      0|	    args[argsLen].ul = va_arg(argList, Gulong);
  379|      0|	    break;
  380|      0|#ifdef LLONG_MAX
  381|      0|	  case fmtLongLongDecimal:
  ------------------
  |  Branch (381:4): [True: 0, False: 20]
  ------------------
  382|      0|	  case fmtLongLongHex:
  ------------------
  |  Branch (382:4): [True: 0, False: 20]
  ------------------
  383|      0|	  case fmtLongLongOctal:
  ------------------
  |  Branch (383:4): [True: 0, False: 20]
  ------------------
  384|      0|	  case fmtLongLongBinary:
  ------------------
  |  Branch (384:4): [True: 0, False: 20]
  ------------------
  385|      0|	    args[argsLen].ll = va_arg(argList, long long);
  386|      0|	    break;
  387|      0|#endif
  388|      0|#ifdef ULLONG_MAX
  389|      0|	  case fmtULongLongDecimal:
  ------------------
  |  Branch (389:4): [True: 0, False: 20]
  ------------------
  390|      0|	  case fmtULongLongHex:
  ------------------
  |  Branch (390:4): [True: 0, False: 20]
  ------------------
  391|      0|	  case fmtULongLongOctal:
  ------------------
  |  Branch (391:4): [True: 0, False: 20]
  ------------------
  392|      0|	  case fmtULongLongBinary:
  ------------------
  |  Branch (392:4): [True: 0, False: 20]
  ------------------
  393|      0|	    args[argsLen].ull = va_arg(argList, unsigned long long);
  394|      0|	    break;
  395|      0|#endif
  396|      0|	  case fmtDouble:
  ------------------
  |  Branch (396:4): [True: 0, False: 20]
  ------------------
  397|      0|	  case fmtDoubleTrim:
  ------------------
  |  Branch (397:4): [True: 0, False: 20]
  ------------------
  398|      0|	    args[argsLen].f = va_arg(argList, double);
  399|      0|	    break;
  400|      0|	  case fmtChar:
  ------------------
  |  Branch (400:4): [True: 0, False: 20]
  ------------------
  401|      0|	    args[argsLen].c = (char)va_arg(argList, int);
  402|      0|	    break;
  403|      0|	  case fmtString:
  ------------------
  |  Branch (403:4): [True: 0, False: 20]
  ------------------
  404|      0|	    args[argsLen].s = va_arg(argList, char *);
  405|      0|	    break;
  406|     20|	  case fmtGString:
  ------------------
  |  Branch (406:4): [True: 20, False: 0]
  ------------------
  407|     20|	    args[argsLen].gs = va_arg(argList, GString *);
  408|     20|	    break;
  409|     20|	  }
  410|     20|	  ++argsLen;
  411|     20|	}
  412|       |
  413|       |	// format the argument
  414|     20|	arg = args[idx];
  415|     20|	str = NULL;
  416|     20|	len = 0;
  417|     20|	switch (ft) {
  ------------------
  |  Branch (417:10): [True: 0, False: 20]
  ------------------
  418|      0|	case fmtIntDecimal:
  ------------------
  |  Branch (418:2): [True: 0, False: 20]
  ------------------
  419|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  420|      0|	  break;
  421|      0|	case fmtIntHex:
  ------------------
  |  Branch (421:2): [True: 0, False: 20]
  ------------------
  422|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  423|      0|	  break;
  424|      0|	case fmtIntOctal:
  ------------------
  |  Branch (424:2): [True: 0, False: 20]
  ------------------
  425|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  426|      0|	  break;
  427|      0|	case fmtIntBinary:
  ------------------
  |  Branch (427:2): [True: 0, False: 20]
  ------------------
  428|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  429|      0|	  break;
  430|      0|	case fmtUIntDecimal:
  ------------------
  |  Branch (430:2): [True: 0, False: 20]
  ------------------
  431|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 10,
  432|      0|		     &str, &len);
  433|      0|	  break;
  434|      0|	case fmtUIntHex:
  ------------------
  |  Branch (434:2): [True: 0, False: 20]
  ------------------
  435|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 16,
  436|      0|		     &str, &len);
  437|      0|	  break;
  438|      0|	case fmtUIntOctal:
  ------------------
  |  Branch (438:2): [True: 0, False: 20]
  ------------------
  439|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  440|      0|	  break;
  441|      0|	case fmtUIntBinary:
  ------------------
  |  Branch (441:2): [True: 0, False: 20]
  ------------------
  442|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  443|      0|	  break;
  444|      0|	case fmtLongDecimal:
  ------------------
  |  Branch (444:2): [True: 0, False: 20]
  ------------------
  445|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  446|      0|	  break;
  447|      0|	case fmtLongHex:
  ------------------
  |  Branch (447:2): [True: 0, False: 20]
  ------------------
  448|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  449|      0|	  break;
  450|      0|	case fmtLongOctal:
  ------------------
  |  Branch (450:2): [True: 0, False: 20]
  ------------------
  451|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  452|      0|	  break;
  453|      0|	case fmtLongBinary:
  ------------------
  |  Branch (453:2): [True: 0, False: 20]
  ------------------
  454|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  455|      0|	  break;
  456|      0|	case fmtULongDecimal:
  ------------------
  |  Branch (456:2): [True: 0, False: 20]
  ------------------
  457|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 10,
  458|      0|		     &str, &len);
  459|      0|	  break;
  460|      0|	case fmtULongHex:
  ------------------
  |  Branch (460:2): [True: 0, False: 20]
  ------------------
  461|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 16,
  462|      0|		     &str, &len);
  463|      0|	  break;
  464|      0|	case fmtULongOctal:
  ------------------
  |  Branch (464:2): [True: 0, False: 20]
  ------------------
  465|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  466|      0|	  break;
  467|      0|	case fmtULongBinary:
  ------------------
  |  Branch (467:2): [True: 0, False: 20]
  ------------------
  468|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  469|      0|	  break;
  470|      0|#ifdef LLONG_MAX
  471|      0|	case fmtLongLongDecimal:
  ------------------
  |  Branch (471:2): [True: 0, False: 20]
  ------------------
  472|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  473|      0|	  break;
  474|      0|	case fmtLongLongHex:
  ------------------
  |  Branch (474:2): [True: 0, False: 20]
  ------------------
  475|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  476|      0|	  break;
  477|      0|	case fmtLongLongOctal:
  ------------------
  |  Branch (477:2): [True: 0, False: 20]
  ------------------
  478|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  479|      0|	  break;
  480|      0|	case fmtLongLongBinary:
  ------------------
  |  Branch (480:2): [True: 0, False: 20]
  ------------------
  481|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  482|      0|	  break;
  483|      0|#endif
  484|      0|#ifdef ULLONG_MAX
  485|      0|	case fmtULongLongDecimal:
  ------------------
  |  Branch (485:2): [True: 0, False: 20]
  ------------------
  486|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 10,
  487|      0|		     &str, &len);
  488|      0|	  break;
  489|      0|	case fmtULongLongHex:
  ------------------
  |  Branch (489:2): [True: 0, False: 20]
  ------------------
  490|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 16,
  491|      0|		     &str, &len);
  492|      0|	  break;
  493|      0|	case fmtULongLongOctal:
  ------------------
  |  Branch (493:2): [True: 0, False: 20]
  ------------------
  494|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 8,
  495|      0|		     &str, &len);
  496|      0|	  break;
  497|      0|	case fmtULongLongBinary:
  ------------------
  |  Branch (497:2): [True: 0, False: 20]
  ------------------
  498|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 2,
  499|      0|		     &str, &len);
  500|      0|	  break;
  501|      0|#endif
  502|      0|	case fmtDouble:
  ------------------
  |  Branch (502:2): [True: 0, False: 20]
  ------------------
  503|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gFalse, &str, &len);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  504|      0|	  break;
  505|      0|	case fmtDoubleTrim:
  ------------------
  |  Branch (505:2): [True: 0, False: 20]
  ------------------
  506|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gTrue, &str, &len);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  507|      0|	  break;
  508|      0|	case fmtChar:
  ------------------
  |  Branch (508:2): [True: 0, False: 20]
  ------------------
  509|      0|	  buf[0] = arg.c;
  510|      0|	  str = buf;
  511|      0|	  len = 1;
  512|      0|	  reverseAlign = !reverseAlign;
  513|      0|	  break;
  514|      0|	case fmtString:
  ------------------
  |  Branch (514:2): [True: 0, False: 20]
  ------------------
  515|      0|	  if (arg.s) {
  ------------------
  |  Branch (515:8): [True: 0, False: 0]
  ------------------
  516|      0|	    str = arg.s;
  517|      0|	    len = (int)strlen(str);
  518|      0|	  } else {
  519|      0|	    str = "(null)";
  520|      0|	    len = 6;
  521|      0|	  }
  522|      0|	  reverseAlign = !reverseAlign;
  523|      0|	  break;
  524|     20|	case fmtGString:
  ------------------
  |  Branch (524:2): [True: 20, False: 0]
  ------------------
  525|     20|	  if (arg.gs) {
  ------------------
  |  Branch (525:8): [True: 20, False: 0]
  ------------------
  526|     20|	    str = arg.gs->getCString();
  527|     20|	    len = arg.gs->getLength();
  528|     20|	  } else {
  529|      0|	    str = "(null)";
  530|      0|	    len = 6;
  531|      0|	  }
  532|     20|	  reverseAlign = !reverseAlign;
  533|     20|	  break;
  534|      0|	case fmtSpace:
  ------------------
  |  Branch (534:2): [True: 0, False: 20]
  ------------------
  535|      0|	  str = buf;
  536|      0|	  len = 0;
  537|      0|	  width = arg.i;
  538|      0|	  break;
  539|     20|	}
  540|       |
  541|       |	// append the formatted arg, handling width and alignment
  542|     20|	if (!reverseAlign && len < width) {
  ------------------
  |  Branch (542:6): [True: 0, False: 20]
  |  Branch (542:23): [True: 0, False: 0]
  ------------------
  543|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (543:18): [True: 0, False: 0]
  ------------------
  544|      0|	    append(' ');
  545|      0|	  }
  546|      0|	}
  547|     20|	append(str, len);
  548|     20|	if (reverseAlign && len < width) {
  ------------------
  |  Branch (548:6): [True: 20, False: 0]
  |  Branch (548:22): [True: 0, False: 20]
  ------------------
  549|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (549:18): [True: 0, False: 0]
  ------------------
  550|      0|	    append(' ');
  551|      0|	  }
  552|      0|	}
  553|     20|      }
  554|       |
  555|     40|    } else if (*p0 == '}') {
  ------------------
  |  Branch (555:16): [True: 0, False: 40]
  ------------------
  556|      0|      ++p0;
  557|      0|      if (*p0 == '}') {
  ------------------
  |  Branch (557:11): [True: 0, False: 0]
  ------------------
  558|      0|	++p0;
  559|      0|      }
  560|      0|      append('}');
  561|       |      
  562|     40|    } else {
  563|    420|      for (p1 = p0 + 1; *p1 && *p1 != '{' && *p1 != '}'; ++p1) ;
  ------------------
  |  Branch (563:25): [True: 400, False: 20]
  |  Branch (563:32): [True: 380, False: 20]
  |  Branch (563:46): [True: 380, False: 0]
  ------------------
  564|     40|      append(p0, (int)(p1 - p0));
  565|     40|      p0 = p1;
  566|     40|    }
  567|     60|  }
  568|       |
  569|     20|  gfree(args);
  570|     20|  return this;
  571|     20|}
_ZN7GString6resizeEi:
  108|    760|inline void GString::resize(int length1) {
  109|    760|  char *s1;
  110|       |
  111|    760|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 760]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|    760|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 60, False: 700]
  ------------------
  115|     60|    s = new char[size(length1)];
  116|    700|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 100, False: 600]
  ------------------
  117|    100|    s1 = new char[size(length1)];
  118|    100|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 100]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|    100|    } else {
  122|    100|      memcpy(s1, s, length + 1);
  123|    100|    }
  124|    100|    delete[] s;
  125|    100|    s = s1;
  126|    100|  }
  127|    760|}
GString.cc:_ZL4sizei:
   98|  1.56k|static inline int size(int len) {
   99|  1.56k|  int delta;
  100|  3.48k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 1.92k, False: 1.56k]
  |  Branch (100:34): [True: 1.92k, False: 0]
  ------------------
  101|  1.56k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 1.56k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|  1.56k|  return (len + delta) & ~(delta - 1);
  106|  1.56k|}

_ZN7GString9getLengthEv:
   76|    680|  int getLength() { return length; }
_ZN7GString10getCStringEv:
   79|     60|  char *getCString() { return s; }
_ZN7GString7getCharEi:
   82|    640|  char getChar(int i) { return s[i]; }

_Z7gmalloci:
  139|     20|void *gmalloc(int size) GMEM_EXCEP {
  140|     20|  void *p;
  141|       |
  142|     20|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 20]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|     20|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 20]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|     20|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 20]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|     20|  return p;
  152|     20|}
_Z8gmallocnii:
  204|     20|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|     20|  int n;
  206|       |
  207|     20|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 20]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|     20|  n = nObjs * objSize;
  211|     20|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 20]
  |  Branch (211:23): [True: 0, False: 20]
  |  Branch (211:36): [True: 0, False: 20]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|     20|  return gmalloc(n);
  215|     20|}
_Z5gfreePv:
  307|     20|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|     20|  if (p) {
  ------------------
  |  Branch (348:7): [True: 20, False: 0]
  ------------------
  349|     20|    free(p);
  350|     20|  }
  351|     20|#endif
  352|     20|}

_Z5error13ErrorCategorylPKcz:
   46|     20|		 const char *msg, ...) {
   47|     20|  va_list args;
   48|     20|  GString *s, *sanitized;
   49|     20|  char c;
   50|     20|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|     20|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 20, False: 0]
  |  Branch (53:20): [True: 0, False: 20]
  |  Branch (53:36): [True: 0, False: 0]
  ------------------
   54|      0|    return;
   55|      0|  }
   56|     20|  va_start(args, msg);
   57|     20|  s = GString::formatv(msg, args);
   58|     20|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|     20|  sanitized = new GString();
   63|    660|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 640, False: 20]
  ------------------
   64|    640|    c = s->getChar(i);
   65|    640|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 640, False: 0]
  |  Branch (65:22): [True: 640, False: 0]
  ------------------
   66|    640|      sanitized->append(c);
   67|    640|    } else {
   68|      0|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|      0|    }
   70|    640|  }
   71|       |
   72|     20|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 20]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|     20|  } else {
   75|     20|    fflush(stdout);
   76|     20|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 20]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|     20|    } else {
   80|     20|      fprintf(stderr, "%s: %s\n",
   81|     20|	      errorCategoryNames[category], sanitized->getCString());
   82|     20|    }
   83|     20|    fflush(stderr);
   84|     20|  }
   85|       |
   86|     20|  delete s;
   87|     20|  delete sanitized;
   88|     20|}

_ZN6ObjectC2Ev:
   85|     20|    type(objNone) {}

_ZN6PDFDocC2EPcP7GStringS2_P7PDFCore:
  163|     20|	       GString *userPassword, PDFCore *coreA) {
  164|       |#ifdef _WIN32
  165|       |  OSVERSIONINFO version;
  166|       |#endif
  167|     20|  Object obj;
  168|       |#ifdef _WIN32
  169|       |  Unicode u;
  170|       |  int i, j;
  171|       |#endif
  172|       |
  173|     20|  init(coreA);
  174|       |
  175|     20|  fileName = new GString(fileNameA);
  176|       |
  177|       |#if defined(_WIN32)
  178|       |  wchar_t wPath[winMaxLongPath + 1];
  179|       |  i = 0;
  180|       |  j = 0;
  181|       |  while (j < winMaxLongPath && getUTF8(fileName, &i, &u)) {
  182|       |    wPath[j++] = (wchar_t)u;
  183|       |  }
  184|       |  wPath[j] = L'\0';
  185|       |  readWindowsShortcut(wPath, winMaxLongPath + 1);
  186|       |  int wPathLen = (int)wcslen(wPath);
  187|       |
  188|       |  fileNameU = (wchar_t *)gmallocn(wPathLen + 1, sizeof(wchar_t));
  189|       |  memcpy(fileNameU, wPath, (wPathLen + 1) * sizeof(wchar_t));
  190|       |
  191|       |  // NB: _wfopen is only available in NT
  192|       |  version.dwOSVersionInfoSize = sizeof(version);
  193|       |  GetVersionEx(&version);
  194|       |  if (version.dwPlatformId == VER_PLATFORM_WIN32_NT) {
  195|       |    file = _wfopen(fileNameU, wfopenReadMode);
  196|       |  } else {
  197|       |    file = fopen(fileName->getCString(), fopenReadMode);
  198|       |  }
  199|       |#elif defined(VMS)
  200|       |  file = fopen(fileName->getCString(), fopenReadMode, "ctx=stm");
  201|       |#else
  202|     20|  file = fopen(fileName->getCString(), fopenReadMode);
  ------------------
  |  |   53|     20|#  define fopenReadMode "rb"
  ------------------
  203|     20|#endif
  204|       |
  205|     20|  if (!file) {
  ------------------
  |  Branch (205:7): [True: 20, False: 0]
  ------------------
  206|     20|    error(errIO, -1, "Couldn't open file '{0:t}'", fileName);
  207|     20|    errCode = errOpenFile;
  ------------------
  |  |   14|     20|#define errOpenFile         1	// couldn't open the PDF file
  ------------------
  208|     20|    return;
  209|     20|  }
  210|       |
  211|       |  // create stream
  212|      0|  obj.initNull();
  213|      0|  str = new FileStream(file, 0, gFalse, 0, &obj);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  214|       |
  215|      0|  ok = setup(ownerPassword, userPassword);
  216|      0|}
_ZN6PDFDoc4initEP7PDFCore:
  246|     20|void PDFDoc::init(PDFCore *coreA) {
  247|     20|  ok = gFalse;
  ------------------
  |  |   18|     20|#define gFalse 0
  ------------------
  248|     20|  errCode = errNone;
  ------------------
  |  |   12|     20|#define errNone             0	// no error
  ------------------
  249|     20|  core = coreA;
  250|     20|  file = NULL;
  251|     20|  str = NULL;
  252|     20|  xref = NULL;
  253|     20|  catalog = NULL;
  254|     20|  annots = NULL;
  255|     20|#ifndef DISABLE_OUTLINE
  256|     20|  outline = NULL;
  257|     20|#endif
  258|     20|  optContent = NULL;
  259|     20|}
_ZN6PDFDocD2Ev:
  333|     20|PDFDoc::~PDFDoc() {
  334|     20|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 20]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|     20|#ifndef DISABLE_OUTLINE
  338|     20|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 20]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|     20|#endif
  342|     20|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 20]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|     20|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 20]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|     20|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 20]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|     20|  if (str) {
  ------------------
  |  Branch (351:7): [True: 0, False: 20]
  ------------------
  352|      0|    delete str;
  353|      0|  }
  354|     20|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 20]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|     20|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 20, False: 0]
  ------------------
  358|     20|    delete fileName;
  359|     20|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|     20|}

