LLVMFuzzerTestOneInput:
   17|     13|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   18|     13|    printf("Hello World!\n");
   19|     13|    if (size < 1) {
  ------------------
  |  Branch (19:9): [True: 0, False: 13]
  ------------------
   20|      0|        return 0;
   21|      0|    }
   22|       |
   23|     13|    FuzzedDataProvider stream(data, size);
   24|       |
   25|     13|    double hdpi = stream.ConsumeFloatingPoint<double>();
   26|     13|    double vdpi = stream.ConsumeFloatingPoint<double>();
   27|     13|    int rotate = stream.ConsumeIntegralInRange<int>(0, 360);
   28|       |
   29|     13|    globalParams = new GlobalParams(NULL);
   30|     13|    globalParams->setupBaseFonts(NULL);
   31|       |
   32|     13|    GString *password = new GString("password");
   33|     13|    GString *ownerPassword = new GString("ownerPassword");
   34|     13|    PDFDoc *doc = new PDFDoc(new GString("dummy.pdf"), password, ownerPassword);
   35|     13|    PDFRectangle pageBox;
   36|     13|    GfxState *state = new GfxState(72.0, 72.0, &pageBox, rotate, gFalse);
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   37|       |
   38|     13|    SplashColor paperColor = {0, 0, 0, 0};
   39|     13|    SplashOutputDev *splashOut = new SplashOutputDev(splashModeMono1, 1, gFalse, paperColor);
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   40|       |    
   41|       |    // Since 'doUpdateFont' is a private member of 'SplashOutputDev', we can't directly call it.
   42|       |    // We can try to call a public method that internally uses 'doUpdateFont'.
   43|     13|    splashOut->drawChar(state, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
   44|       |
   45|     13|    delete splashOut;
   46|     13|    delete doc;
   47|     13|    delete globalParams;
   48|     13|    delete password;
   49|     13|    delete ownerPassword;
   50|       |
   51|     13|    return 0;
   52|     13|}

_ZN5GHashC2Ei:
   34|    143|GHash::GHash(GBool deleteKeysA) {
   35|    143|  int h;
   36|       |
   37|    143|  deleteKeys = deleteKeysA;
   38|    143|  size = 7;
   39|    143|  tab = (GHashBucket **)gmallocn(size, sizeof(GHashBucket *));
   40|  1.14k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (40:15): [True: 1.00k, False: 143]
  ------------------
   41|  1.00k|    tab[h] = NULL;
   42|  1.00k|  }
   43|    143|  len = 0;
   44|    143|}
_ZN5GHashD2Ev:
   46|    143|GHash::~GHash() {
   47|    143|  GHashBucket *p;
   48|    143|  int h;
   49|       |
   50|  1.14k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (50:15): [True: 1.00k, False: 143]
  ------------------
   51|  1.09k|    while (tab[h]) {
  ------------------
  |  Branch (51:12): [True: 91, False: 1.00k]
  ------------------
   52|     91|      p = tab[h];
   53|     91|      tab[h] = p->next;
   54|     91|      if (deleteKeys) {
  ------------------
  |  Branch (54:11): [True: 13, False: 78]
  ------------------
   55|     13|	delete p->key;
   56|     13|      }
   57|     91|      delete p;
   58|     91|    }
   59|  1.00k|  }
   60|    143|  gfree(tab);
   61|    143|}
_ZN5GHash3addEP7GStringPv:
   63|     91|void GHash::add(GString *key, void *val) {
   64|     91|  GHashBucket *p;
   65|     91|  int h;
   66|       |
   67|       |  // expand the table if necessary
   68|     91|  if (len >= size) {
  ------------------
  |  Branch (68:7): [True: 0, False: 91]
  ------------------
   69|      0|    expand();
   70|      0|  }
   71|       |
   72|       |  // add the new symbol
   73|     91|  p = new GHashBucket;
   74|     91|  p->key = key;
   75|     91|  p->val.p = val;
   76|     91|  h = hash(key);
   77|     91|  p->next = tab[h];
   78|     91|  tab[h] = p;
   79|     91|  ++len;
   80|     91|}
_ZN5GHash6lookupEPKc:
  149|    598|void *GHash::lookup(const char *key) {
  150|    598|  GHashBucket *p;
  151|    598|  int h;
  152|       |
  153|    598|  if (!(p = find(key, &h))) {
  ------------------
  |  Branch (153:7): [True: 598, False: 0]
  ------------------
  154|    598|    return NULL;
  155|    598|  }
  156|      0|  return p->val.p;
  157|    598|}
_ZN5GHash9startIterEPP9GHashIter:
  261|    130|void GHash::startIter(GHashIter **iter) {
  262|    130|  *iter = new GHashIter;
  263|    130|  (*iter)->h = -1;
  264|    130|  (*iter)->p = NULL;
  265|    130|}
_ZN5GHash7getNextEPP9GHashIterPP7GStringPPv:
  267|    221|GBool GHash::getNext(GHashIter **iter, GString **key, void **val) {
  268|    221|  if (!*iter) {
  ------------------
  |  Branch (268:7): [True: 0, False: 221]
  ------------------
  269|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  270|      0|  }
  271|    221|  if ((*iter)->p) {
  ------------------
  |  Branch (271:7): [True: 91, False: 130]
  ------------------
  272|     91|    (*iter)->p = (*iter)->p->next;
  273|     91|  }
  274|  1.13k|  while (!(*iter)->p) {
  ------------------
  |  Branch (274:10): [True: 1.04k, False: 91]
  ------------------
  275|  1.04k|    if (++(*iter)->h == size) {
  ------------------
  |  Branch (275:9): [True: 130, False: 910]
  ------------------
  276|    130|      delete *iter;
  277|    130|      *iter = NULL;
  278|    130|      return gFalse;
  ------------------
  |  |   18|    130|#define gFalse 0
  ------------------
  279|    130|    }
  280|    910|    (*iter)->p = tab[(*iter)->h];
  281|    910|  }
  282|     91|  *key = (*iter)->p->key;
  283|     91|  *val = (*iter)->p->val.p;
  284|     91|  return gTrue;
  ------------------
  |  |   17|     91|#define gTrue 1
  ------------------
  285|    221|}
_ZN5GHash4findEPKcPi:
  348|    598|GHashBucket *GHash::find(const char *key, int *h) {
  349|    598|  GHashBucket *p;
  350|       |
  351|    598|  *h = hash(key);
  352|    598|  for (p = tab[*h]; p; p = p->next) {
  ------------------
  |  Branch (352:21): [True: 0, False: 598]
  ------------------
  353|      0|    if (!p->key->cmp(key)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 0]
  ------------------
  354|      0|      return p;
  355|      0|    }
  356|      0|  }
  357|    598|  return NULL;
  358|    598|}
_ZN5GHash4hashEP7GString:
  360|     91|int GHash::hash(GString *key) {
  361|     91|  const char *p;
  362|     91|  unsigned int h;
  363|     91|  int i;
  364|       |
  365|     91|  h = 0;
  366|    702|  for (p = key->getCString(), i = 0; i < key->getLength(); ++p, ++i) {
  ------------------
  |  Branch (366:38): [True: 611, False: 91]
  ------------------
  367|    611|    h = 17 * h + (int)(*p & 0xff);
  368|    611|  }
  369|     91|  return (int)(h % size);
  370|     91|}
_ZN5GHash4hashEPKc:
  372|    598|int GHash::hash(const char *key) {
  373|    598|  const char *p;
  374|    598|  unsigned int h;
  375|       |
  376|    598|  h = 0;
  377|  8.20k|  for (p = key; *p; ++p) {
  ------------------
  |  Branch (377:17): [True: 7.60k, False: 598]
  ------------------
  378|  7.60k|    h = 17 * h + (int)(*p & 0xff);
  379|  7.60k|  }
  380|    598|  return (int)(h % size);
  381|    598|}

_ZN5GListC2Ev:
   21|    897|GList::GList() {
   22|    897|  size = 8;
   23|    897|  data = (void **)gmallocn(size, sizeof(void*));
   24|    897|  length = 0;
   25|    897|  inc = 0;
   26|    897|}
_ZN5GListD2Ev:
   35|    897|GList::~GList() {
   36|    897|  gfree(data);
   37|    897|}
_ZN5GList6appendEPv:
   49|  1.75k|void GList::append(void *p) {
   50|  1.75k|  if (length >= size) {
  ------------------
  |  Branch (50:7): [True: 52, False: 1.70k]
  ------------------
   51|     52|    expand();
   52|     52|  }
   53|  1.75k|  data[length++] = p;
   54|  1.75k|}
_ZN5GList6expandEv:
  116|     52|void GList::expand() {
  117|     52|  size += (inc > 0) ? inc : size;
  ------------------
  |  Branch (117:11): [True: 0, False: 52]
  ------------------
  118|     52|  data = (void **)greallocn(data, size, sizeof(void*));
  119|     52|}

_ZN5GList9getLengthEv:
   35|  2.65k|  int getLength() { return length; }
_ZN5GList3getEi:
   44|  1.75k|  void *get(int i) { return data[i]; }

_ZN7GStringC2Ev:
  129|    390|GString::GString() {
  130|    390|  s = NULL;
  131|    390|  resize(length = 0);
  132|    390|  s[0] = '\0';
  133|    390|}
_ZN7GStringC2EPKc:
  135|  2.37k|GString::GString(const char *sA) {
  136|  2.37k|  int n = (int)strlen(sA);
  137|       |
  138|  2.37k|  s = NULL;
  139|  2.37k|  resize(length = n);
  140|  2.37k|  memcpy(s, sA, n + 1);
  141|  2.37k|}
_ZN7GStringC2EPS_:
  157|     13|GString::GString(GString *str) {
  158|     13|  s = NULL;
  159|     13|  resize(length = str->getLength());
  160|     13|  memcpy(s, str->getCString(), length + 1);
  161|     13|}
_ZN7GString7formatvEPKcP13__va_list_tag:
  196|    195|GString *GString::formatv(const char *fmt, va_list argList) {
  197|    195|  GString *s;
  198|       |
  199|    195|  s = new GString();
  200|    195|  s->appendfv(fmt, argList);
  201|    195|  return s;
  202|    195|}
_ZN7GStringD2Ev:
  204|  2.78k|GString::~GString() {
  205|  2.78k|  delete[] s;
  206|  2.78k|}
_ZN7GString6appendEc:
  214|  7.72k|GString *GString::append(char c) {
  215|  7.72k|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 7.72k]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|  7.72k|  resize(length + 1);
  219|  7.72k|  s[length++] = c;
  220|  7.72k|  s[length] = '\0';
  221|  7.72k|  return this;
  222|  7.72k|}
_ZN7GString6appendEPKc:
  236|    975|GString *GString::append(const char *str) {
  237|    975|  int n = (int)strlen(str);
  238|       |
  239|    975|  if (length > INT_MAX - n) {
  ------------------
  |  Branch (239:7): [True: 0, False: 975]
  ------------------
  240|      0|    gMemError("Integer overflow in GString::append()");
  241|      0|  }
  242|    975|  resize(length + n);
  243|    975|  memcpy(s + length, str, n + 1);
  244|    975|  length += n;
  245|    975|  return this;
  246|    975|}
_ZN7GString6appendEPKci:
  248|    585|GString *GString::append(const char *str, int lengthA) {
  249|    585|  if (lengthA < 0 || length > INT_MAX - lengthA) {
  ------------------
  |  Branch (249:7): [True: 0, False: 585]
  |  Branch (249:22): [True: 0, False: 585]
  ------------------
  250|      0|    gMemError("Integer overflow in GString::append()");
  251|      0|  }
  252|    585|  resize(length + lengthA);
  253|    585|  memcpy(s + length, str, lengthA);
  254|    585|  length += lengthA;
  255|    585|  s[length] = '\0';
  256|    585|  return this;
  257|    585|}
_ZN7GString8appendfvEPKcP13__va_list_tag:
  268|    195|GString *GString::appendfv(const char *fmt, va_list argList) {
  269|    195|  GStringFormatArg *args;
  270|    195|  int argsLen, argsSize;
  271|    195|  GStringFormatArg arg;
  272|    195|  int idx, width, prec;
  273|    195|  GBool reverseAlign, zeroFill;
  274|    195|  GStringFormatType ft;
  275|    195|  char buf[65];
  276|    195|  int len, i;
  277|    195|  const char *p0, *p1;
  278|    195|  const char *str;
  279|       |
  280|    195|  argsLen = 0;
  281|    195|  argsSize = 8;
  282|    195|  args = (GStringFormatArg *)gmallocn(argsSize, sizeof(GStringFormatArg));
  283|       |
  284|    195|  p0 = fmt;
  285|    780|  while (*p0) {
  ------------------
  |  Branch (285:10): [True: 585, False: 195]
  ------------------
  286|    585|    if (*p0 == '{') {
  ------------------
  |  Branch (286:9): [True: 195, False: 390]
  ------------------
  287|    195|      ++p0;
  288|    195|      if (*p0 == '{') {
  ------------------
  |  Branch (288:11): [True: 0, False: 195]
  ------------------
  289|      0|	++p0;
  290|      0|	append('{');
  291|    195|      } else {
  292|       |
  293|       |	// parse the format string
  294|    195|	if (!(*p0 >= '0' && *p0 <= '9')) {
  ------------------
  |  Branch (294:8): [True: 195, False: 0]
  |  Branch (294:22): [True: 195, False: 0]
  ------------------
  295|      0|	  break;
  296|      0|	}
  297|    195|	idx = *p0 - '0';
  298|    195|	for (++p0; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (298:13): [True: 195, False: 0]
  |  Branch (298:27): [True: 0, False: 195]
  ------------------
  299|      0|	  idx = 10 * idx + (*p0 - '0');
  300|      0|	}
  301|    195|	if (*p0 != ':') {
  ------------------
  |  Branch (301:6): [True: 0, False: 195]
  ------------------
  302|      0|	  break;
  303|      0|	}
  304|    195|	++p0;
  305|    195|	if (*p0 == '-') {
  ------------------
  |  Branch (305:6): [True: 0, False: 195]
  ------------------
  306|      0|	  reverseAlign = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  307|      0|	  ++p0;
  308|    195|	} else {
  309|    195|	  reverseAlign = gFalse;
  ------------------
  |  |   18|    195|#define gFalse 0
  ------------------
  310|    195|	}
  311|    195|	width = 0;
  312|    195|	zeroFill = *p0 == '0';
  313|    195|	for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (313:9): [True: 195, False: 0]
  |  Branch (313:23): [True: 0, False: 195]
  ------------------
  314|      0|	  width = 10 * width + (*p0 - '0');
  315|      0|	}
  316|    195|	if (width < 0) {
  ------------------
  |  Branch (316:6): [True: 0, False: 195]
  ------------------
  317|      0|	  width = 0;
  318|      0|	}
  319|    195|	if (*p0 == '.') {
  ------------------
  |  Branch (319:6): [True: 0, False: 195]
  ------------------
  320|      0|	  ++p0;
  321|      0|	  prec = 0;
  322|      0|	  for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  |  Branch (322:25): [True: 0, False: 0]
  ------------------
  323|      0|	    prec = 10 * prec + (*p0 - '0');
  324|      0|	  }
  325|    195|	} else {
  326|    195|	  prec = 0;
  327|    195|	}
  328|    195|	for (ft = (GStringFormatType)0;
  329|  5.47k|	     formatStrings[ft];
  ------------------
  |  Branch (329:7): [True: 5.47k, False: 0]
  ------------------
  330|  5.47k|	     ft = (GStringFormatType)(ft + 1)) {
  331|  5.47k|	  if (!strncmp(p0, formatStrings[ft], strlen(formatStrings[ft]))) {
  ------------------
  |  Branch (331:8): [True: 195, False: 5.27k]
  ------------------
  332|    195|	    break;
  333|    195|	  }
  334|  5.47k|	}
  335|    195|	if (!formatStrings[ft]) {
  ------------------
  |  Branch (335:6): [True: 0, False: 195]
  ------------------
  336|      0|	  break;
  337|      0|	}
  338|    195|	p0 += strlen(formatStrings[ft]);
  339|    195|	if (*p0 != '}') {
  ------------------
  |  Branch (339:6): [True: 0, False: 195]
  ------------------
  340|      0|	  break;
  341|      0|	}
  342|    195|	++p0;
  343|       |
  344|       |	// fetch the argument
  345|    195|	if (idx > argsLen) {
  ------------------
  |  Branch (345:6): [True: 0, False: 195]
  ------------------
  346|      0|	  break;
  347|      0|	}
  348|    195|	if (idx == argsLen) {
  ------------------
  |  Branch (348:6): [True: 195, False: 0]
  ------------------
  349|    195|	  if (argsLen == argsSize) {
  ------------------
  |  Branch (349:8): [True: 0, False: 195]
  ------------------
  350|      0|	    argsSize *= 2;
  351|      0|	    args = (GStringFormatArg *)greallocn(args, argsSize,
  352|      0|						 sizeof(GStringFormatArg));
  353|      0|	  }
  354|    195|	  switch (ft) {
  ------------------
  |  Branch (354:12): [True: 0, False: 195]
  ------------------
  355|      0|	  case fmtIntDecimal:
  ------------------
  |  Branch (355:4): [True: 0, False: 195]
  ------------------
  356|      0|	  case fmtIntHex:
  ------------------
  |  Branch (356:4): [True: 0, False: 195]
  ------------------
  357|      0|	  case fmtIntOctal:
  ------------------
  |  Branch (357:4): [True: 0, False: 195]
  ------------------
  358|      0|	  case fmtIntBinary:
  ------------------
  |  Branch (358:4): [True: 0, False: 195]
  ------------------
  359|      0|	  case fmtSpace:
  ------------------
  |  Branch (359:4): [True: 0, False: 195]
  ------------------
  360|      0|	    args[argsLen].i = va_arg(argList, int);
  361|      0|	    break;
  362|      0|	  case fmtUIntDecimal:
  ------------------
  |  Branch (362:4): [True: 0, False: 195]
  ------------------
  363|      0|	  case fmtUIntHex:
  ------------------
  |  Branch (363:4): [True: 0, False: 195]
  ------------------
  364|      0|	  case fmtUIntOctal:
  ------------------
  |  Branch (364:4): [True: 0, False: 195]
  ------------------
  365|      0|	  case fmtUIntBinary:
  ------------------
  |  Branch (365:4): [True: 0, False: 195]
  ------------------
  366|      0|	    args[argsLen].ui = va_arg(argList, Guint);
  367|      0|	    break;
  368|      0|	  case fmtLongDecimal:
  ------------------
  |  Branch (368:4): [True: 0, False: 195]
  ------------------
  369|      0|	  case fmtLongHex:
  ------------------
  |  Branch (369:4): [True: 0, False: 195]
  ------------------
  370|      0|	  case fmtLongOctal:
  ------------------
  |  Branch (370:4): [True: 0, False: 195]
  ------------------
  371|      0|	  case fmtLongBinary:
  ------------------
  |  Branch (371:4): [True: 0, False: 195]
  ------------------
  372|      0|	    args[argsLen].l = va_arg(argList, long);
  373|      0|	    break;
  374|      0|	  case fmtULongDecimal:
  ------------------
  |  Branch (374:4): [True: 0, False: 195]
  ------------------
  375|      0|	  case fmtULongHex:
  ------------------
  |  Branch (375:4): [True: 0, False: 195]
  ------------------
  376|      0|	  case fmtULongOctal:
  ------------------
  |  Branch (376:4): [True: 0, False: 195]
  ------------------
  377|      0|	  case fmtULongBinary:
  ------------------
  |  Branch (377:4): [True: 0, False: 195]
  ------------------
  378|      0|	    args[argsLen].ul = va_arg(argList, Gulong);
  379|      0|	    break;
  380|      0|#ifdef LLONG_MAX
  381|      0|	  case fmtLongLongDecimal:
  ------------------
  |  Branch (381:4): [True: 0, False: 195]
  ------------------
  382|      0|	  case fmtLongLongHex:
  ------------------
  |  Branch (382:4): [True: 0, False: 195]
  ------------------
  383|      0|	  case fmtLongLongOctal:
  ------------------
  |  Branch (383:4): [True: 0, False: 195]
  ------------------
  384|      0|	  case fmtLongLongBinary:
  ------------------
  |  Branch (384:4): [True: 0, False: 195]
  ------------------
  385|      0|	    args[argsLen].ll = va_arg(argList, long long);
  386|      0|	    break;
  387|      0|#endif
  388|      0|#ifdef ULLONG_MAX
  389|      0|	  case fmtULongLongDecimal:
  ------------------
  |  Branch (389:4): [True: 0, False: 195]
  ------------------
  390|      0|	  case fmtULongLongHex:
  ------------------
  |  Branch (390:4): [True: 0, False: 195]
  ------------------
  391|      0|	  case fmtULongLongOctal:
  ------------------
  |  Branch (391:4): [True: 0, False: 195]
  ------------------
  392|      0|	  case fmtULongLongBinary:
  ------------------
  |  Branch (392:4): [True: 0, False: 195]
  ------------------
  393|      0|	    args[argsLen].ull = va_arg(argList, unsigned long long);
  394|      0|	    break;
  395|      0|#endif
  396|      0|	  case fmtDouble:
  ------------------
  |  Branch (396:4): [True: 0, False: 195]
  ------------------
  397|      0|	  case fmtDoubleTrim:
  ------------------
  |  Branch (397:4): [True: 0, False: 195]
  ------------------
  398|      0|	    args[argsLen].f = va_arg(argList, double);
  399|      0|	    break;
  400|      0|	  case fmtChar:
  ------------------
  |  Branch (400:4): [True: 0, False: 195]
  ------------------
  401|      0|	    args[argsLen].c = (char)va_arg(argList, int);
  402|      0|	    break;
  403|    182|	  case fmtString:
  ------------------
  |  Branch (403:4): [True: 182, False: 13]
  ------------------
  404|    182|	    args[argsLen].s = va_arg(argList, char *);
  405|    182|	    break;
  406|     13|	  case fmtGString:
  ------------------
  |  Branch (406:4): [True: 13, False: 182]
  ------------------
  407|     13|	    args[argsLen].gs = va_arg(argList, GString *);
  408|     13|	    break;
  409|    195|	  }
  410|    195|	  ++argsLen;
  411|    195|	}
  412|       |
  413|       |	// format the argument
  414|    195|	arg = args[idx];
  415|    195|	str = NULL;
  416|    195|	len = 0;
  417|    195|	switch (ft) {
  ------------------
  |  Branch (417:10): [True: 0, False: 195]
  ------------------
  418|      0|	case fmtIntDecimal:
  ------------------
  |  Branch (418:2): [True: 0, False: 195]
  ------------------
  419|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  420|      0|	  break;
  421|      0|	case fmtIntHex:
  ------------------
  |  Branch (421:2): [True: 0, False: 195]
  ------------------
  422|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  423|      0|	  break;
  424|      0|	case fmtIntOctal:
  ------------------
  |  Branch (424:2): [True: 0, False: 195]
  ------------------
  425|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  426|      0|	  break;
  427|      0|	case fmtIntBinary:
  ------------------
  |  Branch (427:2): [True: 0, False: 195]
  ------------------
  428|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  429|      0|	  break;
  430|      0|	case fmtUIntDecimal:
  ------------------
  |  Branch (430:2): [True: 0, False: 195]
  ------------------
  431|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 10,
  432|      0|		     &str, &len);
  433|      0|	  break;
  434|      0|	case fmtUIntHex:
  ------------------
  |  Branch (434:2): [True: 0, False: 195]
  ------------------
  435|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 16,
  436|      0|		     &str, &len);
  437|      0|	  break;
  438|      0|	case fmtUIntOctal:
  ------------------
  |  Branch (438:2): [True: 0, False: 195]
  ------------------
  439|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  440|      0|	  break;
  441|      0|	case fmtUIntBinary:
  ------------------
  |  Branch (441:2): [True: 0, False: 195]
  ------------------
  442|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  443|      0|	  break;
  444|      0|	case fmtLongDecimal:
  ------------------
  |  Branch (444:2): [True: 0, False: 195]
  ------------------
  445|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  446|      0|	  break;
  447|      0|	case fmtLongHex:
  ------------------
  |  Branch (447:2): [True: 0, False: 195]
  ------------------
  448|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  449|      0|	  break;
  450|      0|	case fmtLongOctal:
  ------------------
  |  Branch (450:2): [True: 0, False: 195]
  ------------------
  451|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  452|      0|	  break;
  453|      0|	case fmtLongBinary:
  ------------------
  |  Branch (453:2): [True: 0, False: 195]
  ------------------
  454|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  455|      0|	  break;
  456|      0|	case fmtULongDecimal:
  ------------------
  |  Branch (456:2): [True: 0, False: 195]
  ------------------
  457|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 10,
  458|      0|		     &str, &len);
  459|      0|	  break;
  460|      0|	case fmtULongHex:
  ------------------
  |  Branch (460:2): [True: 0, False: 195]
  ------------------
  461|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 16,
  462|      0|		     &str, &len);
  463|      0|	  break;
  464|      0|	case fmtULongOctal:
  ------------------
  |  Branch (464:2): [True: 0, False: 195]
  ------------------
  465|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  466|      0|	  break;
  467|      0|	case fmtULongBinary:
  ------------------
  |  Branch (467:2): [True: 0, False: 195]
  ------------------
  468|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  469|      0|	  break;
  470|      0|#ifdef LLONG_MAX
  471|      0|	case fmtLongLongDecimal:
  ------------------
  |  Branch (471:2): [True: 0, False: 195]
  ------------------
  472|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  473|      0|	  break;
  474|      0|	case fmtLongLongHex:
  ------------------
  |  Branch (474:2): [True: 0, False: 195]
  ------------------
  475|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  476|      0|	  break;
  477|      0|	case fmtLongLongOctal:
  ------------------
  |  Branch (477:2): [True: 0, False: 195]
  ------------------
  478|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  479|      0|	  break;
  480|      0|	case fmtLongLongBinary:
  ------------------
  |  Branch (480:2): [True: 0, False: 195]
  ------------------
  481|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  482|      0|	  break;
  483|      0|#endif
  484|      0|#ifdef ULLONG_MAX
  485|      0|	case fmtULongLongDecimal:
  ------------------
  |  Branch (485:2): [True: 0, False: 195]
  ------------------
  486|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 10,
  487|      0|		     &str, &len);
  488|      0|	  break;
  489|      0|	case fmtULongLongHex:
  ------------------
  |  Branch (489:2): [True: 0, False: 195]
  ------------------
  490|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 16,
  491|      0|		     &str, &len);
  492|      0|	  break;
  493|      0|	case fmtULongLongOctal:
  ------------------
  |  Branch (493:2): [True: 0, False: 195]
  ------------------
  494|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 8,
  495|      0|		     &str, &len);
  496|      0|	  break;
  497|      0|	case fmtULongLongBinary:
  ------------------
  |  Branch (497:2): [True: 0, False: 195]
  ------------------
  498|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 2,
  499|      0|		     &str, &len);
  500|      0|	  break;
  501|      0|#endif
  502|      0|	case fmtDouble:
  ------------------
  |  Branch (502:2): [True: 0, False: 195]
  ------------------
  503|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gFalse, &str, &len);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  504|      0|	  break;
  505|      0|	case fmtDoubleTrim:
  ------------------
  |  Branch (505:2): [True: 0, False: 195]
  ------------------
  506|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gTrue, &str, &len);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  507|      0|	  break;
  508|      0|	case fmtChar:
  ------------------
  |  Branch (508:2): [True: 0, False: 195]
  ------------------
  509|      0|	  buf[0] = arg.c;
  510|      0|	  str = buf;
  511|      0|	  len = 1;
  512|      0|	  reverseAlign = !reverseAlign;
  513|      0|	  break;
  514|    182|	case fmtString:
  ------------------
  |  Branch (514:2): [True: 182, False: 13]
  ------------------
  515|    182|	  if (arg.s) {
  ------------------
  |  Branch (515:8): [True: 182, False: 0]
  ------------------
  516|    182|	    str = arg.s;
  517|    182|	    len = (int)strlen(str);
  518|    182|	  } else {
  519|      0|	    str = "(null)";
  520|      0|	    len = 6;
  521|      0|	  }
  522|    182|	  reverseAlign = !reverseAlign;
  523|    182|	  break;
  524|     13|	case fmtGString:
  ------------------
  |  Branch (524:2): [True: 13, False: 182]
  ------------------
  525|     13|	  if (arg.gs) {
  ------------------
  |  Branch (525:8): [True: 13, False: 0]
  ------------------
  526|     13|	    str = arg.gs->getCString();
  527|     13|	    len = arg.gs->getLength();
  528|     13|	  } else {
  529|      0|	    str = "(null)";
  530|      0|	    len = 6;
  531|      0|	  }
  532|     13|	  reverseAlign = !reverseAlign;
  533|     13|	  break;
  534|      0|	case fmtSpace:
  ------------------
  |  Branch (534:2): [True: 0, False: 195]
  ------------------
  535|      0|	  str = buf;
  536|      0|	  len = 0;
  537|      0|	  width = arg.i;
  538|      0|	  break;
  539|    195|	}
  540|       |
  541|       |	// append the formatted arg, handling width and alignment
  542|    195|	if (!reverseAlign && len < width) {
  ------------------
  |  Branch (542:6): [True: 0, False: 195]
  |  Branch (542:23): [True: 0, False: 0]
  ------------------
  543|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (543:18): [True: 0, False: 0]
  ------------------
  544|      0|	    append(' ');
  545|      0|	  }
  546|      0|	}
  547|    195|	append(str, len);
  548|    195|	if (reverseAlign && len < width) {
  ------------------
  |  Branch (548:6): [True: 195, False: 0]
  |  Branch (548:22): [True: 0, False: 195]
  ------------------
  549|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (549:18): [True: 0, False: 0]
  ------------------
  550|      0|	    append(' ');
  551|      0|	  }
  552|      0|	}
  553|    195|      }
  554|       |
  555|    390|    } else if (*p0 == '}') {
  ------------------
  |  Branch (555:16): [True: 0, False: 390]
  ------------------
  556|      0|      ++p0;
  557|      0|      if (*p0 == '}') {
  ------------------
  |  Branch (557:11): [True: 0, False: 0]
  ------------------
  558|      0|	++p0;
  559|      0|      }
  560|      0|      append('}');
  561|       |      
  562|    390|    } else {
  563|  4.27k|      for (p1 = p0 + 1; *p1 && *p1 != '{' && *p1 != '}'; ++p1) ;
  ------------------
  |  Branch (563:25): [True: 4.08k, False: 195]
  |  Branch (563:32): [True: 3.88k, False: 195]
  |  Branch (563:46): [True: 3.88k, False: 0]
  ------------------
  564|    390|      append(p0, (int)(p1 - p0));
  565|    390|      p0 = p1;
  566|    390|    }
  567|    585|  }
  568|       |
  569|    195|  gfree(args);
  570|    195|  return this;
  571|    195|}
_ZN7GString9upperCaseEv:
  753|     13|GString *GString::upperCase() {
  754|     13|  int i;
  755|       |
  756|    130|  for (i = 0; i < length; ++i) {
  ------------------
  |  Branch (756:15): [True: 117, False: 13]
  ------------------
  757|    117|    if (islower(s[i] & 0xff)) {
  ------------------
  |  Branch (757:9): [True: 104, False: 13]
  ------------------
  758|    104|      s[i] = (char)toupper(s[i] & 0xff);
  759|    104|    }
  760|    117|  }
  761|     13|  return this;
  762|     13|}
_ZN7GString9lowerCaseEv:
  764|     13|GString *GString::lowerCase() {
  765|     13|  int i;
  766|       |
  767|    130|  for (i = 0; i < length; ++i) {
  ------------------
  |  Branch (767:15): [True: 117, False: 13]
  ------------------
  768|    117|    if (isupper(s[i] & 0xff)) {
  ------------------
  |  Branch (768:9): [True: 0, False: 117]
  ------------------
  769|      0|      s[i] = (char)tolower(s[i] & 0xff);
  770|      0|    }
  771|    117|  }
  772|     13|  return this;
  773|     13|}
_ZN7GString6resizeEi:
  108|  12.0k|inline void GString::resize(int length1) {
  109|  12.0k|  char *s1;
  110|       |
  111|  12.0k|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 12.0k]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|  12.0k|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 2.78k, False: 9.28k]
  ------------------
  115|  2.78k|    s = new char[size(length1)];
  116|  9.28k|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 1.48k, False: 7.80k]
  ------------------
  117|  1.48k|    s1 = new char[size(length1)];
  118|  1.48k|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 1.48k]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|  1.48k|    } else {
  122|  1.48k|      memcpy(s1, s, length + 1);
  123|  1.48k|    }
  124|  1.48k|    delete[] s;
  125|  1.48k|    s = s1;
  126|  1.48k|  }
  127|  12.0k|}
GString.cc:_ZL4sizei:
   98|  22.8k|static inline int size(int len) {
   99|  22.8k|  int delta;
  100|  58.9k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 36.0k, False: 22.8k]
  |  Branch (100:34): [True: 36.0k, False: 0]
  ------------------
  101|  22.8k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 22.8k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|  22.8k|  return (len + delta) & ~(delta - 1);
  106|  22.8k|}

_ZN7GString4copyEv:
   38|     13|  GString *copy() { return new GString(this); }
_ZN7GString9getLengthEv:
   76|  9.62k|  int getLength() { return length; }
_ZN7GString10getCStringEv:
   79|  1.28k|  char *getCString() { return s; }
_ZN7GString7getCharEi:
   82|  7.72k|  char getChar(int i) { return s[i]; }

SplashBitmap.cc:_ZL10traceAllocPvPKcz:
   37|     13|static inline void traceAlloc(void *resourceHandle, const char *fmt, ...) {}
SplashBitmap.cc:_ZL12traceMessagePKcz:
   39|     13|static inline void traceMessage(const char *fmt, ...) {}
SplashBitmap.cc:_ZL9traceFreePvPKcz:
   38|     13|static inline void traceFree(void *nestHandle, const char *fmt, ...) {}

_Z10getHomeDirv:
   49|     65|GString *getHomeDir() {
   50|       |#ifdef VMS
   51|       |  //---------- VMS ----------
   52|       |  return new GString("SYS$LOGIN:");
   53|       |
   54|       |#elif defined(_WIN32)
   55|       |  //---------- Win32 ----------
   56|       |  char *s;
   57|       |  GString *ret;
   58|       |
   59|       |  if ((s = getenv("USERPROFILE")))
   60|       |    ret = new GString(s);
   61|       |  else
   62|       |    ret = new GString(".");
   63|       |  return ret;
   64|       |
   65|       |#elif defined(__EMX__)
   66|       |  //---------- OS/2+EMX ----------
   67|       |  char *s;
   68|       |  GString *ret;
   69|       |
   70|       |  if ((s = getenv("HOME")))
   71|       |    ret = new GString(s);
   72|       |  else
   73|       |    ret = new GString(".");
   74|       |  return ret;
   75|       |
   76|       |#elif defined(ACORN)
   77|       |  //---------- RISCOS ----------
   78|       |  return new GString("@");
   79|       |
   80|       |#else
   81|       |  //---------- Unix ----------
   82|     65|  char *s;
   83|     65|  struct passwd *pw;
   84|     65|  GString *ret;
   85|       |
   86|     65|  if ((s = getenv("HOME"))) {
  ------------------
  |  Branch (86:7): [True: 65, False: 0]
  ------------------
   87|     65|    ret = new GString(s);
   88|     65|  } else {
   89|      0|    if ((s = getenv("USER")))
  ------------------
  |  Branch (89:9): [True: 0, False: 0]
  ------------------
   90|      0|      pw = getpwnam(s);
   91|      0|    else
   92|      0|      pw = getpwuid(getuid());
   93|      0|    if (pw)
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      ret = new GString(pw->pw_dir);
   95|      0|    else
   96|      0|      ret = new GString(".");
   97|      0|  }
   98|     65|  return ret;
   99|     65|#endif
  100|     65|}
_Z12appendToPathP7GStringPKc:
  118|    975|GString *appendToPath(GString *path, const char *fileName) {
  119|       |#if defined(VMS)
  120|       |  //---------- VMS ----------
  121|       |  //~ this should handle everything necessary for file
  122|       |  //~ requesters, but it's certainly not complete
  123|       |  char *p0, *p1, *p2;
  124|       |  char *q1;
  125|       |
  126|       |  p0 = path->getCString();
  127|       |  p1 = p0 + path->getLength() - 1;
  128|       |  if (!strcmp(fileName, "-")) {
  129|       |    if (*p1 == ']') {
  130|       |      for (p2 = p1; p2 > p0 && *p2 != '.' && *p2 != '['; --p2) ;
  131|       |      if (*p2 == '[')
  132|       |	++p2;
  133|       |      path->del(p2 - p0, p1 - p2);
  134|       |    } else if (*p1 == ':') {
  135|       |      path->append("[-]");
  136|       |    } else {
  137|       |      path->clear();
  138|       |      path->append("[-]");
  139|       |    }
  140|       |  } else if ((q1 = strrchr(fileName, '.')) && !strncmp(q1, ".DIR;", 5)) {
  141|       |    if (*p1 == ']') {
  142|       |      path->insert(p1 - p0, '.');
  143|       |      path->insert(p1 - p0 + 1, fileName, q1 - fileName);
  144|       |    } else if (*p1 == ':') {
  145|       |      path->append('[');
  146|       |      path->append(']');
  147|       |      path->append(fileName, q1 - fileName);
  148|       |    } else {
  149|       |      path->clear();
  150|       |      path->append(fileName, q1 - fileName);
  151|       |    }
  152|       |  } else {
  153|       |    if (*p1 != ']' && *p1 != ':')
  154|       |      path->clear();
  155|       |    path->append(fileName);
  156|       |  }
  157|       |  return path;
  158|       |
  159|       |#elif defined(_WIN32)
  160|       |  //---------- Win32 ----------
  161|       |  GString *tmp;
  162|       |  char buf[256];
  163|       |  char *fp;
  164|       |
  165|       |  tmp = new GString(path);
  166|       |  tmp->append('/');
  167|       |  tmp->append(fileName);
  168|       |  GetFullPathNameA(tmp->getCString(), sizeof(buf), buf, &fp);
  169|       |  delete tmp;
  170|       |  path->clear();
  171|       |  path->append(buf);
  172|       |  return path;
  173|       |
  174|       |#elif defined(ACORN)
  175|       |  //---------- RISCOS ----------
  176|       |  char *p;
  177|       |  int i;
  178|       |
  179|       |  path->append(".");
  180|       |  i = path->getLength();
  181|       |  path->append(fileName);
  182|       |  for (p = path->getCString() + i; *p; ++p) {
  183|       |    if (*p == '/') {
  184|       |      *p = '.';
  185|       |    } else if (*p == '.') {
  186|       |      *p = '/';
  187|       |    }
  188|       |  }
  189|       |  return path;
  190|       |
  191|       |#elif defined(__EMX__)
  192|       |  //---------- OS/2+EMX ----------
  193|       |  int i;
  194|       |
  195|       |  // appending "." does nothing
  196|       |  if (!strcmp(fileName, "."))
  197|       |    return path;
  198|       |
  199|       |  // appending ".." goes up one directory
  200|       |  if (!strcmp(fileName, "..")) {
  201|       |    for (i = path->getLength() - 2; i >= 0; --i) {
  202|       |      if (path->getChar(i) == '/' || path->getChar(i) == '\\' ||
  203|       |	  path->getChar(i) == ':')
  204|       |	break;
  205|       |    }
  206|       |    if (i <= 0) {
  207|       |      if (path->getChar(0) == '/' || path->getChar(0) == '\\') {
  208|       |	path->del(1, path->getLength() - 1);
  209|       |      } else if (path->getLength() >= 2 && path->getChar(1) == ':') {
  210|       |	path->del(2, path->getLength() - 2);
  211|       |      } else {
  212|       |	path->clear();
  213|       |	path->append("..");
  214|       |      }
  215|       |    } else {
  216|       |      if (path->getChar(i-1) == ':')
  217|       |	++i;
  218|       |      path->del(i, path->getLength() - i);
  219|       |    }
  220|       |    return path;
  221|       |  }
  222|       |
  223|       |  // otherwise, append "/" and new path component
  224|       |  if (path->getLength() > 0 &&
  225|       |      path->getChar(path->getLength() - 1) != '/' &&
  226|       |      path->getChar(path->getLength() - 1) != '\\')
  227|       |    path->append('/');
  228|       |  path->append(fileName);
  229|       |  return path;
  230|       |
  231|       |#else
  232|       |  //---------- Unix ----------
  233|    975|  int i;
  234|       |
  235|       |  // appending "." does nothing
  236|    975|  if (!strcmp(fileName, "."))
  ------------------
  |  Branch (236:7): [True: 0, False: 975]
  ------------------
  237|      0|    return path;
  238|       |
  239|       |  // appending ".." goes up one directory
  240|    975|  if (!strcmp(fileName, "..")) {
  ------------------
  |  Branch (240:7): [True: 0, False: 975]
  ------------------
  241|      0|    for (i = path->getLength() - 2; i >= 0; --i) {
  ------------------
  |  Branch (241:37): [True: 0, False: 0]
  ------------------
  242|      0|      if (path->getChar(i) == '/')
  ------------------
  |  Branch (242:11): [True: 0, False: 0]
  ------------------
  243|      0|	break;
  244|      0|    }
  245|      0|    if (i <= 0) {
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|      if (path->getChar(0) == '/') {
  ------------------
  |  Branch (246:11): [True: 0, False: 0]
  ------------------
  247|      0|	path->del(1, path->getLength() - 1);
  248|      0|      } else {
  249|      0|	path->clear();
  250|      0|	path->append("..");
  251|      0|      }
  252|      0|    } else {
  253|      0|      path->del(i, path->getLength() - i);
  254|      0|    }
  255|      0|    return path;
  256|      0|  }
  257|       |
  258|       |  // otherwise, append "/" and new path component
  259|    975|  if (path->getLength() > 0 &&
  ------------------
  |  Branch (259:7): [True: 975, False: 0]
  ------------------
  260|    975|      path->getChar(path->getLength() - 1) != '/')
  ------------------
  |  Branch (260:7): [True: 975, False: 0]
  ------------------
  261|    975|    path->append('/');
  262|    975|  path->append(fileName);
  263|    975|  return path;
  264|    975|#endif
  265|    975|}

_Z7gmalloci:
  139|  59.7k|void *gmalloc(int size) GMEM_EXCEP {
  140|  59.7k|  void *p;
  141|       |
  142|  59.7k|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 59.7k]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|  59.7k|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 59.7k]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|  59.7k|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 59.7k]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|  59.7k|  return p;
  152|  59.7k|}
_Z8greallocPvi:
  155|     52|void *grealloc(void *p, int size) GMEM_EXCEP {
  156|       |#ifdef DEBUG_MEM
  157|       |  GMemHdr *hdr;
  158|       |  void *q;
  159|       |  int oldSize;
  160|       |
  161|       |  if (size < 0) {
  162|       |    gMemError("Invalid memory allocation size");
  163|       |  }
  164|       |  if (size == 0) {
  165|       |    if (p) {
  166|       |      gfree(p);
  167|       |    }
  168|       |    return NULL;
  169|       |  }
  170|       |  if (p) {
  171|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  172|       |    oldSize = (int)hdr->size;
  173|       |    q = gmalloc(size);
  174|       |    memcpy(q, p, size < oldSize ? size : oldSize);
  175|       |    gfree(p);
  176|       |  } else {
  177|       |    q = gmalloc(size);
  178|       |  }
  179|       |  return q;
  180|       |#else
  181|     52|  void *q;
  182|       |
  183|     52|  if (size < 0) {
  ------------------
  |  Branch (183:7): [True: 0, False: 52]
  ------------------
  184|      0|    gMemError("Invalid memory allocation size");
  185|      0|  }
  186|     52|  if (size == 0) {
  ------------------
  |  Branch (186:7): [True: 0, False: 52]
  ------------------
  187|      0|    if (p) {
  ------------------
  |  Branch (187:9): [True: 0, False: 0]
  ------------------
  188|      0|      free(p);
  189|      0|    }
  190|      0|    return NULL;
  191|      0|  }
  192|     52|  if (p) {
  ------------------
  |  Branch (192:7): [True: 52, False: 0]
  ------------------
  193|     52|    q = realloc(p, size);
  194|     52|  } else {
  195|      0|    q = malloc(size);
  196|      0|  }
  197|     52|  if (!q) {
  ------------------
  |  Branch (197:7): [True: 0, False: 52]
  ------------------
  198|      0|    gMemError("Out of memory");
  199|      0|  }
  200|     52|  return q;
  201|     52|#endif
  202|     52|}
_Z8gmallocnii:
  204|  1.66k|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|  1.66k|  int n;
  206|       |
  207|  1.66k|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 1.66k]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|  1.66k|  n = nObjs * objSize;
  211|  1.66k|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 1.66k]
  |  Branch (211:23): [True: 0, False: 1.66k]
  |  Branch (211:36): [True: 0, False: 1.66k]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|  1.66k|  return gmalloc(n);
  215|  1.66k|}
_Z9gmalloc64m:
  265|     13|void *gmalloc64(size_t size) GMEM_EXCEP {
  266|     13|  void *p;
  267|       |
  268|     13|  if (size == 0) {
  ------------------
  |  Branch (268:7): [True: 0, False: 13]
  ------------------
  269|      0|    return NULL;
  270|      0|  }
  271|     13|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (271:7): [True: 0, False: 13]
  ------------------
  272|      0|    gMemError("Out of memory");
  273|      0|  }
  274|     13|  return p;
  275|     13|}
_Z10gmallocn64im:
  278|     13|void *gmallocn64(int nObjs, size_t objSize) GMEM_EXCEP {
  279|     13|  size_t n;
  280|       |
  281|     13|  if (nObjs == 0) {
  ------------------
  |  Branch (281:7): [True: 0, False: 13]
  ------------------
  282|      0|    return NULL;
  283|      0|  }
  284|     13|  n = nObjs * objSize;
  285|     13|  if (nObjs < 0 || (size_t)nObjs >= SIZE_MAX / objSize) {
  ------------------
  |  Branch (285:7): [True: 0, False: 13]
  |  Branch (285:20): [True: 0, False: 13]
  ------------------
  286|      0|    gMemError("Bogus memory allocation size");
  287|      0|  }
  288|     13|  return gmalloc64(n);
  289|     13|}
_Z9greallocnPvii:
  291|     52|void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
  292|     52|  int n;
  293|       |
  294|     52|  if (nObjs == 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 52]
  ------------------
  295|      0|    if (p) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      gfree(p);
  297|      0|    }
  298|      0|    return NULL;
  299|      0|  }
  300|     52|  n = nObjs * objSize;
  301|     52|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (301:7): [True: 0, False: 52]
  |  Branch (301:23): [True: 0, False: 52]
  |  Branch (301:36): [True: 0, False: 52]
  ------------------
  302|      0|    gMemError("Bogus memory allocation size");
  303|      0|  }
  304|     52|  return grealloc(p, n);
  305|     52|}
_Z5gfreePv:
  307|  59.8k|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|  59.8k|  if (p) {
  ------------------
  |  Branch (348:7): [True: 59.7k, False: 130]
  ------------------
  349|  59.7k|    free(p);
  350|  59.7k|  }
  351|  59.8k|#endif
  352|  59.8k|}
_Z10copyStringPKc:
  390|  58.0k|char *copyString(const char *s) {
  391|  58.0k|  char *s1;
  392|       |
  393|  58.0k|  s1 = (char *)gmalloc((int)strlen(s) + 1);
  394|  58.0k|  strcpy(s1, s);
  395|  58.0k|  return s1;
  396|  58.0k|}

_ZN6Splash14clearModRegionEv:
  137|     13|void Splash::clearModRegion() {
  138|     13|  modXMin = bitmap->width;
  139|     13|  modYMin = bitmap->height;
  140|     13|  modXMax = -1;
  141|     13|  modYMax = -1;
  142|     13|}
_ZN16SplashImageCacheC2Ev:
 3129|     13|SplashImageCache::SplashImageCache() {
 3130|     13|  tag = NULL;
 3131|     13|  width = 0;
 3132|     13|  height = 0;
 3133|     13|  mode = splashModeRGB8;
 3134|     13|  alpha = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 3135|     13|  interpolate = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 3136|     13|  colorData = NULL;
 3137|     13|  alphaData = NULL;
 3138|     13|  refCount = 1;
 3139|     13|}
_ZN16SplashImageCacheD2Ev:
 3141|     13|SplashImageCache::~SplashImageCache() {
 3142|     13|  if (tag) {
  ------------------
  |  Branch (3142:7): [True: 0, False: 13]
  ------------------
 3143|      0|    delete tag;
 3144|      0|  }
 3145|     13|  gfree(colorData);
 3146|     13|  gfree(alphaData);
 3147|     13|}
_ZN16SplashImageCache11decRefCountEv:
 3184|     13|void SplashImageCache::decRefCount() {
 3185|     13|  --refCount;
 3186|     13|  if (refCount == 0) {
  ------------------
  |  Branch (3186:7): [True: 13, False: 0]
  ------------------
 3187|     13|    delete this;
 3188|     13|  }
 3189|     13|}
_ZN6SplashC2EP12SplashBitmapiP16SplashImageCacheP18SplashScreenParams:
 4487|     13|	       SplashScreenParams *screenParams) {
 4488|     13|  bitmap = bitmapA;
 4489|     13|  bitmapComps = splashColorModeNComps[bitmap->mode];
 4490|     13|  vectorAntialias = vectorAntialiasA;
 4491|     13|  inShading = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4492|     13|  state = new SplashState(bitmap->width, bitmap->height, vectorAntialias,
 4493|     13|			  screenParams);
 4494|     13|  scanBuf = (Guchar *)gmalloc(bitmap->width);
 4495|     13|  if (bitmap->mode == splashModeMono1) {
  ------------------
  |  Branch (4495:7): [True: 13, False: 0]
  ------------------
 4496|     13|    scanBuf2 = (Guchar *)gmalloc(bitmap->width);
 4497|     13|  } else {
 4498|      0|    scanBuf2 = NULL;
 4499|      0|  }
 4500|     13|  groupBackBitmap = NULL;
 4501|     13|  groupDestInitMode = splashGroupDestPreInit;
 4502|     13|  overprintMaskBitmap = NULL;
 4503|     13|  minLineWidth = 0;
 4504|     13|  clearModRegion();
 4505|     13|  debugMode = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4506|       |
 4507|     13|  if (imageCacheA) {
  ------------------
  |  Branch (4507:7): [True: 0, False: 13]
  ------------------
 4508|      0|    imageCache = imageCacheA;
 4509|      0|    imageCache->incRefCount();
 4510|     13|  } else {
 4511|     13|    imageCache = new SplashImageCache();
 4512|     13|  }
 4513|     13|}
_ZN6SplashD2Ev:
 4544|     13|Splash::~Splash() {
 4545|     13|  imageCache->decRefCount();
 4546|       |
 4547|     13|  while (state->next) {
  ------------------
  |  Branch (4547:10): [True: 0, False: 13]
  ------------------
 4548|      0|    restoreState();
 4549|      0|  }
 4550|     13|  delete state;
 4551|     13|  gfree(scanBuf);
 4552|     13|  gfree(scanBuf2);
 4553|     13|}
_ZN6Splash15setStrokeAdjustE22SplashStrokeAdjustMode:
 4708|     13|void Splash::setStrokeAdjust(SplashStrokeAdjustMode strokeAdjust) {
 4709|     13|  state->strokeAdjust = strokeAdjust;
 4710|     13|}
_ZN6Splash27setEnablePathSimplificationEi:
 4794|     13|void Splash::setEnablePathSimplification(GBool en) {
 4795|     13|  state->enablePathSimplification = en;
 4796|     13|}
_ZN6Splash5clearEPhh:
 4826|     13|void Splash::clear(SplashColorPtr color, Guchar alpha) {
 4827|     13|  SplashColorPtr row, p;
 4828|     13|  Guchar mono;
 4829|     13|  int x, y;
 4830|       |
 4831|     13|  switch (bitmap->mode) {
  ------------------
  |  Branch (4831:11): [True: 0, False: 13]
  ------------------
 4832|     13|  case splashModeMono1:
  ------------------
  |  Branch (4832:3): [True: 13, False: 0]
  ------------------
 4833|     13|    mono = (color[0] & 0x80) ? 0xff : 0x00;
  ------------------
  |  Branch (4833:12): [True: 0, False: 13]
  ------------------
 4834|     13|    if (bitmap->rowSize < 0) {
  ------------------
  |  Branch (4834:9): [True: 0, False: 13]
  ------------------
 4835|      0|      memset(bitmap->data + bitmap->rowSize * (bitmap->height - 1),
 4836|      0|	     mono, -bitmap->rowSize * bitmap->height);
 4837|     13|    } else {
 4838|     13|      memset(bitmap->data, mono, bitmap->rowSize * bitmap->height);
 4839|     13|    }
 4840|     13|    break;
 4841|      0|  case splashModeMono8:
  ------------------
  |  Branch (4841:3): [True: 0, False: 13]
  ------------------
 4842|      0|    if (bitmap->rowSize < 0) {
  ------------------
  |  Branch (4842:9): [True: 0, False: 0]
  ------------------
 4843|      0|      memset(bitmap->data + bitmap->rowSize * (bitmap->height - 1),
 4844|      0|	     color[0], -bitmap->rowSize * bitmap->height);
 4845|      0|    } else {
 4846|      0|      memset(bitmap->data, color[0], bitmap->rowSize * bitmap->height);
 4847|      0|    }
 4848|      0|    break;
 4849|      0|  case splashModeRGB8:
  ------------------
  |  Branch (4849:3): [True: 0, False: 13]
  ------------------
 4850|      0|    if (color[0] == color[1] && color[1] == color[2]) {
  ------------------
  |  Branch (4850:9): [True: 0, False: 0]
  |  Branch (4850:33): [True: 0, False: 0]
  ------------------
 4851|      0|      if (bitmap->rowSize < 0) {
  ------------------
  |  Branch (4851:11): [True: 0, False: 0]
  ------------------
 4852|      0|	memset(bitmap->data + bitmap->rowSize * (bitmap->height - 1),
 4853|      0|	       color[0], -bitmap->rowSize * bitmap->height);
 4854|      0|      } else {
 4855|      0|	memset(bitmap->data, color[0], bitmap->rowSize * bitmap->height);
 4856|      0|      }
 4857|      0|    } else {
 4858|      0|      row = bitmap->data;
 4859|      0|      for (y = 0; y < bitmap->height; ++y) {
  ------------------
  |  Branch (4859:19): [True: 0, False: 0]
  ------------------
 4860|      0|	p = row;
 4861|      0|	for (x = 0; x < bitmap->width; ++x) {
  ------------------
  |  Branch (4861:14): [True: 0, False: 0]
  ------------------
 4862|      0|	  *p++ = color[0];
 4863|      0|	  *p++ = color[1];
 4864|      0|	  *p++ = color[2];
 4865|      0|	}
 4866|      0|	row += bitmap->rowSize;
 4867|      0|      }
 4868|      0|    }
 4869|      0|    break;
 4870|      0|  case splashModeBGR8:
  ------------------
  |  Branch (4870:3): [True: 0, False: 13]
  ------------------
 4871|      0|    if (color[0] == color[1] && color[1] == color[2]) {
  ------------------
  |  Branch (4871:9): [True: 0, False: 0]
  |  Branch (4871:33): [True: 0, False: 0]
  ------------------
 4872|      0|      if (bitmap->rowSize < 0) {
  ------------------
  |  Branch (4872:11): [True: 0, False: 0]
  ------------------
 4873|      0|	memset(bitmap->data + bitmap->rowSize * (bitmap->height - 1),
 4874|      0|	       color[0], -bitmap->rowSize * bitmap->height);
 4875|      0|      } else {
 4876|      0|	memset(bitmap->data, color[0], bitmap->rowSize * bitmap->height);
 4877|      0|      }
 4878|      0|    } else {
 4879|      0|      row = bitmap->data;
 4880|      0|      for (y = 0; y < bitmap->height; ++y) {
  ------------------
  |  Branch (4880:19): [True: 0, False: 0]
  ------------------
 4881|      0|	p = row;
 4882|      0|	for (x = 0; x < bitmap->width; ++x) {
  ------------------
  |  Branch (4882:14): [True: 0, False: 0]
  ------------------
 4883|      0|	  *p++ = color[2];
 4884|      0|	  *p++ = color[1];
 4885|      0|	  *p++ = color[0];
 4886|      0|	}
 4887|      0|	row += bitmap->rowSize;
 4888|      0|      }
 4889|      0|    }
 4890|      0|    break;
 4891|      0|#if SPLASH_CMYK
 4892|      0|  case splashModeCMYK8:
  ------------------
  |  Branch (4892:3): [True: 0, False: 13]
  ------------------
 4893|      0|    if (color[0] == color[1] && color[1] == color[2] && color[2] == color[3]) {
  ------------------
  |  Branch (4893:9): [True: 0, False: 0]
  |  Branch (4893:33): [True: 0, False: 0]
  |  Branch (4893:57): [True: 0, False: 0]
  ------------------
 4894|      0|      if (bitmap->rowSize < 0) {
  ------------------
  |  Branch (4894:11): [True: 0, False: 0]
  ------------------
 4895|      0|	memset(bitmap->data + bitmap->rowSize * (bitmap->height - 1),
 4896|      0|	       color[0], -bitmap->rowSize * bitmap->height);
 4897|      0|      } else {
 4898|      0|	memset(bitmap->data, color[0], bitmap->rowSize * bitmap->height);
 4899|      0|      }
 4900|      0|    } else {
 4901|      0|      row = bitmap->data;
 4902|      0|      for (y = 0; y < bitmap->height; ++y) {
  ------------------
  |  Branch (4902:19): [True: 0, False: 0]
  ------------------
 4903|      0|	p = row;
 4904|      0|	for (x = 0; x < bitmap->width; ++x) {
  ------------------
  |  Branch (4904:14): [True: 0, False: 0]
  ------------------
 4905|      0|	  *p++ = color[0];
 4906|      0|	  *p++ = color[1];
 4907|      0|	  *p++ = color[2];
 4908|      0|	  *p++ = color[3];
 4909|      0|	}
 4910|      0|	row += bitmap->rowSize;
 4911|      0|      }
 4912|      0|    }
 4913|      0|    break;
 4914|     13|#endif
 4915|     13|  }
 4916|       |
 4917|     13|  if (bitmap->alpha) {
  ------------------
  |  Branch (4917:7): [True: 0, False: 13]
  ------------------
 4918|      0|    memset(bitmap->alpha, alpha, bitmap->alphaRowSize * bitmap->height);
 4919|      0|  }
 4920|       |
 4921|     13|  updateModX(0);
 4922|     13|  updateModY(0);
 4923|     13|  updateModX(bitmap->width - 1);
 4924|     13|  updateModY(bitmap->height - 1);
 4925|     13|}
_ZN6Splash10updateModXEi:
  144|     26|inline void Splash::updateModX(int x) {
  145|     26|  if (x < modXMin) {
  ------------------
  |  Branch (145:7): [True: 13, False: 13]
  ------------------
  146|     13|    modXMin = x;
  147|     13|  }
  148|     26|  if (x > modXMax) {
  ------------------
  |  Branch (148:7): [True: 13, False: 13]
  ------------------
  149|     13|    modXMax = x;
  150|     13|  }
  151|     26|}
_ZN6Splash10updateModYEi:
  153|     26|inline void Splash::updateModY(int y) {
  154|     26|  if (y < modYMin) {
  ------------------
  |  Branch (154:7): [True: 13, False: 13]
  ------------------
  155|     13|    modYMin = y;
  156|     13|  }
  157|     26|  if (y > modYMax) {
  ------------------
  |  Branch (157:7): [True: 13, False: 13]
  ------------------
  158|     13|    modYMax = y;
  159|     13|  }
  160|     26|}

_ZN6Splash15setMinLineWidthEd:
  313|     13|  void setMinLineWidth(SplashCoord w) { minLineWidth = w; }

_ZN12SplashBitmapC2Eiii15SplashColorModeiiPS_:
   26|     13|			   GBool topDown, SplashBitmap *parentA) {
   27|       |  // NB: this code checks that rowSize fits in a signed 32-bit
   28|       |  // integer, because some code (outside this class) makes that
   29|       |  // assumption
   30|     13|  width = widthA;
   31|     13|  height = heightA;
   32|     13|  mode = modeA;
   33|     13|  switch (mode) {
  ------------------
  |  Branch (33:11): [True: 0, False: 13]
  ------------------
   34|     13|  case splashModeMono1:
  ------------------
  |  Branch (34:3): [True: 13, False: 0]
  ------------------
   35|     13|    if (width <= 0) {
  ------------------
  |  Branch (35:9): [True: 0, False: 13]
  ------------------
   36|      0|      gMemError("invalid bitmap width");
   37|      0|    }
   38|     13|    rowSize = (width + 7) >> 3;
   39|     13|    break;
   40|      0|  case splashModeMono8:
  ------------------
  |  Branch (40:3): [True: 0, False: 13]
  ------------------
   41|      0|    if (width <= 0) {
  ------------------
  |  Branch (41:9): [True: 0, False: 0]
  ------------------
   42|      0|      gMemError("invalid bitmap width");
   43|      0|    }
   44|      0|    rowSize = width;
   45|      0|    break;
   46|      0|  case splashModeRGB8:
  ------------------
  |  Branch (46:3): [True: 0, False: 13]
  ------------------
   47|      0|  case splashModeBGR8:
  ------------------
  |  Branch (47:3): [True: 0, False: 13]
  ------------------
   48|      0|    if (width <= 0 || width > INT_MAX / 3) {
  ------------------
  |  Branch (48:9): [True: 0, False: 0]
  |  Branch (48:23): [True: 0, False: 0]
  ------------------
   49|      0|      gMemError("invalid bitmap width");
   50|      0|    }
   51|      0|    rowSize = (SplashBitmapRowSize)width * 3;
   52|      0|    break;
   53|      0|#if SPLASH_CMYK
   54|      0|  case splashModeCMYK8:
  ------------------
  |  Branch (54:3): [True: 0, False: 13]
  ------------------
   55|      0|    if (width <= 0 || width > INT_MAX / 4) {
  ------------------
  |  Branch (55:9): [True: 0, False: 0]
  |  Branch (55:23): [True: 0, False: 0]
  ------------------
   56|      0|      gMemError("invalid bitmap width");
   57|      0|    }
   58|      0|    rowSize = (SplashBitmapRowSize)width * 4;
   59|      0|    break;
   60|     13|#endif
   61|     13|  }
   62|     13|  rowSize += rowPad - 1;
   63|     13|  rowSize -= rowSize % rowPad;
   64|       |
   65|     13|  traceAlloc(this, "alloc bitmap: %d x %d x %d %s -> %lld bytes",
   66|     13|	     width, height, splashColorModeNComps[mode],
   67|     13|	     alphaA ? "with alpha" : "without alpha",
  ------------------
  |  Branch (67:7): [True: 0, False: 13]
  ------------------
   68|     13|	     height * rowSize + (alphaA ? height * width : 0));
  ------------------
  |  Branch (68:27): [True: 0, False: 13]
  ------------------
   69|       |
   70|     13|  parent = parentA;
   71|     13|  oldData = NULL;
   72|     13|  oldAlpha = NULL;
   73|     13|  oldRowSize = 0;
   74|     13|  oldAlphaRowSize = 0;
   75|     13|  oldHeight = 0;
   76|     13|  if (parent && parent->oldData &&
  ------------------
  |  Branch (76:7): [True: 0, False: 13]
  |  Branch (76:17): [True: 0, False: 0]
  ------------------
   77|     13|      parent->oldRowSize == rowSize &&
  ------------------
  |  Branch (77:7): [True: 0, False: 0]
  ------------------
   78|     13|      parent->oldHeight == height) {
  ------------------
  |  Branch (78:7): [True: 0, False: 0]
  ------------------
   79|      0|    data = parent->oldData;
   80|      0|    parent->oldData = NULL;
   81|      0|    traceMessage("reusing bitmap memory");
   82|     13|  } else {
   83|     13|    data = (SplashColorPtr)gmallocn64(height, rowSize);
   84|     13|    traceMessage("not reusing bitmap memory"
   85|     13|		 " (parent=%p parent->oldData=%p same-size=%d)",
   86|     13|		 parent, parent ? parent->oldData : NULL,
  ------------------
  |  Branch (86:12): [True: 0, False: 13]
  ------------------
   87|     13|		 parent ? (parent->oldRowSize == rowSize &&
  ------------------
  |  Branch (87:4): [True: 0, False: 13]
  |  Branch (87:14): [True: 0, False: 0]
  ------------------
   88|     13|			   parent->oldHeight == height) : 0);
  ------------------
  |  Branch (88:7): [True: 0, False: 0]
  ------------------
   89|     13|  }
   90|     13|  if (!topDown) {
  ------------------
  |  Branch (90:7): [True: 0, False: 13]
  ------------------
   91|      0|    data += (height - 1) * rowSize;
   92|      0|    rowSize = -rowSize;
   93|      0|  }
   94|     13|  if (alphaA) {
  ------------------
  |  Branch (94:7): [True: 0, False: 13]
  ------------------
   95|      0|    alphaRowSize = width;
   96|      0|    if (parent && parent->oldAlpha &&
  ------------------
  |  Branch (96:9): [True: 0, False: 0]
  |  Branch (96:19): [True: 0, False: 0]
  ------------------
   97|      0|	parent->oldAlphaRowSize == alphaRowSize &&
  ------------------
  |  Branch (97:2): [True: 0, False: 0]
  ------------------
   98|      0|	parent->oldHeight == height) {
  ------------------
  |  Branch (98:2): [True: 0, False: 0]
  ------------------
   99|      0|      alpha = parent->oldAlpha;
  100|      0|      parent->oldAlpha = NULL;
  101|      0|    } else {
  102|      0|      alpha = (Guchar *)gmallocn64(height, alphaRowSize);
  103|      0|    }
  104|     13|  } else {
  105|     13|    alphaRowSize = 0;
  106|     13|    alpha = NULL;
  107|     13|  }
  108|     13|}
_ZN12SplashBitmapD2Ev:
  110|     13|SplashBitmap::~SplashBitmap() {
  111|     13|  traceFree(this, "free bitmap");
  112|     13|  if (data && rowSize < 0) {
  ------------------
  |  Branch (112:7): [True: 13, False: 0]
  |  Branch (112:15): [True: 0, False: 13]
  ------------------
  113|      0|    rowSize = -rowSize;
  114|      0|    data -= (height - 1) * rowSize;
  115|      0|  }
  116|     13|  if (parent && rowSize > 4000000 / height) {
  ------------------
  |  Branch (116:7): [True: 0, False: 13]
  |  Branch (116:17): [True: 0, False: 0]
  ------------------
  117|      0|    gfree(parent->oldData);
  118|      0|    gfree(parent->oldAlpha);
  119|      0|    parent->oldData = data;
  120|      0|    parent->oldAlpha = alpha;
  121|      0|    parent->oldRowSize = rowSize;
  122|      0|    parent->oldAlphaRowSize = alphaRowSize;
  123|      0|    parent->oldHeight = height;
  124|     13|  } else {
  125|     13|    gfree(data);
  126|     13|    gfree(alpha);
  127|     13|  }
  128|     13|  gfree(oldData);
  129|     13|  gfree(oldAlpha);
  130|     13|}

_ZN10SplashClipC2Eiiii:
   36|     13|		       int hardXMaxA, int hardYMaxA) {
   37|     13|  int w;
   38|       |
   39|     13|  hardXMin = hardXMinA;
   40|     13|  hardYMin = hardYMinA;
   41|     13|  hardXMax = hardXMaxA;
   42|     13|  hardYMax = hardYMaxA;
   43|     13|  xMin = hardXMin;
   44|     13|  yMin = hardYMin;
   45|     13|  xMax = hardXMax;
   46|     13|  yMax = hardYMax;
   47|     13|  intBoundsValid = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   48|     13|  paths = NULL;
   49|     13|  eo = NULL;
   50|     13|  scanners = NULL;
   51|     13|  length = size = 0;
   52|     13|  isSimple = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
   53|     13|  prev = NULL;
   54|     13|  if ((w = hardXMax + 1) <= 0) {
  ------------------
  |  Branch (54:7): [True: 0, False: 13]
  ------------------
   55|      0|    w = 1;
   56|      0|  }
   57|     13|  buf = (Guchar *)gmalloc(w);
   58|     13|}
_ZN10SplashClipD2Ev:
   89|     13|SplashClip::~SplashClip() {
   90|     13|  int i;
   91|       |
   92|     13|  for (i = 0; i < length; ++i) {
  ------------------
  |  Branch (92:15): [True: 0, False: 13]
  ------------------
   93|      0|    delete scanners[i];
   94|      0|    delete paths[i];
   95|      0|  }
   96|     13|  gfree(paths);
   97|     13|  gfree(eo);
   98|     13|  gfree(scanners);
   99|     13|  gfree(buf);
  100|     13|}

SplashScreen.cc:_ZL11splashRoundd:
  180|    234|static inline int splashRound(SplashCoord x) {
  181|       |#if USE_FIXEDPOINT
  182|       |
  183|       |  //--- fixed point
  184|       |
  185|       |  return FixedPoint::round(x);
  186|       |
  187|       |#else
  188|       |
  189|       |  //--- all others
  190|       |
  191|    234|  return splashFloor(x + 0.5);
  192|       |
  193|    234|#endif
  194|    234|}
SplashScreen.cc:_ZL11splashFloord:
   36|    234|static inline int splashFloor(SplashCoord x) {
   37|       |#if USE_FIXEDPOINT
   38|       |
   39|       |  //--- fixed point
   40|       |
   41|       |  return FixedPoint::floor(x);
   42|       |
   43|       |#elif (defined(__GNUC__) && defined(__SSE2__)) || \
   44|       |      (defined(_WIN32) && (_M_IX86_FP == 2 || defined(_M_X64)))
   45|       |
   46|       |  //--- SSE2 intrinsics
   47|       |  // NB: 64-bit x86 guarantees availability of SSE2.
   48|       |
   49|    234|  __m128d m1, m2;
   50|    234|  int i, s;
   51|       |
   52|    234|  m1 = _mm_set_sd(x);
   53|    234|  i = _mm_cvttsd_si32(m1);
   54|    234|  m2 = _mm_cvtsi32_sd(m1, i);
   55|    234|  s = _mm_ucomigt_sd(m2, m1);
   56|    234|  return i - s;
   57|       |
   58|       |#elif defined(__GNUC__) && defined(__i386__) && !defined(__APPLE__)
   59|       |
   60|       |  //--- x87 inline assembly (gcc/clang)
   61|       |  // (this code fails on OSX for reasons I don't understand)
   62|       |
   63|       |  Gushort oldCW, newCW, t;
   64|       |  int result;
   65|       |
   66|       |  __asm__ volatile("fnstcw %0\n"
   67|       |		   "movw   %0, %3\n"
   68|       |		   "andw   $0xf3ff, %3\n"
   69|       |		   "orw    $0x0400, %3\n"
   70|       |		   "movw   %3, %1\n"       // round down
   71|       |		   "fldcw  %1\n"
   72|       |		   "fistl %2\n"
   73|       |		   "fldcw  %0\n"
   74|       |		   : "=m" (oldCW), "=m" (newCW), "=m" (result), "=r" (t)
   75|       |		   : "t" (x));
   76|       |  return result;
   77|       |
   78|       |#elif defined(_WIN32) && defined(_M_IX86)
   79|       |
   80|       |  //--- x87 inline assembly (VC)
   81|       |
   82|       |  Gushort oldCW, newCW;
   83|       |  int result;
   84|       |
   85|       |  __asm fld QWORD PTR x
   86|       |  __asm fnstcw WORD PTR oldCW
   87|       |  __asm mov ax, WORD PTR oldCW
   88|       |  __asm and ax, 0xf3ff
   89|       |  __asm or ax, 0x0400
   90|       |  __asm mov WORD PTR newCW, ax     // round down
   91|       |  __asm fldcw WORD PTR newCW
   92|       |  __asm fistp DWORD PTR result
   93|       |  __asm fldcw WORD PTR oldCW
   94|       |  return result;
   95|       |
   96|       |#else
   97|       |
   98|       |  //--- all others
   99|       |
  100|       |  return (int)floor(x);
  101|       |
  102|       |#endif
  103|    234|}
SplashScreen.cc:_ZL9splashPowdd:
  212|    208|static inline SplashCoord splashPow(SplashCoord x, SplashCoord y) {
  213|       |#if USE_FIXEDPOINT
  214|       |  return FixedPoint::pow(x, y);
  215|       |#else
  216|    208|  return pow(x, y);
  217|    208|#endif
  218|    208|}

_ZN13SplashPatternC2Ev:
   20|     26|SplashPattern::SplashPattern() {
   21|     26|}
_ZN13SplashPatternD2Ev:
   23|     26|SplashPattern::~SplashPattern() {
   24|     26|}
_ZN16SplashSolidColorC2EPh:
   30|     26|SplashSolidColor::SplashSolidColor(SplashColorPtr colorA) {
   31|     26|  splashColorCopy(color, colorA);
   32|     26|}

_ZN12SplashScreenC2EP18SplashScreenParams:
   64|     13|SplashScreen::SplashScreen(SplashScreenParams *params) {
   65|     13|  Guchar u;
   66|     13|  int black, white, i;
   67|       |
   68|     13|  if (!params) {
  ------------------
  |  Branch (68:7): [True: 0, False: 13]
  ------------------
   69|      0|    params = &defaultParams;
   70|      0|  }
   71|       |
   72|       |  // size must be a power of 2, and at least 2
   73|     26|  for (size = 2, log2Size = 1; size < params->size; size <<= 1, ++log2Size) ;
  ------------------
  |  Branch (73:32): [True: 13, False: 13]
  ------------------
   74|       |
   75|     13|  switch (params->type) {
  ------------------
  |  Branch (75:11): [True: 0, False: 13]
  ------------------
   76|       |
   77|     13|  case splashScreenDispersed:
  ------------------
  |  Branch (77:3): [True: 13, False: 0]
  ------------------
   78|     13|    mat = (Guchar *)gmallocn(size * size, sizeof(Guchar));
   79|     13|    buildDispersedMatrix(size/2, size/2, 1, size/2, 1);
   80|     13|    break;
   81|       |
   82|      0|  case splashScreenClustered:
  ------------------
  |  Branch (82:3): [True: 0, False: 13]
  ------------------
   83|      0|    mat = (Guchar *)gmallocn(size * size, sizeof(Guchar));
   84|      0|    buildClusteredMatrix();
   85|      0|    break;
   86|       |
   87|      0|  case splashScreenStochasticClustered:
  ------------------
  |  Branch (87:3): [True: 0, False: 13]
  ------------------
   88|       |    // size must be at least 2*r
   89|      0|    while (size < (params->dotRadius << 1)) {
  ------------------
  |  Branch (89:12): [True: 0, False: 0]
  ------------------
   90|      0|      size <<= 1;
   91|      0|      ++log2Size;
   92|      0|    }
   93|      0|    mat = (Guchar *)gmallocn(size * size, sizeof(Guchar));
   94|      0|    buildSCDMatrix(params->dotRadius);
   95|      0|    break;
   96|     13|  }
   97|       |
   98|     13|  sizeM1 = size - 1;
   99|       |
  100|       |  // do gamma correction and compute minVal/maxVal
  101|     13|  minVal = 255;
  102|     13|  maxVal = 0;
  103|     13|  black = splashRound((SplashCoord)255.0 * params->blackThreshold);
  104|     13|  if (black < 1) {
  ------------------
  |  Branch (104:7): [True: 13, False: 0]
  ------------------
  105|     13|    black = 1;
  106|     13|  }
  107|     13|  white = splashRound((SplashCoord)255.0 * params->whiteThreshold);
  108|     13|  if (white > 255) {
  ------------------
  |  Branch (108:7): [True: 0, False: 13]
  ------------------
  109|      0|    white = 255;
  110|      0|  }
  111|    221|  for (i = 0; i < size * size; ++i) {
  ------------------
  |  Branch (111:15): [True: 208, False: 13]
  ------------------
  112|    208|    u = (Guchar)splashRound((SplashCoord)255.0 *
  113|    208|			    splashPow((SplashCoord)mat[i] / 255.0,
  114|    208|				      params->gamma));
  115|    208|    if (u < black) {
  ------------------
  |  Branch (115:9): [True: 0, False: 208]
  ------------------
  116|      0|      u = (Guchar)black;
  117|    208|    } else if (u >= white) {
  ------------------
  |  Branch (117:16): [True: 13, False: 195]
  ------------------
  118|     13|      u = (Guchar)white;
  119|     13|    }
  120|    208|    mat[i] = u;
  121|    208|    if (u < minVal) {
  ------------------
  |  Branch (121:9): [True: 26, False: 182]
  ------------------
  122|     26|      minVal = u;
  123|    182|    } else if (u > maxVal) {
  ------------------
  |  Branch (123:16): [True: 13, False: 169]
  ------------------
  124|     13|      maxVal = u;
  125|     13|    }
  126|    208|  }
  127|     13|}
_ZN12SplashScreen20buildDispersedMatrixEiiiii:
  130|    273|					int delta, int offset) {
  131|    273|  if (delta == 0) {
  ------------------
  |  Branch (131:7): [True: 208, False: 65]
  ------------------
  132|       |    // map values in [1, size^2] --> [1, 255]
  133|    208|    mat[(i << log2Size) + j] =
  134|    208|        (Guchar)(1 + (254 * (val - 1)) / (size * size - 1));
  135|    208|  } else {
  136|     65|    buildDispersedMatrix(i, j,
  137|     65|			 val, delta / 2, 4*offset);
  138|     65|    buildDispersedMatrix((i + delta) % size, (j + delta) % size,
  139|     65|			 val + offset, delta / 2, 4*offset);
  140|     65|    buildDispersedMatrix((i + delta) % size, j,
  141|     65|			 val + 2*offset, delta / 2, 4*offset);
  142|     65|    buildDispersedMatrix((i + 2*delta) % size, (j + delta) % size,
  143|     65|			 val + 3*offset, delta / 2, 4*offset);
  144|     65|  }
  145|    273|}
_ZN12SplashScreenD2Ev:
  377|     13|SplashScreen::~SplashScreen() {
  378|     13|  gfree(mat);
  379|     13|}

_ZN11SplashStateC2EiiiP18SplashScreenParams:
   33|     13|			 SplashScreenParams *screenParams) {
   34|     13|  SplashColor color;
   35|     13|  int i;
   36|       |
   37|     13|  matrix[0] = 1;  matrix[1] = 0;
   38|     13|  matrix[2] = 0;  matrix[3] = 1;
   39|     13|  matrix[4] = 0;  matrix[5] = 0;
   40|     13|  memset(&color, 0, sizeof(SplashColor));
   41|     13|  strokePattern = new SplashSolidColor(color);
   42|     13|  fillPattern = new SplashSolidColor(color);
   43|     13|  screen = new SplashScreen(screenParams);
   44|     13|  blendFunc = NULL;
   45|     13|  strokeAlpha = 1;
   46|     13|  fillAlpha = 1;
   47|     13|  lineWidth = 1;
   48|     13|  lineCap = splashLineCapButt;
  ------------------
  |  |   26|     13|#define splashLineCapButt       0
  ------------------
   49|     13|  lineJoin = splashLineJoinMiter;
  ------------------
  |  |   34|     13|#define splashLineJoinMiter     0
  ------------------
   50|     13|  miterLimit = 10;
   51|     13|  flatness = 1;
   52|     13|  lineDash = NULL;
   53|     13|  lineDashLength = 0;
   54|     13|  lineDashPhase = 0;
   55|     13|  strokeAdjust = splashStrokeAdjustOff;
   56|     13|  clip = new SplashClip(0, 0, width, height);
   57|     13|  clipIsShared = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   58|     13|  softMask = NULL;
   59|     13|  deleteSoftMask = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   60|     13|  inNonIsolatedGroup = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   61|     13|  inKnockoutGroup = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   62|     13|#if SPLASH_CMYK
   63|     13|  rgbTransferR = (Guchar *)gmalloc(8 * 256);
   64|     13|  rgbTransferG = rgbTransferR + 256;
   65|     13|  rgbTransferB = rgbTransferG + 256;
   66|     13|  grayTransfer = rgbTransferB + 256;
   67|     13|  cmykTransferC = grayTransfer + 256;
   68|     13|  cmykTransferM = cmykTransferC + 256;
   69|     13|  cmykTransferY = cmykTransferM + 256;
   70|     13|  cmykTransferK = cmykTransferY + 256;
   71|       |#else
   72|       |  rgbTransferR = (Guchar *)gmalloc(4 * 256);
   73|       |  rgbTransferG = rgbTransferR + 256;
   74|       |  rgbTransferB = rgbTransferG + 256;
   75|       |  grayTransfer = rgbTransferB + 256;
   76|       |#endif
   77|  3.34k|  for (i = 0; i < 256; ++i) {
  ------------------
  |  Branch (77:15): [True: 3.32k, False: 13]
  ------------------
   78|  3.32k|    rgbTransferR[i] = (Guchar)i;
   79|  3.32k|    rgbTransferG[i] = (Guchar)i;
   80|  3.32k|    rgbTransferB[i] = (Guchar)i;
   81|  3.32k|    grayTransfer[i] = (Guchar)i;
   82|  3.32k|#if SPLASH_CMYK
   83|  3.32k|    cmykTransferC[i] = (Guchar)i;
   84|  3.32k|    cmykTransferM[i] = (Guchar)i;
   85|  3.32k|    cmykTransferY[i] = (Guchar)i;
   86|  3.32k|    cmykTransferK[i] = (Guchar)i;
   87|  3.32k|#endif
   88|  3.32k|  }
   89|     13|  transferIsShared = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   90|     13|  overprintMask = 0xffffffff;
   91|     13|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
   92|     13|  next = NULL;
   93|     13|}
_ZN11SplashStateD2Ev:
  203|     13|SplashState::~SplashState() {
  204|     13|  delete strokePattern;
  205|     13|  delete fillPattern;
  206|     13|  delete screen;
  207|     13|  gfree(lineDash);
  208|     13|  if (!clipIsShared) {
  ------------------
  |  Branch (208:7): [True: 13, False: 0]
  ------------------
  209|     13|    delete clip;
  210|     13|  }
  211|     13|  if (!transferIsShared) {
  ------------------
  |  Branch (211:7): [True: 13, False: 0]
  ------------------
  212|     13|    gfree(rgbTransferR);
  213|     13|  }
  214|     13|  if (deleteSoftMask && softMask) {
  ------------------
  |  Branch (214:7): [True: 0, False: 13]
  |  Branch (214:25): [True: 0, False: 0]
  ------------------
  215|      0|    delete softMask;
  216|      0|  }
  217|     13|}

SplashOutputDev.cc:_ZL15splashColorCopyPhS_:
   84|     13|static inline void splashColorCopy(SplashColorPtr dest, SplashColorPtr src) {
   85|     13|  dest[0] = src[0];
   86|     13|  dest[1] = src[1];
   87|     13|  dest[2] = src[2];
   88|     13|#if SPLASH_CMYK
   89|     13|  dest[3] = src[3];
   90|     13|#endif
   91|     13|}
SplashPattern.cc:_ZL15splashColorCopyPhS_:
   84|     26|static inline void splashColorCopy(SplashColorPtr dest, SplashColorPtr src) {
   85|     26|  dest[0] = src[0];
   86|     26|  dest[1] = src[1];
   87|     26|  dest[2] = src[2];
   88|     26|#if SPLASH_CMYK
   89|     26|  dest[3] = src[3];
   90|     26|#endif
   91|     26|}

_ZN17BuiltinFontWidthsC2EP16BuiltinFontWidthi:
   20|    182|BuiltinFontWidths::BuiltinFontWidths(BuiltinFontWidth *widths, int sizeA) {
   21|    182|  int i, h;
   22|       |
   23|    182|  size = sizeA;
   24|    182|  tab = (BuiltinFontWidth **)gmallocn(size, sizeof(BuiltinFontWidth *));
   25|  54.4k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (25:15): [True: 54.2k, False: 182]
  ------------------
   26|  54.2k|    tab[i] = NULL;
   27|  54.2k|  }
   28|  54.4k|  for (i = 0; i < sizeA; ++i) {
  ------------------
  |  Branch (28:15): [True: 54.2k, False: 182]
  ------------------
   29|  54.2k|    h = hash(widths[i].name);
   30|  54.2k|    widths[i].next = tab[h];
   31|  54.2k|    tab[h] = &widths[i];
   32|  54.2k|  }
   33|    182|}
_ZN17BuiltinFontWidthsD2Ev:
   35|    182|BuiltinFontWidths::~BuiltinFontWidths() {
   36|    182|  gfree(tab);
   37|    182|}
_ZN17BuiltinFontWidths4hashEPKc:
   54|  54.2k|int BuiltinFontWidths::hash(const char *name) {
   55|  54.2k|  const char *p;
   56|  54.2k|  unsigned int h;
   57|       |
   58|  54.2k|  h = 0;
   59|   403k|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (59:18): [True: 349k, False: 54.2k]
  ------------------
   60|   349k|    h = 17 * h + (int)(*p & 0xff);
   61|   349k|  }
   62|  54.2k|  return (int)(h % size);
   63|  54.2k|}

_Z21initBuiltinFontTablesv:
 4262|     13|void initBuiltinFontTables() {
 4263|     13|  builtinFonts[0].widths = new BuiltinFontWidths(courierWidthsTab, 315);
 4264|     13|  builtinFonts[1].widths = new BuiltinFontWidths(courierBoldWidthsTab, 315);
 4265|     13|  builtinFonts[2].widths = new BuiltinFontWidths(courierBoldObliqueWidthsTab, 315);
 4266|     13|  builtinFonts[3].widths = new BuiltinFontWidths(courierObliqueWidthsTab, 315);
 4267|     13|  builtinFonts[4].widths = new BuiltinFontWidths(helveticaWidthsTab, 315);
 4268|     13|  builtinFonts[5].widths = new BuiltinFontWidths(helveticaBoldWidthsTab, 316);
 4269|     13|  builtinFonts[6].widths = new BuiltinFontWidths(helveticaBoldObliqueWidthsTab, 315);
 4270|     13|  builtinFonts[7].widths = new BuiltinFontWidths(helveticaObliqueWidthsTab, 315);
 4271|     13|  builtinFonts[8].widths = new BuiltinFontWidths(symbolWidthsTab, 190);
 4272|     13|  builtinFonts[9].widths = new BuiltinFontWidths(timesBoldWidthsTab, 315);
 4273|     13|  builtinFonts[10].widths = new BuiltinFontWidths(timesBoldItalicWidthsTab, 315);
 4274|     13|  builtinFonts[11].widths = new BuiltinFontWidths(timesItalicWidthsTab, 315);
 4275|     13|  builtinFonts[12].widths = new BuiltinFontWidths(timesRomanWidthsTab, 315);
 4276|     13|  builtinFonts[13].widths = new BuiltinFontWidths(zapfDingbatsWidthsTab, 202);
 4277|     13|}
_Z21freeBuiltinFontTablesv:
 4279|     13|void freeBuiltinFontTables() {
 4280|     13|  int i;
 4281|       |
 4282|    195|  for (i = 0; i < 14; ++i) {
  ------------------
  |  Branch (4282:15): [True: 182, False: 13]
  ------------------
 4283|    182|    delete builtinFonts[i].widths;
 4284|    182|  }
 4285|     13|}

_ZN9CMapCacheC2Ev:
  387|     13|CMapCache::CMapCache() {
  388|     13|  int i;
  389|       |
  390|     65|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|     65|#define cMapCacheSize 4
  ------------------
  |  Branch (390:15): [True: 52, False: 13]
  ------------------
  391|     52|    cache[i] = NULL;
  392|     52|  }
  393|     13|}
_ZN9CMapCacheD2Ev:
  395|     13|CMapCache::~CMapCache() {
  396|     13|  int i;
  397|       |
  398|     65|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|     65|#define cMapCacheSize 4
  ------------------
  |  Branch (398:15): [True: 52, False: 13]
  ------------------
  399|     52|    if (cache[i]) {
  ------------------
  |  Branch (399:9): [True: 0, False: 52]
  ------------------
  400|      0|      cache[i]->decRefCnt();
  401|      0|    }
  402|     52|  }
  403|     13|}

_ZN22CharCodeToUnicodeCacheC2Ei:
  709|     26|CharCodeToUnicodeCache::CharCodeToUnicodeCache(int sizeA) {
  710|     26|  int i;
  711|       |
  712|     26|  size = sizeA;
  713|     26|  cache = (CharCodeToUnicode **)gmallocn(size, sizeof(CharCodeToUnicode *));
  714|    130|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (714:15): [True: 104, False: 26]
  ------------------
  715|    104|    cache[i] = NULL;
  716|    104|  }
  717|     26|}
_ZN22CharCodeToUnicodeCacheD2Ev:
  719|     26|CharCodeToUnicodeCache::~CharCodeToUnicodeCache() {
  720|     26|  int i;
  721|       |
  722|    130|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (722:15): [True: 104, False: 26]
  ------------------
  723|    104|    if (cache[i]) {
  ------------------
  |  Branch (723:9): [True: 0, False: 104]
  ------------------
  724|      0|      cache[i]->decRefCnt();
  725|      0|    }
  726|    104|  }
  727|     26|  gfree(cache);
  728|     26|}

_Z5error13ErrorCategorylPKcz:
   46|    195|		 const char *msg, ...) {
   47|    195|  va_list args;
   48|    195|  GString *s, *sanitized;
   49|    195|  char c;
   50|    195|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|    195|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 195, False: 0]
  |  Branch (53:20): [True: 195, False: 0]
  |  Branch (53:36): [True: 0, False: 195]
  ------------------
   54|      0|    return;
   55|      0|  }
   56|    195|  va_start(args, msg);
   57|    195|  s = GString::formatv(msg, args);
   58|    195|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|    195|  sanitized = new GString();
   63|  6.94k|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 6.74k, False: 195]
  ------------------
   64|  6.74k|    c = s->getChar(i);
   65|  6.74k|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 6.74k, False: 0]
  |  Branch (65:22): [True: 6.74k, False: 0]
  ------------------
   66|  6.74k|      sanitized->append(c);
   67|  6.74k|    } else {
   68|      0|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|      0|    }
   70|  6.74k|  }
   71|       |
   72|    195|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 195]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|    195|  } else {
   75|    195|    fflush(stdout);
   76|    195|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 195]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|    195|    } else {
   80|    195|      fprintf(stderr, "%s: %s\n",
   81|    195|	      errorCategoryNames[category], sanitized->getCString());
   82|    195|    }
   83|    195|    fflush(stderr);
   84|    195|  }
   85|       |
   86|    195|  delete s;
   87|    195|  delete sanitized;
   88|    195|}

_ZN13GfxColorSpaceC2Ev:
   98|     26|GfxColorSpace::GfxColorSpace() {
   99|     26|  overprintMask = 0x0f;
  100|     26|  defaultColorSpace = gFalse;
  ------------------
  |  |   18|     26|#define gFalse 0
  ------------------
  101|     26|}
_ZN13GfxColorSpace6createE17GfxColorSpaceMode:
  167|     26|GfxColorSpace *GfxColorSpace::create(GfxColorSpaceMode mode) {
  168|     26|  GfxColorSpace *cs;
  169|       |
  170|     26|  cs = NULL;
  171|     26|  if (mode == csDeviceGray) {
  ------------------
  |  Branch (171:7): [True: 26, False: 0]
  ------------------
  172|     26|    cs = new GfxDeviceGrayColorSpace();
  173|     26|  } else if (mode == csDeviceRGB) {
  ------------------
  |  Branch (173:14): [True: 0, False: 0]
  ------------------
  174|      0|    cs = new GfxDeviceRGBColorSpace();
  175|      0|  } else if (mode == csDeviceCMYK) {
  ------------------
  |  Branch (175:14): [True: 0, False: 0]
  ------------------
  176|      0|    cs = new GfxDeviceCMYKColorSpace();
  177|      0|  }
  178|     26|  return cs;
  179|     26|}
_ZN23GfxDeviceGrayColorSpaceC2Ev:
  203|     26|GfxDeviceGrayColorSpace::GfxDeviceGrayColorSpace() {
  204|     26|}
_ZN7GfxPathC2Ev:
 4353|     13|GfxPath::GfxPath() {
 4354|     13|  justMoved = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4355|     13|  size = 16;
 4356|     13|  n = 0;
 4357|     13|  firstX = firstY = 0;
 4358|     13|  subpaths = (GfxSubpath **)gmallocn(size, sizeof(GfxSubpath *));
 4359|     13|}
_ZN8GfxStateC2EddP12PDFRectangleii:
 4493|     13|		   ) {
 4494|     13|  double kx, ky;
 4495|       |
 4496|     13|  hDPI = hDPIA;
 4497|     13|  vDPI = vDPIA;
 4498|     13|  rotate = rotateA;
 4499|     13|  px1 = pageBox->x1;
 4500|     13|  py1 = pageBox->y1;
 4501|     13|  px2 = pageBox->x2;
 4502|     13|  py2 = pageBox->y2;
 4503|     13|  kx = hDPI / 72.0;
 4504|     13|  ky = vDPI / 72.0;
 4505|     13|  if (rotate == 90) {
  ------------------
  |  Branch (4505:7): [True: 1, False: 12]
  ------------------
 4506|      1|    ctm[0] = 0;
 4507|      1|    ctm[1] = upsideDown ? ky : -ky;
  ------------------
  |  Branch (4507:14): [True: 0, False: 1]
  ------------------
 4508|      1|    ctm[2] = kx;
 4509|      1|    ctm[3] = 0;
 4510|      1|    ctm[4] = -kx * py1;
 4511|      1|    ctm[5] = ky * (upsideDown ? -px1 : px2);
  ------------------
  |  Branch (4511:20): [True: 0, False: 1]
  ------------------
 4512|      1|    pageWidth = kx * (py2 - py1);
 4513|      1|    pageHeight = ky * (px2 - px1);
 4514|     12|  } else if (rotate == 180) {
  ------------------
  |  Branch (4514:14): [True: 1, False: 11]
  ------------------
 4515|      1|    ctm[0] = -kx;
 4516|      1|    ctm[1] = 0;
 4517|      1|    ctm[2] = 0;
 4518|      1|    ctm[3] = upsideDown ? ky : -ky;
  ------------------
  |  Branch (4518:14): [True: 0, False: 1]
  ------------------
 4519|      1|    ctm[4] = kx * px2;
 4520|      1|    ctm[5] = ky * (upsideDown ? -py1 : py2);
  ------------------
  |  Branch (4520:20): [True: 0, False: 1]
  ------------------
 4521|      1|    pageWidth = kx * (px2 - px1);
 4522|      1|    pageHeight = ky * (py2 - py1);
 4523|     11|  } else if (rotate == 270) {
  ------------------
  |  Branch (4523:14): [True: 1, False: 10]
  ------------------
 4524|      1|    ctm[0] = 0;
 4525|      1|    ctm[1] = upsideDown ? -ky : ky;
  ------------------
  |  Branch (4525:14): [True: 0, False: 1]
  ------------------
 4526|      1|    ctm[2] = -kx;
 4527|      1|    ctm[3] = 0;
 4528|      1|    ctm[4] = kx * py2;
 4529|      1|    ctm[5] = ky * (upsideDown ? px2 : -px1);
  ------------------
  |  Branch (4529:20): [True: 0, False: 1]
  ------------------
 4530|      1|    pageWidth = kx * (py2 - py1);
 4531|      1|    pageHeight = ky * (px2 - px1);
 4532|     10|  } else {
 4533|     10|    ctm[0] = kx;
 4534|     10|    ctm[1] = 0;
 4535|     10|    ctm[2] = 0;
 4536|     10|    ctm[3] = upsideDown ? -ky : ky;
  ------------------
  |  Branch (4536:14): [True: 0, False: 10]
  ------------------
 4537|     10|    ctm[4] = -kx * px1;
 4538|     10|    ctm[5] = ky * (upsideDown ? py2 : -py1);
  ------------------
  |  Branch (4538:20): [True: 0, False: 10]
  ------------------
 4539|     10|    pageWidth = kx * (px2 - px1);
 4540|     10|    pageHeight = ky * (py2 - py1);
 4541|     10|  }
 4542|       |
 4543|     13|  fillColorSpace = GfxColorSpace::create(csDeviceGray);
 4544|     13|  strokeColorSpace = GfxColorSpace::create(csDeviceGray);
 4545|     13|  fillColor.c[0] = 0;
 4546|     13|  strokeColor.c[0] = 0;
 4547|     13|  fillPattern = NULL;
 4548|     13|  strokePattern = NULL;
 4549|     13|  blendMode = gfxBlendNormal;
 4550|     13|  fillOpacity = 1;
 4551|     13|  strokeOpacity = 1;
 4552|     13|  fillOverprint = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4553|     13|  strokeOverprint = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4554|     13|  renderingIntent = gfxRenderingIntentRelativeColorimetric;
 4555|     13|  overprintMode = 0;
 4556|     13|  transfer[0] = transfer[1] = transfer[2] = transfer[3] = NULL;
 4557|       |
 4558|     13|  lineWidth = 1;
 4559|     13|  lineDash = NULL;
 4560|     13|  lineDashLength = 0;
 4561|     13|  lineDashStart = 0;
 4562|     13|  flatness = 1;
 4563|     13|  lineJoin = 0;
 4564|     13|  lineCap = 0;
 4565|     13|  miterLimit = 10;
 4566|     13|  strokeAdjust = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4567|       |
 4568|     13|  font = NULL;
 4569|     13|  fontSize = 0;
 4570|     13|  textMat[0] = 1; textMat[1] = 0;
 4571|     13|  textMat[2] = 0; textMat[3] = 1;
 4572|     13|  textMat[4] = 0; textMat[5] = 0;
 4573|     13|  charSpace = 0;
 4574|     13|  wordSpace = 0;
 4575|     13|  horizScaling = 1;
 4576|     13|  leading = 0;
 4577|     13|  rise = 0;
 4578|     13|  render = 0;
 4579|       |
 4580|     13|  path = new GfxPath();
 4581|     13|  curX = curY = 0;
 4582|     13|  lineX = lineY = 0;
 4583|       |
 4584|     13|  clipXMin = 0;
 4585|     13|  clipYMin = 0;
 4586|     13|  clipXMax = pageWidth;
 4587|     13|  clipYMax = pageHeight;
 4588|       |
 4589|     13|  ignoreColorOps = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
 4590|       |
 4591|     13|  saved = NULL;
 4592|     13|}

_ZN11SysFontListC2Ev:
  374|     13|SysFontList::SysFontList() {
  375|     13|  fonts = new GList();
  376|     13|}
_ZN11SysFontListD2Ev:
  378|     13|SysFontList::~SysFontList() {
  379|     13|  deleteGList(fonts, SysFontInfo);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  380|     13|}
_ZN10KeyBindingC2EiiiPKc:
  560|    793|KeyBinding::KeyBinding(int codeA, int modsA, int contextA, const char *cmd0) {
  561|    793|  code = codeA;
  562|    793|  mods = modsA;
  563|    793|  context = contextA;
  564|    793|  cmds = new GList();
  565|    793|  cmds->append(new GString(cmd0));
  566|    793|}
_ZN10KeyBindingD2Ev:
  585|    793|KeyBinding::~KeyBinding() {
  586|    793|  deleteGList(cmds, GString);
  ------------------
  |  |   94|    793|  do {                                              \
  |  |   95|    793|    GList *_list = (list);                          \
  |  |   96|    793|    {                                               \
  |  |   97|    793|      int _i;                                       \
  |  |   98|  1.58k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 793, False: 793]
  |  |  ------------------
  |  |   99|    793|        delete (T*)_list->get(_i);                  \
  |  |  100|    793|      }                                             \
  |  |  101|    793|      delete _list;                                 \
  |  |  102|    793|    }                                               \
  |  |  103|    793|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  587|    793|}
_ZN12GlobalParamsC2EPKc:
  607|     13|GlobalParams::GlobalParams(const char *cfgFileName) {
  608|     13|  UnicodeMap *map;
  609|     13|  GString *fileName;
  610|     13|  FILE *f;
  611|     13|  int i;
  612|       |
  613|     13|#if MULTITHREADED
  614|     13|  gInitMutex(&mutex);
  ------------------
  |  |   51|     13|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  615|     13|  gInitMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   51|     13|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  616|     13|  gInitMutex(&cMapCacheMutex);
  ------------------
  |  |   51|     13|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  617|     13|#endif
  618|       |
  619|       |#ifdef _WIN32
  620|       |  tlsWin32ErrorInfo = TlsAlloc();
  621|       |#endif
  622|       |
  623|     13|  initBuiltinFontTables();
  624|       |
  625|       |  // scan the encoding in reverse because we want the lowest-numbered
  626|       |  // index for each char name ('space' is encoded twice)
  627|     13|  macRomanReverseMap = new NameToCharCode();
  628|  3.34k|  for (i = 255; i >= 0; --i) {
  ------------------
  |  Branch (628:17): [True: 3.32k, False: 13]
  ------------------
  629|  3.32k|    if (macRomanEncoding[i]) {
  ------------------
  |  Branch (629:9): [True: 2.89k, False: 429]
  ------------------
  630|  2.89k|      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);
  631|  2.89k|    }
  632|  3.32k|  }
  633|       |
  634|       |#ifdef _WIN32
  635|       |  // baseDir will be set by a call to setBaseDir
  636|       |  baseDir = new GString();
  637|       |#else
  638|     13|  baseDir = appendToPath(getHomeDir(), ".xpdf");
  639|     13|#endif
  640|     13|  configFileVars = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  641|     13|  setDataDirVar();
  642|     13|  nameToUnicode = new NameToCharCode();
  643|     13|  cidToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  644|     13|  unicodeToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  645|     13|  residentUnicodeMaps = new GHash();
  646|     13|  unicodeMaps = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  647|     13|  cMapDirs = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  648|     13|  toUnicodeDirs = new GList();
  649|     13|  unicodeRemapping = new UnicodeRemapping();
  650|     13|  fontFiles = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  651|     13|  fontDirs = new GList();
  652|     13|  ccFontFiles = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  653|     13|  base14SysFonts = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  654|     13|  sysFonts = new SysFontList();
  655|       |#if HAVE_PAPER_H
  656|       |  const char *paperName;
  657|       |  const struct paper *paperType;
  658|       |  paperinit();
  659|       |  if ((paperName = systempapername())) {
  660|       |    paperType = paperinfo(paperName);
  661|       |    psPaperWidth = (int)paperpswidth(paperType);
  662|       |    psPaperHeight = (int)paperpsheight(paperType);
  663|       |  } else {
  664|       |    error(errConfig, -1, "No paper information available - using defaults");
  665|       |    psPaperWidth = defPaperWidth;
  666|       |    psPaperHeight = defPaperHeight;
  667|       |  }
  668|       |  paperdone();
  669|       |#else
  670|     13|  psPaperWidth = defPaperWidth;
  ------------------
  |  |   46|     13|#define defPaperWidth  612    // American letter (8.5x11")
  ------------------
  671|     13|  psPaperHeight = defPaperHeight;
  ------------------
  |  |   47|     13|#define defPaperHeight 792
  ------------------
  672|     13|#endif
  673|     13|  psImageableLLX = psImageableLLY = 0;
  674|     13|  psImageableURX = psPaperWidth;
  675|     13|  psImageableURY = psPaperHeight;
  676|     13|  psCrop = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  677|     13|  psUseCropBoxAsPage = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  678|     13|  psExpandSmaller = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  679|     13|  psShrinkLarger = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  680|     13|  psCenter = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  681|     13|  psDuplex = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  682|     13|  psLevel = psLevel2;
  683|     13|  psResidentFonts = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  684|     13|  psResidentFonts16 = new GList();
  685|     13|  psResidentFontsCC = new GList();
  686|     13|  psEmbedType1 = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  687|     13|  psEmbedTrueType = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  688|     13|  psEmbedCIDPostScript = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  689|     13|  psEmbedCIDTrueType = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  690|     13|  psFontPassthrough = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  691|     13|  psPreload = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  692|     13|  psOPI = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  693|     13|  psASCIIHex = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  694|     13|  psLZW = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  695|     13|  psUncompressPreloadedImages = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  696|     13|  psMinLineWidth = 0;
  697|     13|  psRasterResolution = 300;
  698|     13|  psRasterMono = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  699|     13|  psRasterSliceSize = 20000000;
  700|     13|  psAlwaysRasterize = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  701|     13|  psNeverRasterize = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  702|     13|  textEncoding = new GString(defaultTextEncoding);
  703|       |#if defined(_WIN32)
  704|       |  textEOL = eolDOS;
  705|       |#else
  706|     13|  textEOL = eolUnix;
  707|     13|#endif
  708|     13|  textPageBreaks = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  709|     13|  textKeepTinyChars = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  710|     13|  initialZoom = new GString("125");
  711|     13|  defaultFitZoom = 0;
  712|     13|  zoomScaleFactor = 1;
  713|     13|  zoomValues = new GList();
  714|     13|  zoomValues->append(new GString("25"));
  715|     13|  zoomValues->append(new GString("50"));
  716|     13|  zoomValues->append(new GString("75"));
  717|     13|  zoomValues->append(new GString("100"));
  718|     13|  zoomValues->append(new GString("110"));
  719|     13|  zoomValues->append(new GString("125"));
  720|     13|  zoomValues->append(new GString("150"));
  721|     13|  zoomValues->append(new GString("175"));
  722|     13|  zoomValues->append(new GString("200"));
  723|     13|  zoomValues->append(new GString("300"));
  724|     13|  zoomValues->append(new GString("400"));
  725|     13|  zoomValues->append(new GString("600"));
  726|     13|  zoomValues->append(new GString("800"));
  727|     13|  initialDisplayMode = new GString("continuous");
  728|     13|  initialToolbarState = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  729|     13|  initialSidebarState = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  730|     13|  initialSidebarWidth = 0;
  731|     13|  initialSelectMode = new GString("linear");
  732|     13|  maxTileWidth = 1500;
  733|     13|  maxTileHeight = 1500;
  734|     13|  tileCacheSize = 10;
  735|     13|  workerThreads = 1;
  736|     13|  enableFreeType = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  737|     13|  disableFreeTypeHinting = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  738|     13|  antialias = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  739|     13|  vectorAntialias = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  740|     13|  imageMaskAntialias = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  741|     13|  antialiasPrinting = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  742|     13|  strokeAdjust = strokeAdjustNormal;
  743|     13|  screenType = screenUnset;
  744|     13|  screenSize = -1;
  745|     13|  screenDotRadius = -1;
  746|     13|  screenGamma = 1.0;
  747|     13|  screenBlackThreshold = 0.0;
  748|     13|  screenWhiteThreshold = 1.0;
  749|     13|  minLineWidth = 0.0;
  750|     13|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  751|     13|  drawAnnotations = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  752|     13|  drawFormFields = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  753|     13|  enableXFA = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  754|     13|  overprintPreview = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  755|     13|  paperColor = new GString("#ffffff");
  756|     13|  matteColor = new GString("#808080");
  757|     13|  fullScreenMatteColor = new GString("#000000");
  758|     13|  selectionColor = new GString("#8080ff");
  759|     13|  reverseVideoInvertImages = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  760|     13|  allowLinksToChangeZoom = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  761|     13|  launchCommand = NULL;
  762|     13|  movieCommand = NULL;
  763|     13|  defaultPrinter = NULL;
  764|     13|  mapNumericCharNames = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  765|     13|  mapUnknownCharNames = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  766|     13|  mapExtTrueTypeFontsViaUnicode = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  767|     13|  useTrueTypeUnicodeMapping = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  768|     13|  ignoreWrongSizeToUnicode = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  769|     13|  droppedFonts = new GHash(gTrue);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  770|     13|  separateRotatedText = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  771|     13|  createDefaultKeyBindings();
  772|     13|  popupMenuCmds = new GList();
  773|     13|  initStateFilePaths();
  774|     13|  saveSessionOnQuit = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  775|     13|  savePageNumbers = gTrue;
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  776|     13|  printCommands = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  777|     13|  printStatusInfo = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  778|     13|  errQuiet = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  779|     13|  debugLogFile = NULL;
  780|       |
  781|     13|  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);
  ------------------
  |  |   71|     13|#define cidToUnicodeCacheSize     4
  ------------------
  782|     13|  unicodeToUnicodeCache =
  783|     13|      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);
  ------------------
  |  |   72|     13|#define unicodeToUnicodeCacheSize 4
  ------------------
  784|     13|  unicodeMapCache = new UnicodeMapCache();
  785|     13|  cMapCache = new CMapCache();
  786|       |
  787|       |  // set up the initial nameToUnicode table
  788|  55.1k|  for (i = 0; nameToUnicodeTab[i].name; ++i) {
  ------------------
  |  Branch (788:15): [True: 55.1k, False: 13]
  ------------------
  789|  55.1k|    nameToUnicode->add(nameToUnicodeTab[i].name, nameToUnicodeTab[i].u);
  790|  55.1k|  }
  791|       |
  792|       |  // set up the residentUnicodeMaps table
  793|     13|  map = new UnicodeMap("Latin1", gFalse,
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  794|     13|		       latin1UnicodeMapRanges, latin1UnicodeMapLen);
  ------------------
  |  |   71|     13|#define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  795|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  796|     13|  map = new UnicodeMap("ASCII7", gFalse,
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  797|     13|		       ascii7UnicodeMapRanges, ascii7UnicodeMapLen);
  ------------------
  |  |  207|     13|#define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  798|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  799|     13|  map = new UnicodeMap("Symbol", gFalse,
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  800|     13|		       symbolUnicodeMapRanges, symbolUnicodeMapLen);
  ------------------
  |  |  332|     13|#define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  801|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  802|     13|  map = new UnicodeMap("ZapfDingbats", gFalse, zapfDingbatsUnicodeMapRanges,
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  803|     13|		       zapfDingbatsUnicodeMapLen);
  ------------------
  |  |  366|     13|#define zapfDingbatsUnicodeMapLen (sizeof(zapfDingbatsUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  804|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  805|     13|  map = new UnicodeMap("UTF-8", gTrue, &mapUTF8);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  806|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  807|     13|  map = new UnicodeMap("UCS-2", gTrue, &mapUCS2);
  ------------------
  |  |   17|     13|#define gTrue 1
  ------------------
  808|     13|  residentUnicodeMaps->add(map->getEncodingName(), map);
  809|       |
  810|       |  // look for a user config file, then a system-wide config file
  811|     13|  f = NULL;
  812|     13|  fileName = NULL;
  813|     13|  if (cfgFileName && cfgFileName[0]) {
  ------------------
  |  Branch (813:7): [True: 0, False: 13]
  |  Branch (813:22): [True: 0, False: 0]
  ------------------
  814|      0|    fileName = new GString(cfgFileName);
  815|      0|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (815:9): [True: 0, False: 0]
  ------------------
  816|      0|      delete fileName;
  817|      0|    }
  818|      0|  }
  819|     13|  if (!f) {
  ------------------
  |  Branch (819:7): [True: 13, False: 0]
  ------------------
  820|     13|    fileName = appendToPath(getHomeDir(), xpdfUserConfigFile);
  ------------------
  |  |   58|     13|#define xpdfUserConfigFile ".xpdfrc"
  ------------------
  821|     13|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (821:9): [True: 13, False: 0]
  ------------------
  822|     13|      delete fileName;
  823|     13|    }
  824|     13|  }
  825|     13|  if (!f) {
  ------------------
  |  Branch (825:7): [True: 13, False: 0]
  ------------------
  826|       |#ifdef _WIN32
  827|       |    char buf[512];
  828|       |    i = GetModuleFileNameA(NULL, buf, sizeof(buf));
  829|       |    if (i <= 0 || i >= sizeof(buf)) {
  830|       |      // error or path too long for buffer - just use the current dir
  831|       |      buf[0] = '\0';
  832|       |    }
  833|       |    fileName = grabPath(buf);
  834|       |    appendToPath(fileName, xpdfSysConfigFile);
  835|       |#else
  836|     13|    fileName = new GString(xpdfSysConfigFile);
  ------------------
  |  |   69|     13|#define xpdfSysConfigFile "/etc/xpdfrc"
  ------------------
  837|     13|#endif
  838|     13|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (838:9): [True: 13, False: 0]
  ------------------
  839|     13|      delete fileName;
  840|     13|    }
  841|     13|  }
  842|     13|  if (f) {
  ------------------
  |  Branch (842:7): [True: 0, False: 13]
  ------------------
  843|      0|    parseFile(fileName, f);
  844|      0|    delete fileName;
  845|      0|    fclose(f);
  846|      0|  }
  847|     13|}
_ZN12GlobalParams13setDataDirVarEv:
  849|     13|void GlobalParams::setDataDirVar() {
  850|     13|  GString *dir;
  851|       |
  852|       |#if defined(XPDFRC_DATADIR)
  853|       |  dir = new GString(XPDFRC_DATADIR);
  854|       |#elif defined(_WIN32)
  855|       |  wchar_t buf[512];
  856|       |  DWORD n = GetModuleFileNameW(NULL, buf, sizeof(buf) / sizeof(wchar_t));
  857|       |  if (n <= 0 || n >= sizeof(buf)) {
  858|       |    // error or path too long for buffer - just use the current dir
  859|       |    buf[0] = L'\0';
  860|       |  }
  861|       |  GString *path = fileNameToUTF8(buf);
  862|       |  dir = grabPath(path->getCString());
  863|       |  delete path;
  864|       |  appendToPath(dir, "data");
  865|       |#else
  866|       |  //~ may be useful to allow the options of using the install dir
  867|       |  //~   and/or the user's home dir (?)
  868|     13|  dir = new GString("./data");
  869|     13|#endif
  870|       |
  871|     13|  configFileVars->add(new GString("DATADIR"), dir);
  872|     13|}
_ZN12GlobalParams24createDefaultKeyBindingsEv:
  874|     13|void GlobalParams::createDefaultKeyBindings() {
  875|     13|  keyBindings = new GList();
  876|       |
  877|       |  //----- mouse buttons
  878|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  147|     13|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  879|     13|				     xpdfKeyContextAny, "startSelection"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  880|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  147|     13|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  193|     13|#define xpdfKeyModShift           (1 << 0)
  ------------------
  881|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  882|     13|				     "startExtendedSelection"));
  883|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  156|     13|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  884|     13|				     xpdfKeyContextAny, "endSelection"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  885|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  156|     13|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  193|     13|#define xpdfKeyModShift           (1 << 0)
  ------------------
  886|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  887|     13|				     "endSelection"));
  888|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseDoubleClick1,
  ------------------
  |  |  174|     13|#define xpdfKeyCodeMouseDoubleClick1  0x2301
  ------------------
  889|     13|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  890|     13|				     "selectWord"));
  891|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseTripleClick1,
  ------------------
  |  |  183|     13|#define xpdfKeyCodeMouseTripleClick1  0x2401
  ------------------
  892|     13|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  893|     13|				     "selectLine"));
  894|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  165|     13|#define xpdfKeyCodeMouseClick1        0x2201
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  895|     13|				     xpdfKeyContextAny, "followLinkNoSel"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  896|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  166|     13|#define xpdfKeyCodeMouseClick2        0x2202
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  897|     13|				     xpdfKeyContextOverLink,
  ------------------
  |  |  201|     13|#define xpdfKeyContextOverLink    (1 << 4)
  ------------------
  898|     13|				     "followLinkInNewTab"));
  899|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  148|     13|#define xpdfKeyCodeMousePress2        0x2002
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  900|     13|				     xpdfKeyContextAny, "startPan"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  901|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  157|     13|#define xpdfKeyCodeMouseRelease2      0x2102
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  902|     13|				     xpdfKeyContextAny, "endPan"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  903|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  149|     13|#define xpdfKeyCodeMousePress3        0x2003
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  904|     13|				     xpdfKeyContextAny, "postPopupMenu"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  905|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  150|     13|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  906|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  907|     13|				     "scrollUpPrevPage(16)"));
  908|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  151|     13|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  909|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  910|     13|				     "scrollDownNextPage(16)"));
  911|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  152|     13|#define xpdfKeyCodeMousePress6        0x2006
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  912|     13|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  913|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  153|     13|#define xpdfKeyCodeMousePress7        0x2007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  914|     13|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  915|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  150|     13|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  916|     13|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  917|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  151|     13|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  918|     13|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  919|       |
  920|       |  //----- control keys
  921|     13|  keyBindings->append(new KeyBinding('o', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  922|     13|				     xpdfKeyContextAny, "open"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  923|     13|  keyBindings->append(new KeyBinding('r', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  924|     13|				     xpdfKeyContextAny, "reload"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  925|     13|  keyBindings->append(new KeyBinding('f', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  926|     13|				     xpdfKeyContextAny, "find"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  927|     13|  keyBindings->append(new KeyBinding('g', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  928|     13|				     xpdfKeyContextAny, "findNext"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  929|     13|  keyBindings->append(new KeyBinding('c', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  930|     13|				     xpdfKeyContextAny, "copy"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  931|     13|  keyBindings->append(new KeyBinding('p', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  932|     13|				     xpdfKeyContextAny, "print"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  933|     13|  keyBindings->append(new KeyBinding('0', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  934|     13|				     xpdfKeyContextAny, "zoomPercent(125)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  935|     13|  keyBindings->append(new KeyBinding('+', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  936|     13|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  937|     13|  keyBindings->append(new KeyBinding('=', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  938|     13|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  939|     13|  keyBindings->append(new KeyBinding('-', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  940|     13|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  941|     13|  keyBindings->append(new KeyBinding('s', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  942|     13|				     xpdfKeyContextAny, "saveAs"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  943|     13|  keyBindings->append(new KeyBinding('t', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  944|     13|				     xpdfKeyContextAny, "newTab"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  945|     13|  keyBindings->append(new KeyBinding('n', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  946|     13|				     xpdfKeyContextAny, "newWindow"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  947|     13|  keyBindings->append(new KeyBinding('w', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  948|     13|				     xpdfKeyContextAny, "closeTabOrQuit"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  949|     13|  keyBindings->append(new KeyBinding('l', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  950|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  951|     13|				     "toggleFullScreenMode"));
  952|     13|  keyBindings->append(new KeyBinding('q', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  953|     13|				     xpdfKeyContextAny, "quit"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  954|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  130|     13|#define xpdfKeyCodeTab                0x1000
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  955|     13|				     xpdfKeyContextAny, "nextTab"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  956|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab,
  ------------------
  |  |  130|     13|#define xpdfKeyCodeTab                0x1000
  ------------------
  957|     13|				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  193|     13|#define xpdfKeyModShift           (1 << 0)
  ------------------
              				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  958|     13|				     xpdfKeyContextAny, "prevTab"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  959|     13|  keyBindings->append(new KeyBinding('?', xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  960|     13|				     xpdfKeyContextAny, "help"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  961|       |
  962|       |  //----- alt keys
  963|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  141|     13|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  195|     13|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  964|     13|				     xpdfKeyContextAny, "goBackward"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  965|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  142|     13|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  195|     13|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  966|     13|				     xpdfKeyContextAny, "goForward"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  967|       |
  968|       |  //----- home/end keys
  969|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  137|     13|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  970|     13|				     xpdfKeyContextAny, "gotoPage(1)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  971|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  137|     13|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  972|     13|				     xpdfKeyContextAny, "scrollToTopLeft"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  973|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  138|     13|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  974|     13|				     xpdfKeyContextAny, "gotoLastPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  975|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  138|     13|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  976|     13|				     xpdfKeyContextAny,
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  977|     13|				     "scrollToBottomRight"));
  978|       |
  979|       |  //----- pgup/pgdn keys
  980|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  139|     13|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  981|     13|				     xpdfKeyContextAny, "pageUp"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  982|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  140|     13|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  983|     13|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  984|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|     13|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  985|     13|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  986|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|     13|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  987|     13|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
  988|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|     13|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  989|     13|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|     13|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  990|     13|				     "prevPageNoScroll"));
  991|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|     13|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  992|     13|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|     13|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  993|     13|				     "nextPageNoScroll"));
  994|       |
  995|       |  //----- esc key
  996|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  134|     13|#define xpdfKeyCodeEsc                0x1004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
  997|     13|				     xpdfKeyContextFullScreen,
  ------------------
  |  |  197|     13|#define xpdfKeyContextFullScreen  (1 << 0)
  ------------------
  998|     13|				     "windowMode"));
  999|       |
 1000|       |  //----- arrow keys
 1001|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  141|     13|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1002|     13|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1003|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  142|     13|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1004|     13|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1005|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  143|     13|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1006|     13|				     xpdfKeyContextAny, "scrollUp(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1007|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  144|     13|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1008|     13|				     xpdfKeyContextAny, "scrollDown(16)"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1009|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|     13|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1010|     13|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1011|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|     13|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1012|     13|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1013|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|     13|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1014|     13|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|     13|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1015|     13|				     "prevPageNoScroll"));
 1016|     13|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|     13|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|     13|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1017|     13|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|     13|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1018|     13|				     "nextPageNoScroll"));
 1019|       |
 1020|       |  //----- letter keys
 1021|     13|  keyBindings->append(new KeyBinding(' ', xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1022|     13|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1023|     13|  keyBindings->append(new KeyBinding('g', xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1024|     13|				     xpdfKeyContextAny, "focusToPageNum"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1025|     13|  keyBindings->append(new KeyBinding('z', xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1026|     13|				     xpdfKeyContextAny, "zoomFitPage"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1027|     13|  keyBindings->append(new KeyBinding('w', xpdfKeyModNone,
  ------------------
  |  |  192|     13|#define xpdfKeyModNone            0
  ------------------
 1028|     13|				     xpdfKeyContextAny, "zoomFitWidth"));
  ------------------
  |  |  196|     13|#define xpdfKeyContextAny         0
  ------------------
 1029|     13|}
_ZN12GlobalParams18initStateFilePathsEv:
 1031|     13|void GlobalParams::initStateFilePaths() {
 1032|       |#ifdef _WIN32
 1033|       |  char path[MAX_PATH];
 1034|       |  if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL,
 1035|       |		       SHGFP_TYPE_CURRENT, path) != S_OK) {
 1036|       |    return;
 1037|       |  }
 1038|       |  GString *dir = appendToPath(new GString(path), "xpdf");
 1039|       |  CreateDirectoryA(dir->getCString(), NULL);
 1040|       |  pagesFile = appendToPath(dir->copy(), "xpdf.pages");
 1041|       |  tabStateFile = appendToPath(dir->copy(), "xpdf.tab-state");
 1042|       |  sessionFile = appendToPath(dir, "xpdf.session");
 1043|       |#else
 1044|     13|  pagesFile = appendToPath(getHomeDir(), ".xpdf.pages");
 1045|     13|  tabStateFile = appendToPath(getHomeDir(), ".xpdf.tab-state");
 1046|     13|  sessionFile = appendToPath(getHomeDir(), ".xpdf.session");
 1047|     13|#endif
 1048|     13|}
_ZN12GlobalParamsD2Ev:
 2179|     13|GlobalParams::~GlobalParams() {
 2180|     13|  GHashIter *iter;
 2181|     13|  GString *key;
 2182|     13|  GList *list;
 2183|       |
 2184|     13|  freeBuiltinFontTables();
 2185|       |
 2186|     13|  delete macRomanReverseMap;
 2187|       |
 2188|     13|  delete baseDir;
 2189|     13|  deleteGHash(configFileVars, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     26|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 13, False: 13]
  |  |  ------------------
  |  |   68|     13|        delete (T*)_p;                             \
  |  |   69|     13|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2190|     13|  delete nameToUnicode;
 2191|     13|  deleteGHash(cidToUnicodes, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2192|     13|  deleteGHash(unicodeToUnicodes, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2193|     13|  deleteGHash(residentUnicodeMaps, UnicodeMap);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     91|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 78, False: 13]
  |  |  ------------------
  |  |   68|     78|        delete (T*)_p;                             \
  |  |   69|     78|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2194|     13|  deleteGHash(unicodeMaps, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2195|     13|  deleteGList(toUnicodeDirs, GString);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2196|     13|  delete unicodeRemapping;
 2197|     13|  deleteGHash(fontFiles, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2198|     13|  deleteGList(fontDirs, GString);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2199|     13|  deleteGHash(ccFontFiles, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2200|     13|  deleteGHash(base14SysFonts, Base14FontInfo);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2201|     13|  delete sysFonts;
 2202|     13|  deleteGHash(psResidentFonts, GString);
  ------------------
  |  |   60|     13|  do {                                             \
  |  |   61|     13|    GHash *_hash = (hash);                         \
  |  |   62|     13|    {                                              \
  |  |   63|     13|      GHashIter *_iter;                            \
  |  |   64|     13|      GString *_key;                               \
  |  |   65|     13|      void *_p;                                    \
  |  |   66|     13|      _hash->startIter(&_iter);                    \
  |  |   67|     13|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 13]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|     13|      delete _hash;                                \
  |  |   71|     13|    }                                              \
  |  |   72|     13|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2203|     13|  deleteGList(psResidentFonts16, PSFontParam16);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2204|     13|  deleteGList(psResidentFontsCC, PSFontParam16);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2205|     13|  delete textEncoding;
 2206|     13|  delete initialZoom;
 2207|     13|  deleteGList(zoomValues, GString);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|    182|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 169, False: 13]
  |  |  ------------------
  |  |   99|    169|        delete (T*)_list->get(_i);                  \
  |  |  100|    169|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2208|     13|  delete initialDisplayMode;
 2209|     13|  delete initialSelectMode;
 2210|     13|  if (paperColor) {
  ------------------
  |  Branch (2210:7): [True: 13, False: 0]
  ------------------
 2211|     13|    delete paperColor;
 2212|     13|  }
 2213|     13|  if (matteColor) {
  ------------------
  |  Branch (2213:7): [True: 13, False: 0]
  ------------------
 2214|     13|    delete matteColor;
 2215|     13|  }
 2216|     13|  if (fullScreenMatteColor) {
  ------------------
  |  Branch (2216:7): [True: 13, False: 0]
  ------------------
 2217|     13|    delete fullScreenMatteColor;
 2218|     13|  }
 2219|     13|  if (selectionColor) {
  ------------------
  |  Branch (2219:7): [True: 13, False: 0]
  ------------------
 2220|     13|    delete selectionColor;
 2221|     13|  }
 2222|     13|  if (launchCommand) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 13]
  ------------------
 2223|      0|    delete launchCommand;
 2224|      0|  }
 2225|     13|  if (movieCommand) {
  ------------------
  |  Branch (2225:7): [True: 0, False: 13]
  ------------------
 2226|      0|    delete movieCommand;
 2227|      0|  }
 2228|     13|  if (defaultPrinter) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 13]
  ------------------
 2229|      0|    delete defaultPrinter;
 2230|      0|  }
 2231|     13|  delete droppedFonts;
 2232|     13|  deleteGList(keyBindings, KeyBinding);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|    806|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 793, False: 13]
  |  |  ------------------
  |  |   99|    793|        delete (T*)_list->get(_i);                  \
  |  |  100|    793|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2233|     13|  deleteGList(popupMenuCmds, PopupMenuCmd);
  ------------------
  |  |   94|     13|  do {                                              \
  |  |   95|     13|    GList *_list = (list);                          \
  |  |   96|     13|    {                                               \
  |  |   97|     13|      int _i;                                       \
  |  |   98|     13|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 13]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|     13|      delete _list;                                 \
  |  |  102|     13|    }                                               \
  |  |  103|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2234|     13|  delete pagesFile;
 2235|     13|  delete tabStateFile;
 2236|     13|  delete sessionFile;
 2237|     13|  delete debugLogFile;
 2238|       |
 2239|     13|  cMapDirs->startIter(&iter);
 2240|     13|  while (cMapDirs->getNext(&iter, &key, (void **)&list)) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 13]
  ------------------
 2241|      0|    deleteGList(list, GString);
  ------------------
  |  |   94|      0|  do {                                              \
  |  |   95|      0|    GList *_list = (list);                          \
  |  |   96|      0|    {                                               \
  |  |   97|      0|      int _i;                                       \
  |  |   98|      0|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 0]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|      0|      delete _list;                                 \
  |  |  102|      0|    }                                               \
  |  |  103|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2242|      0|  }
 2243|     13|  delete cMapDirs;
 2244|       |
 2245|     13|  delete cidToUnicodeCache;
 2246|     13|  delete unicodeToUnicodeCache;
 2247|     13|  delete unicodeMapCache;
 2248|     13|  delete cMapCache;
 2249|       |
 2250|     13|#if MULTITHREADED
 2251|     13|  gDestroyMutex(&mutex);
  ------------------
  |  |   52|     13|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2252|     13|  gDestroyMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   52|     13|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2253|     13|  gDestroyMutex(&cMapCacheMutex);
  ------------------
  |  |   52|     13|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2254|     13|#endif
 2255|     13|}
_ZN12GlobalParams14setupBaseFontsEPKc:
 2347|     13|void GlobalParams::setupBaseFonts(const char *dir) {
 2348|     13|  GString *fontName;
 2349|     13|  GString *fileName;
 2350|     13|  int fontNum;
 2351|     13|  const char *s;
 2352|     13|  Base14FontInfo *base14;
 2353|       |#ifdef _WIN32
 2354|       |  char winFontDir[MAX_PATH];
 2355|       |#endif
 2356|       |#ifdef __APPLE__
 2357|       |  static const char *macFontExts[3] = { "dfont", "ttc", "ttf" };
 2358|       |  GList *dfontFontNames;
 2359|       |  GBool found;
 2360|       |  int k;
 2361|       |#endif
 2362|     13|  FILE *f;
 2363|     13|  int i, j;
 2364|       |
 2365|       |#ifdef _WIN32
 2366|       |  getWinFontDir(winFontDir);
 2367|       |#endif
 2368|       |#ifdef __APPLE__
 2369|       |  dfontFontNames = NULL;
 2370|       |#endif
 2371|    195|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2371:15): [True: 182, False: 13]
  ------------------
 2372|    182|    if (fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 182]
  ------------------
 2373|      0|      continue;
 2374|      0|    }
 2375|    182|    fontName = new GString(displayFontTab[i].name);
 2376|    182|    fileName = NULL;
 2377|    182|    fontNum = 0;
 2378|    182|    if (dir) {
  ------------------
  |  Branch (2378:9): [True: 0, False: 182]
  ------------------
 2379|      0|      fileName = appendToPath(new GString(dir), displayFontTab[i].t1FileName);
 2380|      0|      if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2380:11): [True: 0, False: 0]
  ------------------
 2381|      0|	fclose(f);
 2382|      0|      } else {
 2383|      0|	delete fileName;
 2384|      0|	fileName = NULL;
 2385|      0|      }
 2386|      0|    }
 2387|       |#ifdef _WIN32
 2388|       |    if (!fileName && winFontDir[0] && displayFontTab[i].ttFileName) {
 2389|       |      fileName = appendToPath(new GString(winFontDir),
 2390|       |			      displayFontTab[i].ttFileName);
 2391|       |      if ((f = fopen(fileName->getCString(), "rb"))) {
 2392|       |	fclose(f);
 2393|       |      } else {
 2394|       |	delete fileName;
 2395|       |	fileName = NULL;
 2396|       |      }
 2397|       |    }
 2398|       |#endif
 2399|       |#ifdef __APPLE__
 2400|       |    // Check for Mac OS X system fonts.
 2401|       |    s = displayFontTab[i].macFileName;
 2402|       |    if (dfontFontNames && i > 0 &&
 2403|       |	(!s || strcmp(s, displayFontTab[i-1].macFileName))) {
 2404|       |      deleteGList(dfontFontNames, GString);
 2405|       |      dfontFontNames = NULL;
 2406|       |    }
 2407|       |    if (!fileName && s) {
 2408|       |      for (j = 0; j < 3; ++j) {
 2409|       |	fileName = GString::format("{0:s}/{1:s}.{2:s}",
 2410|       |				   macSystemFontPath, s, macFontExts[j]);
 2411|       |	if (!(f = fopen(fileName->getCString(), "rb"))) {
 2412|       |	  delete fileName;
 2413|       |	  fileName = NULL;
 2414|       |	} else {
 2415|       |	  fclose(f);
 2416|       |	  found = gFalse;
 2417|       |	  // for .dfont or .ttc, we need to scan the font list
 2418|       |	  if (j < 2) {
 2419|       |	    if (!dfontFontNames) {
 2420|       |	      dfontFontNames =
 2421|       |	          FoFiIdentifier::getFontList(fileName->getCString());
 2422|       |	    }
 2423|       |	    if (dfontFontNames) {
 2424|       |	      for (k = 0; k < dfontFontNames->getLength(); ++k) {
 2425|       |		if (macFontNameMatches((GString *)dfontFontNames->get(k),
 2426|       |				       displayFontTab[i].macFontName)) {
 2427|       |		  fontNum = k;
 2428|       |		  found = gTrue;
 2429|       |		  break;
 2430|       |		}
 2431|       |	      }
 2432|       |	    }
 2433|       |	  // for .ttf, we just use the font
 2434|       |	  } else {
 2435|       |	    found = gTrue;
 2436|       |	  }
 2437|       |	  if (!found) {
 2438|       |	    delete fileName;
 2439|       |	    fileName = NULL;
 2440|       |	  }
 2441|       |	  break;
 2442|       |	}
 2443|       |      }
 2444|       |    }
 2445|       |#endif // __APPLE__
 2446|       |    // On Linux, this checks the "standard" ghostscript font
 2447|       |    // directories.  On Windows, it checks the "standard" system font
 2448|       |    // directories (because SHGetSpecialFolderPath(CSIDL_FONTS)
 2449|       |    // doesn't work on Win 2k Server or Win2003 Server, or with older
 2450|       |    // versions of shell32.dll).
 2451|       |#ifdef _WIN32
 2452|       |    s = displayFontTab[i].ttFileName;
 2453|       |#else
 2454|    182|    s = displayFontTab[i].t1FileName;
 2455|    182|#endif
 2456|    182|    if (!fileName && s) {
  ------------------
  |  Branch (2456:9): [True: 182, False: 0]
  |  Branch (2456:22): [True: 182, False: 0]
  ------------------
 2457|  1.09k|      for (j = 0; !fileName && displayFontDirs[j]; ++j) {
  ------------------
  |  Branch (2457:19): [True: 1.09k, False: 0]
  |  Branch (2457:32): [True: 910, False: 182]
  ------------------
 2458|    910|	fileName = appendToPath(new GString(displayFontDirs[j]), s);
 2459|    910|	if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2459:6): [True: 0, False: 910]
  ------------------
 2460|      0|	  fclose(f);
 2461|    910|	} else {
 2462|    910|	  delete fileName;
 2463|    910|	  fileName = NULL;
 2464|    910|	}
 2465|    910|      }
 2466|    182|    }
 2467|    182|    if (!fileName) {
  ------------------
  |  Branch (2467:9): [True: 182, False: 0]
  ------------------
 2468|    182|      delete fontName;
 2469|    182|      continue;
 2470|    182|    }
 2471|      0|    base14SysFonts->add(fontName, new Base14FontInfo(fileName, fontNum, 0));
 2472|      0|  }
 2473|       |#ifdef __APPLE__
 2474|       |  if (dfontFontNames) {
 2475|       |    deleteGList(dfontFontNames, GString);
 2476|       |  }
 2477|       |#endif
 2478|    195|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2478:15): [True: 182, False: 13]
  ------------------
 2479|    182|    if (!base14SysFonts->lookup(displayFontTab[i].name) &&
  ------------------
  |  Branch (2479:9): [True: 182, False: 0]
  ------------------
 2480|    182|	!fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2480:2): [True: 182, False: 0]
  ------------------
 2481|    182|      if (displayFontTab[i].obliqueFont &&
  ------------------
  |  Branch (2481:11): [True: 52, False: 130]
  ------------------
 2482|    182|	  ((base14 = (Base14FontInfo *)base14SysFonts
  ------------------
  |  Branch (2482:4): [True: 0, False: 52]
  ------------------
 2483|     52|	                 ->lookup(displayFontTab[i].obliqueFont)))) {
 2484|      0|	base14SysFonts->add(
 2485|      0|	        new GString(displayFontTab[i].name),
 2486|      0|		new Base14FontInfo(base14->fileName->copy(),
 2487|      0|				   base14->fontNum,
 2488|      0|				   displayFontTab[i].obliqueFactor));
 2489|    182|      } else {
 2490|    182|	error(errConfig, -1, "No display font for '{0:s}'",
 2491|    182|	      displayFontTab[i].name);
 2492|    182|      }
 2493|    182|    }
 2494|    182|  }
 2495|       |#ifdef _WIN32
 2496|       |  if (winFontDir[0]) {
 2497|       |    sysFonts->scanWindowsFonts(winFontDir);
 2498|       |  }
 2499|       |#endif
 2500|       |#if HAVE_FONTCONFIG
 2501|       |  sysFonts->scanFontconfigFonts();
 2502|       |#endif
 2503|     13|}
_ZN12GlobalParams18getVectorAntialiasEv:
 3184|     13|GBool GlobalParams::getVectorAntialias() {
 3185|     13|  GBool f;
 3186|       |
 3187|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3188|     13|  f = vectorAntialias;
 3189|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3190|     13|  return f;
 3191|     13|}
_ZN12GlobalParams15getStrokeAdjustEv:
 3211|     13|StrokeAdjustMode GlobalParams::getStrokeAdjust() {
 3212|     13|  StrokeAdjustMode mode;
 3213|       |
 3214|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3215|     13|  mode = strokeAdjust;
 3216|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3217|     13|  return mode;
 3218|     13|}
_ZN12GlobalParams13getScreenTypeEv:
 3220|     13|ScreenType GlobalParams::getScreenType() {
 3221|     13|  ScreenType t;
 3222|       |
 3223|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3224|     13|  t = screenType;
 3225|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3226|     13|  return t;
 3227|     13|}
_ZN12GlobalParams13getScreenSizeEv:
 3229|     13|int GlobalParams::getScreenSize() {
 3230|     13|  int size;
 3231|       |
 3232|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3233|     13|  size = screenSize;
 3234|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3235|     13|  return size;
 3236|     13|}
_ZN12GlobalParams18getScreenDotRadiusEv:
 3238|     13|int GlobalParams::getScreenDotRadius() {
 3239|     13|  int r;
 3240|       |
 3241|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3242|     13|  r = screenDotRadius;
 3243|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3244|     13|  return r;
 3245|     13|}
_ZN12GlobalParams14getScreenGammaEv:
 3247|     13|double GlobalParams::getScreenGamma() {
 3248|     13|  double gamma;
 3249|       |
 3250|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3251|     13|  gamma = screenGamma;
 3252|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3253|     13|  return gamma;
 3254|     13|}
_ZN12GlobalParams23getScreenBlackThresholdEv:
 3256|     13|double GlobalParams::getScreenBlackThreshold() {
 3257|     13|  double thresh;
 3258|       |
 3259|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3260|     13|  thresh = screenBlackThreshold;
 3261|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3262|     13|  return thresh;
 3263|     13|}
_ZN12GlobalParams23getScreenWhiteThresholdEv:
 3265|     13|double GlobalParams::getScreenWhiteThreshold() {
 3266|     13|  double thresh;
 3267|       |
 3268|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3269|     13|  thresh = screenWhiteThreshold;
 3270|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3271|     13|  return thresh;
 3272|     13|}
_ZN12GlobalParams15getMinLineWidthEv:
 3274|     13|double GlobalParams::getMinLineWidth() {
 3275|     13|  double w;
 3276|       |
 3277|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3278|     13|  w = minLineWidth;
 3279|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3280|     13|  return w;
 3281|     13|}
_ZN12GlobalParams27getEnablePathSimplificationEv:
 3283|     13|GBool GlobalParams::getEnablePathSimplification() {
 3284|     13|  GBool en;
 3285|       |
 3286|     13|  lockGlobalParams;
  ------------------
  |  |   50|     13|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|     13|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3287|     13|  en = enablePathSimplification;
 3288|     13|  unlockGlobalParams;
  ------------------
  |  |   53|     13|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|     13|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3289|     13|  return en;
 3290|     13|}
_ZN12GlobalParams11getErrQuietEv:
 3562|    195|GBool GlobalParams::getErrQuiet() {
 3563|       |  // no locking -- this function may get called from inside a locked
 3564|       |  // section
 3565|    195|  return errQuiet;
 3566|    195|}

_ZN14NameToCharCodeC2Ev:
   25|     26|NameToCharCode::NameToCharCode() {
   26|     26|  int i;
   27|       |
   28|     26|  size = 31;
   29|     26|  len = 0;
   30|     26|  tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   31|    832|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (31:15): [True: 806, False: 26]
  ------------------
   32|    806|    tab[i].name = NULL;
   33|    806|  }
   34|     26|}
_ZN14NameToCharCodeD2Ev:
   36|     26|NameToCharCode::~NameToCharCode() {
   37|     26|  int i;
   38|       |
   39|   219k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (39:15): [True: 219k, False: 26]
  ------------------
   40|   219k|    if (tab[i].name) {
  ------------------
  |  Branch (40:9): [True: 58.0k, False: 161k]
  ------------------
   41|  58.0k|      gfree(tab[i].name);
   42|  58.0k|    }
   43|   219k|  }
   44|     26|  gfree(tab);
   45|     26|}
_ZN14NameToCharCode3addEPKcj:
   47|  58.0k|void NameToCharCode::add(const char *name, CharCode c) {
   48|  58.0k|  NameToCharCodeEntry *oldTab;
   49|  58.0k|  int h, i, oldSize;
   50|       |
   51|       |  // expand the table if necessary
   52|  58.0k|  if (len >= size / 2) {
  ------------------
  |  Branch (52:7): [True: 169, False: 57.8k]
  ------------------
   53|    169|    oldSize = size;
   54|    169|    oldTab = tab;
   55|    169|    size = 2*size + 1;
   56|    169|    tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   57|   437k|    for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (57:17): [True: 437k, False: 169]
  ------------------
   58|   437k|      tab[h].name = NULL;
   59|   437k|    }
   60|   218k|    for (i = 0; i < oldSize; ++i) {
  ------------------
  |  Branch (60:17): [True: 218k, False: 169]
  ------------------
   61|   218k|      if (oldTab[i].name) {
  ------------------
  |  Branch (61:11): [True: 109k, False: 109k]
  ------------------
   62|   109k|	h = hash(oldTab[i].name);
   63|   159k|	while (tab[h].name) {
  ------------------
  |  Branch (63:9): [True: 50.3k, False: 109k]
  ------------------
   64|  50.3k|	  if (++h == size) {
  ------------------
  |  Branch (64:8): [True: 0, False: 50.3k]
  ------------------
   65|      0|	    h = 0;
   66|      0|	  }
   67|  50.3k|	}
   68|   109k|	tab[h] = oldTab[i];
   69|   109k|      }
   70|   218k|    }
   71|    169|    gfree(oldTab);
   72|    169|  }
   73|       |
   74|       |  // add the new name
   75|  58.0k|  h = hash(name);
   76|   241k|  while (tab[h].name && strcmp(tab[h].name, name)) {
  ------------------
  |  Branch (76:10): [True: 183k, False: 58.0k]
  |  Branch (76:25): [True: 183k, False: 13]
  ------------------
   77|   183k|    if (++h == size) {
  ------------------
  |  Branch (77:9): [True: 39, False: 183k]
  ------------------
   78|     39|      h = 0;
   79|     39|    }
   80|   183k|  }
   81|  58.0k|  if (!tab[h].name) {
  ------------------
  |  Branch (81:7): [True: 58.0k, False: 13]
  ------------------
   82|  58.0k|    tab[h].name = copyString(name);
   83|  58.0k|  }
   84|  58.0k|  tab[h].c = c;
   85|       |
   86|  58.0k|  ++len;
   87|  58.0k|}
_ZN14NameToCharCode4hashEPKc:
  104|   167k|int NameToCharCode::hash(const char *name) {
  105|   167k|  const char *p;
  106|   167k|  unsigned int h;
  107|       |
  108|   167k|  h = 0;
  109|  1.96M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (109:18): [True: 1.79M, False: 167k]
  ------------------
  110|  1.79M|    h = 17 * h + (int)(*p & 0xff);
  111|  1.79M|  }
  112|   167k|  return (int)(h % size);
  113|   167k|}

_ZN6ObjectC2Ev:
   85|     13|    type(objNone) {}

_ZN9OutputDevC2Ev:
   39|     13|  OutputDev() {}
_ZN9OutputDevD2Ev:
   42|     13|  virtual ~OutputDev() {}

_ZN6PDFDocC2EP7GStringS1_S1_P7PDFCore:
   61|     13|	       GString *userPassword, PDFCore *coreA) {
   62|     13|  Object obj;
   63|     13|  GString *fileName1, *fileName2;
   64|       |#ifdef _WIN32
   65|       |  int n, i;
   66|       |#endif
   67|       |
   68|     13|  init(coreA);
   69|       |
   70|     13|  fileName = fileNameA;
   71|       |#ifdef _WIN32
   72|       |  n = fileName->getLength();
   73|       |  fileNameU = (wchar_t *)gmallocn(n + 1, sizeof(wchar_t));
   74|       |  for (i = 0; i < n; ++i) {
   75|       |    fileNameU[i] = (wchar_t)(fileName->getChar(i) & 0xff);
   76|       |  }
   77|       |  fileNameU[n] = L'\0';
   78|       |#endif
   79|       |
   80|     13|  fileName1 = fileName;
   81|       |
   82|       |  // try to open file
   83|     13|  fileName2 = NULL;
   84|       |#ifdef VMS
   85|       |  if (!(file = fopen(fileName1->getCString(), fopenReadMode, "ctx=stm"))) {
   86|       |    error(errIO, -1, "Couldn't open file '{0:t}'", fileName1);
   87|       |    errCode = errOpenFile;
   88|       |    return;
   89|       |  }
   90|       |#else
   91|     13|  if (!(file = fopen(fileName1->getCString(), fopenReadMode))) {
  ------------------
  |  |   53|     13|#  define fopenReadMode "rb"
  ------------------
  |  Branch (91:7): [True: 13, False: 0]
  ------------------
   92|     13|    fileName2 = fileName->copy();
   93|     13|    fileName2->lowerCase();
   94|     13|    if (!(file = fopen(fileName2->getCString(), fopenReadMode))) {
  ------------------
  |  |   53|     13|#  define fopenReadMode "rb"
  ------------------
  |  Branch (94:9): [True: 13, False: 0]
  ------------------
   95|     13|      fileName2->upperCase();
   96|     13|      if (!(file = fopen(fileName2->getCString(), fopenReadMode))) {
  ------------------
  |  |   53|     13|#  define fopenReadMode "rb"
  ------------------
  |  Branch (96:11): [True: 13, False: 0]
  ------------------
   97|     13|	error(errIO, -1, "Couldn't open file '{0:t}'", fileName);
   98|     13|	delete fileName2;
   99|     13|	errCode = errOpenFile;
  ------------------
  |  |   14|     13|#define errOpenFile         1	// couldn't open the PDF file
  ------------------
  100|     13|	return;
  101|     13|      }
  102|     13|    }
  103|      0|    delete fileName2;
  104|      0|  }
  105|      0|#endif
  106|       |
  107|       |  // create stream
  108|      0|  obj.initNull();
  109|      0|  str = new FileStream(file, 0, gFalse, 0, &obj);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  110|       |
  111|      0|  ok = setup(ownerPassword, userPassword);
  112|      0|}
_ZN6PDFDoc4initEP7PDFCore:
  246|     13|void PDFDoc::init(PDFCore *coreA) {
  247|     13|  ok = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  248|     13|  errCode = errNone;
  ------------------
  |  |   12|     13|#define errNone             0	// no error
  ------------------
  249|     13|  core = coreA;
  250|     13|  file = NULL;
  251|     13|  str = NULL;
  252|     13|  xref = NULL;
  253|     13|  catalog = NULL;
  254|     13|  annots = NULL;
  255|     13|#ifndef DISABLE_OUTLINE
  256|     13|  outline = NULL;
  257|     13|#endif
  258|     13|  optContent = NULL;
  259|     13|}
_ZN6PDFDocD2Ev:
  333|     13|PDFDoc::~PDFDoc() {
  334|     13|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 13]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|     13|#ifndef DISABLE_OUTLINE
  338|     13|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 13]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|     13|#endif
  342|     13|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 13]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|     13|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 13]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|     13|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 13]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|     13|  if (str) {
  ------------------
  |  Branch (351:7): [True: 0, False: 13]
  ------------------
  352|      0|    delete str;
  353|      0|  }
  354|     13|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 13]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|     13|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 13, False: 0]
  ------------------
  358|     13|    delete fileName;
  359|     13|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|     13|}

_ZN12PDFRectangleC2Ev:
   28|     13|  PDFRectangle() { x1 = y1 = x2 = y2 = 0; }

_ZN15SplashOutputDevC2E15SplashColorModeiiPhii:
  620|     13|				 GBool allowAntialiasA) {
  621|     13|  colorMode = colorModeA;
  622|     13|  bitmapRowPad = bitmapRowPadA;
  623|     13|  bitmapTopDown = bitmapTopDownA;
  624|     13|  bitmapUpsideDown = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  625|     13|  noComposite = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  626|     13|  allowAntialias = allowAntialiasA;
  627|     13|  vectorAntialias = allowAntialias &&
  ------------------
  |  Branch (627:21): [True: 13, False: 0]
  ------------------
  628|     13|		      globalParams->getVectorAntialias() &&
  ------------------
  |  Branch (628:9): [True: 13, False: 0]
  ------------------
  629|     13|		      colorMode != splashModeMono1;
  ------------------
  |  Branch (629:9): [True: 0, False: 13]
  ------------------
  630|     13|  setupScreenParams(72.0, 72.0);
  631|     13|  reverseVideo = reverseVideoA;
  632|     13|  splashColorCopy(paperColor, paperColorA);
  633|     13|  skipHorizText = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  634|     13|  skipRotatedText = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  635|       |
  636|     13|  xref = NULL;
  637|       |
  638|     13|  bitmap = new SplashBitmap(1, 1, bitmapRowPad, colorMode,
  639|     13|			    colorMode != splashModeMono1, bitmapTopDown, NULL);
  640|     13|  splash = new Splash(bitmap, vectorAntialias, NULL, &screenParams);
  641|     13|  splash->setMinLineWidth(globalParams->getMinLineWidth());
  642|     13|  splash->setStrokeAdjust(
  643|     13|		 mapStrokeAdjustMode[globalParams->getStrokeAdjust()]);
  644|     13|  splash->setEnablePathSimplification(
  645|     13|		 globalParams->getEnablePathSimplification());
  646|     13|  splash->clear(paperColor, 0);
  647|       |
  648|     13|  fontEngine = NULL;
  649|       |
  650|     13|  nT3Fonts = 0;
  651|     13|  t3GlyphStack = NULL;
  652|       |
  653|     13|  font = NULL;
  654|     13|  needFontUpdate = gFalse;
  ------------------
  |  |   18|     13|#define gFalse 0
  ------------------
  655|     13|  savedTextPath = NULL;
  656|     13|  savedClipPath = NULL;
  657|       |
  658|     13|  transpGroupStack = NULL;
  659|       |
  660|     13|  nestCount = 0;
  661|       |
  662|     13|  startPageCbk = NULL;
  663|     13|  startPageCbkData = NULL;
  664|     13|}
_ZN15SplashOutputDev17setupScreenParamsEdd:
  667|     13|void SplashOutputDev::setupScreenParams(double hDPI, double vDPI) {
  668|     13|  screenParams.size = globalParams->getScreenSize();
  669|     13|  screenParams.dotRadius = globalParams->getScreenDotRadius();
  670|     13|  screenParams.gamma = (SplashCoord)globalParams->getScreenGamma();
  671|     13|  screenParams.blackThreshold =
  672|     13|      (SplashCoord)globalParams->getScreenBlackThreshold();
  673|     13|  screenParams.whiteThreshold =
  674|     13|      (SplashCoord)globalParams->getScreenWhiteThreshold();
  675|     13|  switch (globalParams->getScreenType()) {
  676|      0|  case screenDispersed:
  ------------------
  |  Branch (676:3): [True: 0, False: 13]
  ------------------
  677|      0|    screenParams.type = splashScreenDispersed;
  678|      0|    if (screenParams.size < 0) {
  ------------------
  |  Branch (678:9): [True: 0, False: 0]
  ------------------
  679|      0|      screenParams.size = 4;
  680|      0|    }
  681|      0|    break;
  682|      0|  case screenClustered:
  ------------------
  |  Branch (682:3): [True: 0, False: 13]
  ------------------
  683|      0|    screenParams.type = splashScreenClustered;
  684|      0|    if (screenParams.size < 0) {
  ------------------
  |  Branch (684:9): [True: 0, False: 0]
  ------------------
  685|      0|      screenParams.size = 10;
  686|      0|    }
  687|      0|    break;
  688|      0|  case screenStochasticClustered:
  ------------------
  |  Branch (688:3): [True: 0, False: 13]
  ------------------
  689|      0|    screenParams.type = splashScreenStochasticClustered;
  690|      0|    if (screenParams.size < 0) {
  ------------------
  |  Branch (690:9): [True: 0, False: 0]
  ------------------
  691|      0|      screenParams.size = 64;
  692|      0|    }
  693|      0|    if (screenParams.dotRadius < 0) {
  ------------------
  |  Branch (693:9): [True: 0, False: 0]
  ------------------
  694|      0|      screenParams.dotRadius = 2;
  695|      0|    }
  696|      0|    break;
  697|     13|  case screenUnset:
  ------------------
  |  Branch (697:3): [True: 13, False: 0]
  ------------------
  698|     13|  default:
  ------------------
  |  Branch (698:3): [True: 0, False: 13]
  ------------------
  699|       |    // use clustered dithering for resolution >= 300 dpi
  700|       |    // (compare to 299.9 to avoid floating point issues)
  701|     13|    if (hDPI > 299.9 && vDPI > 299.9) {
  ------------------
  |  Branch (701:9): [True: 0, False: 13]
  |  Branch (701:25): [True: 0, False: 0]
  ------------------
  702|      0|      screenParams.type = splashScreenStochasticClustered;
  703|      0|      if (screenParams.size < 0) {
  ------------------
  |  Branch (703:11): [True: 0, False: 0]
  ------------------
  704|      0|	screenParams.size = 64;
  705|      0|      }
  706|      0|      if (screenParams.dotRadius < 0) {
  ------------------
  |  Branch (706:11): [True: 0, False: 0]
  ------------------
  707|      0|	screenParams.dotRadius = 2;
  708|      0|      }
  709|     13|    } else {
  710|     13|      screenParams.type = splashScreenDispersed;
  711|     13|      if (screenParams.size < 0) {
  ------------------
  |  Branch (711:11): [True: 13, False: 0]
  ------------------
  712|     13|	screenParams.size = 4;
  713|     13|      }
  714|     13|    }
  715|     13|  }
  716|     13|}
_ZN15SplashOutputDevD2Ev:
  718|     13|SplashOutputDev::~SplashOutputDev() {
  719|     13|  int i;
  720|       |
  721|     13|  for (i = 0; i < nT3Fonts; ++i) {
  ------------------
  |  Branch (721:15): [True: 0, False: 13]
  ------------------
  722|      0|    delete t3FontCache[i];
  723|      0|  }
  724|     13|  if (fontEngine) {
  ------------------
  |  Branch (724:7): [True: 0, False: 13]
  ------------------
  725|      0|    delete fontEngine;
  726|      0|  }
  727|     13|  if (splash) {
  ------------------
  |  Branch (727:7): [True: 13, False: 0]
  ------------------
  728|     13|    delete splash;
  729|     13|  }
  730|     13|  if (bitmap) {
  ------------------
  |  Branch (730:7): [True: 13, False: 0]
  ------------------
  731|     13|    delete bitmap;
  732|     13|  }
  733|     13|  if (savedTextPath) {
  ------------------
  |  Branch (733:7): [True: 0, False: 13]
  ------------------
  734|      0|    delete savedTextPath;
  735|      0|  }
  736|     13|  if (savedClipPath) {
  ------------------
  |  Branch (736:7): [True: 0, False: 13]
  ------------------
  737|      0|    delete savedClipPath;
  738|      0|  }
  739|     13|}
_ZN15SplashOutputDev8drawCharEP8GfxStateddddddjiPjiiii:
 2227|     13|			       GBool fill, GBool stroke, GBool makePath) {
 2228|     13|  if (skipHorizText || skipRotatedText) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 13]
  |  Branch (2228:24): [True: 0, False: 13]
  ------------------
 2229|      0|    double m[4];
 2230|      0|    state->getFontTransMat(&m[0], &m[1], &m[2], &m[3]);
 2231|       |    // this matches the 'diagonal' test in TextPage::updateFont()
 2232|      0|    GBool horiz = m[0] > 0 && fabs(m[1]) < 0.001 &&
  ------------------
  |  Branch (2232:19): [True: 0, False: 0]
  |  Branch (2232:31): [True: 0, False: 0]
  ------------------
 2233|      0|                  fabs(m[2]) < 0.001 && m[3] < 0;
  ------------------
  |  Branch (2233:19): [True: 0, False: 0]
  |  Branch (2233:41): [True: 0, False: 0]
  ------------------
 2234|      0|    if ((skipHorizText && horiz) || (skipRotatedText && !horiz)) {
  ------------------
  |  Branch (2234:10): [True: 0, False: 0]
  |  Branch (2234:27): [True: 0, False: 0]
  |  Branch (2234:38): [True: 0, False: 0]
  |  Branch (2234:57): [True: 0, False: 0]
  ------------------
 2235|      0|      return;
 2236|      0|    }
 2237|      0|  }
 2238|       |
 2239|     13|  fill = fill && !state->getFillColorSpace()->isNonMarking();
  ------------------
  |  Branch (2239:10): [True: 0, False: 13]
  |  Branch (2239:18): [True: 0, False: 0]
  ------------------
 2240|     13|  stroke = stroke && !state->getStrokeColorSpace()->isNonMarking();
  ------------------
  |  Branch (2240:12): [True: 0, False: 13]
  |  Branch (2240:22): [True: 0, False: 0]
  ------------------
 2241|       |
 2242|       |  // check for invisible text -- this is used by Acrobat Capture
 2243|     13|  if (!fill && !stroke && !makePath) {
  ------------------
  |  Branch (2243:7): [True: 13, False: 0]
  |  Branch (2243:16): [True: 13, False: 0]
  |  Branch (2243:27): [True: 13, False: 0]
  ------------------
 2244|     13|    return;
 2245|     13|  }
 2246|       |
 2247|      0|  if (needFontUpdate) {
  ------------------
  |  Branch (2247:7): [True: 0, False: 0]
  ------------------
 2248|      0|    doUpdateFont(state);
 2249|      0|  }
 2250|      0|  if (!font) {
  ------------------
  |  Branch (2250:7): [True: 0, False: 0]
  ------------------
 2251|      0|    return;
 2252|      0|  }
 2253|       |
 2254|      0|  x -= originX;
 2255|      0|  y -= originY;
 2256|       |
 2257|      0|  SplashPath *path = NULL;
 2258|      0|  if (stroke || makePath) {
  ------------------
  |  Branch (2258:7): [True: 0, False: 0]
  |  Branch (2258:17): [True: 0, False: 0]
  ------------------
 2259|      0|    if ((path = font->getGlyphPath(code))) {
  ------------------
  |  Branch (2259:9): [True: 0, False: 0]
  ------------------
 2260|      0|      path->offset((SplashCoord)x, (SplashCoord)y);
 2261|      0|    }
 2262|      0|  }
 2263|       |
 2264|       |  // don't use stroke adjustment when stroking text -- the results
 2265|       |  // tend to be ugly (because characters with horizontal upper or
 2266|       |  // lower edges get misaligned relative to the other characters)
 2267|      0|  SplashStrokeAdjustMode savedStrokeAdjust = splashStrokeAdjustOff;
 2268|      0|  if (stroke) {
  ------------------
  |  Branch (2268:7): [True: 0, False: 0]
  ------------------
 2269|      0|    savedStrokeAdjust = splash->getStrokeAdjust();
 2270|      0|    splash->setStrokeAdjust(splashStrokeAdjustOff);
 2271|      0|  }
 2272|       |
 2273|       |  // the possible operations are:
 2274|       |  //   - fill
 2275|       |  //   - stroke
 2276|       |  //   - fill + stroke
 2277|       |  //   - makePath
 2278|       |
 2279|      0|  if (fill && stroke) {
  ------------------
  |  Branch (2279:7): [True: 0, False: 0]
  |  Branch (2279:15): [True: 0, False: 0]
  ------------------
 2280|      0|    if (path) {
  ------------------
  |  Branch (2280:9): [True: 0, False: 0]
  ------------------
 2281|      0|      setOverprintMask(state, state->getFillColorSpace(),
 2282|      0|		       state->getFillOverprint(), state->getOverprintMode(),
 2283|      0|		       state->getFillColor());
 2284|      0|      splash->fill(path, gFalse);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2285|      0|      setOverprintMask(state, state->getStrokeColorSpace(),
 2286|      0|		       state->getStrokeOverprint(), state->getOverprintMode(),
 2287|      0|		       state->getStrokeColor());
 2288|      0|      splash->stroke(path);
 2289|      0|    }
 2290|       |
 2291|      0|  } else if (fill) {
  ------------------
  |  Branch (2291:14): [True: 0, False: 0]
  ------------------
 2292|      0|    setOverprintMask(state, state->getFillColorSpace(),
 2293|      0|		     state->getFillOverprint(), state->getOverprintMode(),
 2294|      0|		     state->getFillColor());
 2295|      0|    splash->fillChar((SplashCoord)x, (SplashCoord)y, code, font);
 2296|       |
 2297|      0|  } else if (stroke) {
  ------------------
  |  Branch (2297:14): [True: 0, False: 0]
  ------------------
 2298|      0|    if (path) {
  ------------------
  |  Branch (2298:9): [True: 0, False: 0]
  ------------------
 2299|      0|      setOverprintMask(state, state->getStrokeColorSpace(),
 2300|      0|		       state->getStrokeOverprint(), state->getOverprintMode(),
 2301|      0|		       state->getStrokeColor());
 2302|      0|      splash->stroke(path);
 2303|      0|    }
 2304|       |
 2305|      0|  } else if (makePath) {
  ------------------
  |  Branch (2305:14): [True: 0, False: 0]
  ------------------
 2306|      0|    if (path) {
  ------------------
  |  Branch (2306:9): [True: 0, False: 0]
  ------------------
 2307|      0|      if (savedTextPath) {
  ------------------
  |  Branch (2307:11): [True: 0, False: 0]
  ------------------
 2308|      0|	savedTextPath->append(path);
 2309|      0|      } else {
 2310|      0|	savedTextPath = path;
 2311|      0|	path = NULL;
 2312|      0|      }
 2313|      0|    }
 2314|      0|  }
 2315|       |
 2316|      0|  if (stroke) {
  ------------------
  |  Branch (2316:7): [True: 0, False: 0]
  ------------------
 2317|      0|    splash->setStrokeAdjust(savedStrokeAdjust);
 2318|      0|  }
 2319|       |
 2320|      0|  if (path) {
  ------------------
  |  Branch (2320:7): [True: 0, False: 0]
  ------------------
 2321|      0|    delete path;
 2322|      0|  }
 2323|      0|}

_ZN10UnicodeMapC2EPKciP15UnicodeMapRangei:
  122|     52|		       UnicodeMapRange *rangesA, int lenA) {
  123|     52|  encodingName = new GString(encodingNameA);
  124|     52|  unicodeOut = unicodeOutA;
  125|     52|  kind = unicodeMapResident;
  126|     52|  ranges = rangesA;
  127|     52|  len = lenA;
  128|     52|  eMaps = NULL;
  129|     52|  eMapsLen = 0;
  130|     52|  refCnt = 1;
  131|     52|}
_ZN10UnicodeMapC2EPKciPFijPciE:
  134|     26|		       UnicodeMapFunc funcA) {
  135|     26|  encodingName = new GString(encodingNameA);
  136|     26|  unicodeOut = unicodeOutA;
  137|     26|  kind = unicodeMapFunc;
  138|     26|  func = funcA;
  139|     26|  eMaps = NULL;
  140|     26|  eMapsLen = 0;
  141|     26|  refCnt = 1;
  142|     26|}
_ZN10UnicodeMapD2Ev:
  144|     78|UnicodeMap::~UnicodeMap() {
  145|     78|  delete encodingName;
  146|     78|  if (kind == unicodeMapUser && ranges) {
  ------------------
  |  Branch (146:7): [True: 0, False: 78]
  |  Branch (146:33): [True: 0, False: 0]
  ------------------
  147|      0|    gfree(ranges);
  148|      0|  }
  149|     78|  if (eMaps) {
  ------------------
  |  Branch (149:7): [True: 0, False: 78]
  ------------------
  150|      0|    gfree(eMaps);
  151|      0|  }
  152|     78|}
_ZN15UnicodeMapCacheC2Ev:
  228|     13|UnicodeMapCache::UnicodeMapCache() {
  229|     13|  int i;
  230|       |
  231|     65|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|     65|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (231:15): [True: 52, False: 13]
  ------------------
  232|     52|    cache[i] = NULL;
  233|     52|  }
  234|     13|}
_ZN15UnicodeMapCacheD2Ev:
  236|     13|UnicodeMapCache::~UnicodeMapCache() {
  237|     13|  int i;
  238|       |
  239|     65|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|     65|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (239:15): [True: 52, False: 13]
  ------------------
  240|     52|    if (cache[i]) {
  ------------------
  |  Branch (240:9): [True: 0, False: 52]
  ------------------
  241|      0|      cache[i]->decRefCnt();
  242|      0|    }
  243|     52|  }
  244|     13|}

_ZN10UnicodeMap15getEncodingNameEv:
   65|     78|  GString *getEncodingName() { return encodingName; }

_ZN16UnicodeRemappingC2Ev:
   69|     13|UnicodeRemapping::UnicodeRemapping() {
   70|  3.34k|  for (int i = 0; i < 256; ++i) {
  ------------------
  |  Branch (70:19): [True: 3.32k, False: 13]
  ------------------
   71|  3.32k|    page0[i] = (Unicode)i;
   72|  3.32k|  }
   73|     13|  sMap = NULL;
   74|     13|  sMapLen = sMapSize = 0;
   75|     13|}
_ZN16UnicodeRemappingD2Ev:
   77|     13|UnicodeRemapping::~UnicodeRemapping() {
   78|     13|  gfree(sMap);
   79|     13|}

