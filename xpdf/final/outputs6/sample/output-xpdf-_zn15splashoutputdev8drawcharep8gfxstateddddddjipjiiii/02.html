<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii / 02</h1>
Bug: False
<br>
Crash reason: FP_NEAR_INIT_CRASH
<br>
<br>

<h2>Triage</h2>
<pre>
Crash is caused by bug in project.

The crash is happening at the point where GlobalParams::getVectorAntialias() is being called. The crash log indicates a null-deref, which suggests that an attempt is being made to access memory that hasn&#39;t been properly initialized or that has already been freed. It&#39;s likely that there&#39;s a bug in the project&#39;s code where it&#39;s not correctly handling the initialization or cleanup of the GlobalParams object, leading to this crash.
</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  GString *fileNameA = new GString(&#34;dummy.pdf&#34;);
  PDFDoc *pdfDoc = new PDFDoc(fileNameA);
  splashOut-&gt;startDoc(pdfDoc-&gt;getXRef());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  delete pdfDoc;
  free(unicode);
  
  return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;SplashOutputDev.h&#34;
#include &#34;FrameBuffer.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
  double w = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  double h = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  FrameBuffer frameBuffer(bitmap_row, bitmap_column, 72, 72, nComps, gFalse, NULL);
  GfxState *state = new GfxState(72, 
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
The target function `void SplashOutputDev::drawChar(GfxState *, double, double, double, double, double, double, CharCode, int, Unicode *, int, GBool, GBool, GBool)` was not called by the fuzz target `LLVMFuzzerTestOneInput`.YOU MUST CALL FUNCTION `void SplashOutputDev::drawChar(GfxState *, double, double, double, double, double, double, CharCode, int, Unicode *, int, GBool, GBool, GBool)` INSIDE FUNCTION `LLVMFuzzerTestOneInput`.
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;SplashOutputDev.h&#34;
#include &#34;FrameBuffer.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
  double w = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  double h = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  FrameBuffer frameBuffer(bitmap_row, bitmap_column, 72, 72, nComps, gFalse, NULL);
  GfxState *state = new GfxState(72, 72, &amp;frameBuffer);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(state-&gt;getDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;SplashOutputDev.h&#34;
#include &#34;FrameBuffer.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
  double w = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  double h = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  FrameBuffer frameBuffer(bitmap_row, bitmap_column, 72, 72, nComps, gFalse, NULL);
  GfxState *state = new GfxState(72, 72, &amp;frameBuffer);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(state-&gt;getDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
fuzz_JBIG2.cc:9:10: fatal error: &#39;FrameBuffer.h&#39; file not found
    9 | #include &#34;FrameBuffer.h&#34;
      |          ^~~~~~~~~~~~~~~
&lt;/error&gt;


Below are instructions to assist you in fixing the error.
&lt;instruction&gt;
IMPORTANT: DO NOT include the header file FrameBuffer.h in the generated fuzz target again, the file does not exist in the project-under-test.
If the non-existent &lt;filepath&gt;FrameBuffer.h&lt;/filepath&gt; was included for the declaration of &lt;code&gt;void SplashOutputDev::drawChar(GfxState *, double, double, double, double, double, double, CharCode, int, Unicode *, int, GBool, GBool, GBool)&lt;/code&gt;, you must replace it with the EXACT path of the actual file &lt;filepath&gt;#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;&lt;/filepath&gt;. For example:
&lt;code&gt;
#include &#34;#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;&#34;
&lt;/code&gt;
Otherwise, consider replacing it with some of the following statementsthat may be correct alternatives:
&lt;code&gt;
#include &#34;/src/freetype/src/autofit/afloader.h&#34;
#include &#34;/src/freetype/include/freetype/ftdriver.h&#34;
#include &#34;/src/freetype/include/freetype/ftrender.h&#34;
#include &#34;/src/freetype/src/autofit/afscript.h&#34;
#include &#34;/src/freetype/src/pfr/pfrobjs.h&#34;
&lt;/code&gt;

&lt;/instruction&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
  double w = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  double h = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  GfxState *state = new GfxState(72, 72, bitmap_row, bitmap_column, nComps, gFalse, NULL);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(state-&gt;getDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
</pre>


<h3>Fixer prompt #3</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
  double w = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  double h = stream.ConsumeIntegralInRange&lt;double&gt;(1, 1000);
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  GfxState *state = new GfxState(72, 72, bitmap_row, bitmap_column, nComps, gFalse, NULL);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(state-&gt;getDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
fuzz_JBIG2.cc:26:23: error: no viable conversion from &#39;double&#39; to &#39;std::vector&lt;double&gt;&#39;
   26 |   std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
      |                       ^         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/bin/../include/c++/v1/vector:502:57: note: candidate constructor not viable: no known conversion from &#39;double&#39; to &#39;const vector&lt;double&gt; &amp;&#39; for 1st argument
  502 |     _LIBCPP_CONSTEXPR_SINCE_CXX20 _LIBCPP_HIDE_FROM_ABI vector(const vector&amp; __x);
      |                                                         ^      ~~~~~~~~~~~~~~~~~
/usr/local/bin/../include/c++/v1/vector:509:5: note: candidate constructor not viable: no known conversion from &#39;double&#39; to &#39;initializer_list&lt;value_type&gt;&#39; (aka &#39;initializer_list&lt;double&gt;&#39;) for 1st argument
  509 |     vector(initializer_list&lt;value_type&gt; __il);
      |     ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/bin/../include/c++/v1/vector:520:5: note: candidate constructor not viable: no known conversion from &#39;double&#39; to &#39;vector&lt;double&gt; &amp;&amp;&#39; for 1st argument
  520 |     vector(vector&amp;&amp; __x)
      |     ^      ~~~~~~~~~~~~
/usr/local/bin/../include/c++/v1/vector:415:66: note: explicit constructor is not a candidate
  415 |     _LIBCPP_CONSTEXPR_SINCE_CXX20 _LIBCPP_HIDE_FROM_ABI explicit vector(const allocator_type&amp; __a)
      |                                                                  ^
/usr/local/bin/../include/c++/v1/vector:424:66: note: explicit constructor is not a candidate
  424 |     _LIBCPP_CONSTEXPR_SINCE_CXX20 _LIBCPP_HIDE_FROM_ABI explicit vector(size_type __n);
      |                                                                  ^
fuzz_JBIG2.cc:38:25: error: no matching constructor for initialization of &#39;GfxState&#39;
   38 |   GfxState *state = new GfxState(72, 72, bitmap_row, bitmap_column, nComps, gFalse, NULL);
      |                         ^        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/src/xpdf-4.05/xpdf/GfxState.h:1131:3: note: candidate constructor not viable: requires 5 arguments, but 7 were provided
 1131 |   GfxState(double hDPIA, double vDPIA, PDFRectangle *pageBox,
      |   ^        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1132 |            int rotateA, GBool upsideDown
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/src/xpdf-4.05/xpdf/GfxState.h:1373:3: note: candidate constructor not viable: requires 2 arguments, but 7 were provided
 1373 |   GfxState(GfxState *state, GBool copyPath);
      |   ^        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/src/xpdf-4.05/xpdf/GfxState.h:1125:7: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 7 were provided
 1125 | class GfxState {
      |       ^~~~~~~~
fuzz_JBIG2.cc:41:30: error: no member named &#39;getDoc&#39; in &#39;GfxState&#39;
   41 |   splashOut-&gt;startDoc(state-&gt;getDoc());
      |                       ~~~~~  ^
In file included from fuzz_JBIG2.cc:1:
/usr/local/lib/clang/18/include/fuzzer/FuzzedDataProvider.h:205:17: error: static assertion failed due to requirement &#39;std::is_integral&lt;double&gt;::value&#39;: An integral type is required.
  205 |   static_assert(std::is_integral&lt;T&gt;::value, &#34;An integral type is required.&#34;);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
fuzz_JBIG2.cc:26:40: note: in instantiation of function template specialization &#39;FuzzedDataProvider::ConsumeIntegralInRange&lt;double&gt;&#39; requested here
   26 |   std::vector&lt;double&gt; m_array = stream.ConsumeIntegralInRange&lt;double&gt;(0, 6);
      |                                        ^
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #3</h3>

<pre>
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(new PDFDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;
&lt;solution&gt;
</pre>


<h3>Fixer prompt #4</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  splashOut-&gt;startDoc(new PDFDoc());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
fuzz_JBIG2.cc:45:27: error: no matching constructor for initialization of &#39;PDFDoc&#39;
   45 |   splashOut-&gt;startDoc(new PDFDoc());
      |                           ^
../xpdf/PDFDoc.h:35:7: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 0 were provided
   35 | class PDFDoc {
      |       ^~~~~~
../xpdf/PDFDoc.h:38:3: note: candidate constructor not viable: requires at least argument &#39;fileNameA&#39;, but no arguments were provided
   38 |   PDFDoc(GString *fileNameA, GString *ownerPassword = NULL,
      |   ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   39 |          GString *userPassword = NULL, PDFCore *coreA = NULL);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../xpdf/PDFDoc.h:48:3: note: candidate constructor not viable: requires at least argument &#39;fileNameA&#39;, but no arguments were provided
   48 |   PDFDoc(char *fileNameA, GString *ownerPassword = NULL,
      |   ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   49 |          GString *userPassword = NULL, PDFCore *coreA = NULL);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../xpdf/PDFDoc.h:51:3: note: candidate constructor not viable: requires at least argument &#39;strA&#39;, but no arguments were provided
   51 |   PDFDoc(BaseStream *strA, GString *ownerPassword = NULL,
      |   ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   52 |          GString *userPassword = NULL, PDFCore *coreA = NULL);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #4</h3>

<pre>
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  GString *fileNameA = new GString(&#34;dummy.pdf&#34;);
  splashOut-&gt;startDoc(new PDFDoc(fileNameA));
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;
&lt;/solution&gt;
</pre>


<h3>Fixer prompt #5</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  GString *fileNameA = new GString(&#34;dummy.pdf&#34;);
  splashOut-&gt;startDoc(new PDFDoc(fileNameA));
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  free(unicode);
  
  return 0;
}
&lt;/code&gt;

Below is the error to fix:
The code has the following build issues:
&lt;error&gt;
fuzz_JBIG2.cc:46:23: error: cannot initialize a parameter of type &#39;XRef *&#39; with an rvalue of type &#39;PDFDoc *&#39;
   46 |   splashOut-&gt;startDoc(new PDFDoc(fileNameA));
      |                       ^~~~~~~~~~~~~~~~~~~~~
/src/xpdf-4.05/xpdf/SplashOutputDev.h:187:23: note: passing argument to parameter &#39;xrefA&#39; here
  187 |   void startDoc(XRef *xrefA);
      |                       ^
&lt;/error&gt;




Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #5</h3>

<pre>
Here is the corrected code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;

#include &lt;aconf.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

#include &#34;PDFDoc.h&#34;
#include &#34;/src/xpdf-4.05/xpdf/SplashOutputDev.h&#34;

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  FuzzedDataProvider stream(data, size);

  double x = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y = stream.ConsumeFloatingPoint&lt;double&gt;();
  double x_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double y_radius = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle1 = stream.ConsumeFloatingPoint&lt;double&gt;();
  double angle2 = stream.ConsumeFloatingPoint&lt;double&gt;();
  CharCode code = stream.ConsumeIntegral&lt;CharCode&gt;();
  int nBytes = stream.ConsumeIntegralInRange&lt;int&gt;(1, 100);
  auto unicode = (Unicode *)malloc(sizeof(Unicode) * nBytes);
  for (int i = 0; i&lt; nBytes; i++) {
    unicode[i] = stream.ConsumeIntegral&lt;Unicode&gt;();
  }
  GBool dopath = stream.ConsumeIntegral&lt;GBool&gt;();
  std::vector&lt;double&gt; m_array;
  for (int i = 0; i &lt; 6; i++) {
    m_array.push_back(stream.ConsumeFloatingPoint&lt;double&gt;());
  }
  double w = stream.ConsumeFloatingPoint&lt;double&gt;();
  double h = stream.ConsumeFloatingPoint&lt;double&gt;();
  int nComps = stream.ConsumeIntegralInRange&lt;int&gt;(1, 4);
  int bitmap_row = stream.ConsumeIntegral&lt;int&gt;();
  int bitmap_column = stream.ConsumeIntegral&lt;int&gt;();

  if (m_array.size() != 6) {
    free(unicode);
    return 0;
  }

  PDFRectangle pageBox;
  GfxState *state = new GfxState(72, 72, &amp;pageBox, 0, gFalse);
  
  SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 4, gFalse, gFalse);
  GString *fileNameA = new GString(&#34;dummy.pdf&#34;);
  PDFDoc *pdfDoc = new PDFDoc(fileNameA);
  splashOut-&gt;startDoc(pdfDoc-&gt;getXRef());
  splashOut-&gt;drawChar(state, x, y, x_radius, y_radius, angle1, angle2, code, nBytes, unicode, nBytes, gTrue, gTrue, gTrue);

  delete splashOut;
  delete state;
  delete pdfDoc;
  free(unicode);
  
  return 0;
}
```

The error was due to the fact that the `startDoc` method of `SplashOutputDev` class expects an `XRef` object as an argument, but a `PDFDoc` object was passed instead. To fix this, I created a `PDFDoc` object and passed its `XRef` object to the `startDoc` method. Also, I added a line to delete the `PDFDoc` object to prevent memory leaks.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4, attempt 1.
Fixing /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4, attempt 2.
Fixing /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4, attempt 3.
Fixing /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4, attempt 4.
Fixing /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4, attempt 5.
Successfully built /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4 in 5 iterations of fixing.
Triaging the crash related to /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/fixed_targets/02.cc with gpt-4.
Warning: Failed to fix semantic error FP_NEAR_INIT_CRASH in xpdf-zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii-02.

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/chyun/oss-fuzz-gen/results6/output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii/corpora/02.cc:/tmp/fuzz_JBIG2_corpus -v /tmp/tmpa6lt_ngl/build/out/xpdf-zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzz_JBIG2 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/fuzz_JBIG2_corpus&#39;: Device or resource busy
/out/fuzz_JBIG2 -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/fuzz_JBIG2_corpus -detect_leaks=0 &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1364838262
INFO: Loaded 1 modules   (57843 inline 8-bit counters): 57843 [0x556f7d88ea88, 0x556f7d89cc7b), 
INFO: Loaded 1 PC tables (57843 PCs): 57843 [0x556f7d89cc80,0x556f7d97ebb0), 
INFO:        0 files found in /tmp/fuzz_JBIG2_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
AddressSanitizer:DEADLYSIGNAL
=================================================================
[1m[31m==16==ERROR: AddressSanitizer: SEGV on unknown address 0x0000000002c0 (pc 0x7fd311204fc4 bp 0x7ffe50c31f70 sp 0x7ffe50c31f58 T0)
[1m[0m==16==The signal is caused by a READ memory access.
==16==Hint: address points to the zero page.
SCARINESS: 10 (null-deref)
    #0 0x7fd311204fc4 in __pthread_mutex_lock (/lib/x86_64-linux-gnu/libpthread.so.0+0xafc4) (BuildId: 9a65bb469e45a1c6fbcffae5b82a2fd7a69eb479)
    #1 0x556f7d2a43ef in GlobalParams::getVectorAntialias() /src/xpdf-4.05/xpdf/GlobalParams.cc:3187:3
    #2 0x556f7d3fdd5c in SplashOutputDev::SplashOutputDev(SplashColorMode, int, int, unsigned char*, int, int) /src/xpdf-4.05/xpdf/SplashOutputDev.cc:628:23
    #3 0x556f7d161fd0 in LLVMFuzzerTestOneInput /src/xpdf-4.05/build/fuzz_JBIG2.cc:44:36
    #4 0x556f7d013660 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #5 0x556f7d014b61 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
    #6 0x556f7d015147 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
    #7 0x556f7d003756 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #8 0x556f7d02fc82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #9 0x7fd310fe3082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #10 0x556f7cff48cd in _start (/out/fuzz_JBIG2+0x29f8cd)

DEDUP_TOKEN: __pthread_mutex_lock--GlobalParams::getVectorAntialias()--SplashOutputDev::SplashOutputDev(SplashColorMode, int, int, unsigned char*, int, int)
AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libpthread.so.0+0xafc4) (BuildId: 9a65bb469e45a1c6fbcffae5b82a2fd7a69eb479) in __pthread_mutex_lock
==16==ABORTING
MS: 0 ; base unit: 0000000000000000000000000000000000000000


artifact_prefix=&#39;./&#39;; Test unit written to ./crash-da39a3ee5e6b4b0d3255bfef95601890afd80709
Base64: 
stat::number_of_executed_units: 1
stat::average_exec_per_sec:     0
stat::new_units_added:          0
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              36

</pre>


</body>