LLVMFuzzerTestOneInput:
   27|    122|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   28|    122|  FuzzedDataProvider fdp(data, size);
   29|    122|  double hdpi = fdp.ConsumeFloatingPoint<double>();
   30|    122|  double vdpi = fdp.ConsumeFloatingPoint<double>();
   31|    122|  int rotate = fdp.ConsumeIntegral<int>();
   32|    122|  bool useMediaBox = fdp.ConsumeBool();
   33|    122|  bool crop = fdp.ConsumeBool();
   34|    122|  bool printing = fdp.ConsumeBool();
   35|    122|  std::vector<char> payload = fdp.ConsumeRemainingBytes<char>();
   36|       |
   37|    122|  Object xpdf_obj;
   38|    122|  xpdf_obj.initNull();
   39|    122|  BaseStream *stream = new MemStream(payload.data(), 0, payload.size(), &xpdf_obj);
   40|       |
   41|    122|  Object info, xfa;
   42|    122|  Object *acroForm;
   43|    122|  GlobalParams *globalParams = new GlobalParams(NULL);
   44|    122|  globalParams->setErrQuiet(1);
   45|    122|  globalParams->setupBaseFonts(NULL);
   46|    122|  char yes[] = "yes";
   47|    122|  globalParams->setEnableFreeType(yes); // Yes, it's a string and not a bool.
   48|    122|  globalParams->setErrQuiet(1);
   49|       |
   50|    122|  PDFDoc *doc = NULL;
   51|    122|  try {
   52|    122|    doc = new PDFDoc(stream); // Fixed: Assign the created PDFDoc object to the pointer
   53|    122|    if (doc->isOk() == gTrue) {
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  |  Branch (53:9): [True: 0, False: 122]
  ------------------
   54|      0|      doc->getNumPages();
   55|      0|      doc->getOutline();
   56|      0|      doc->getStructTreeRoot();
   57|      0|      doc->getXRef();
   58|      0|      doc->okToPrint(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   59|      0|      doc->okToCopy(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   60|      0|      doc->okToChange(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   61|      0|      doc->okToAddNotes(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   62|      0|      doc->isLinearized();
   63|      0|      doc->getPDFVersion();
   64|       |
   65|      0|      GString *metadata;
   66|      0|      if ((metadata = doc->readMetadata())) {
  ------------------
  |  Branch (66:11): [True: 0, False: 0]
  ------------------
   67|      0|        (void)metadata->getCString();
   68|      0|      }
   69|      0|      delete metadata;
   70|       |
   71|      0|      Object info;
   72|      0|      doc->getDocInfo(&info);
   73|      0|      if (info.isDict()) {
  ------------------
  |  Branch (73:11): [True: 0, False: 0]
  ------------------
   74|      0|        info.getDict();
   75|      0|      }
   76|      0|      info.free();
   77|       |
   78|      0|      if ((acroForm = doc->getCatalog()->getAcroForm())->isDict()) {
  ------------------
  |  Branch (78:11): [True: 0, False: 0]
  ------------------
   79|      0|        acroForm->dictLookup("XFA", &xfa);
   80|      0|        xfa.free();
   81|      0|      }
   82|       |
   83|      0|      for (size_t i = 1; i <= doc->getNumPages(); i++) {
  ------------------
  |  Branch (83:26): [True: 0, False: 0]
  ------------------
   84|      0|        doc->getLinks(i);
   85|      0|        auto page = doc->getCatalog()->getPage(i);
   86|      0|        if (!page->isOk()) {
  ------------------
  |  Branch (86:13): [True: 0, False: 0]
  ------------------
   87|      0|          continue;
   88|      0|        }
   89|      0|        page->getResourceDict();
   90|      0|        page->getMetadata();
   91|      0|        page->getResourceDict();
   92|      0|      }
   93|       |
   94|      0|      SplashColor paperColor = {0xff, 0xff, 0xff};
   95|      0|      SplashOutputDev *splashOut = new SplashOutputDev(splashModeRGB8, 1, gFalse, paperColor);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
   96|      0|      splashOut->setNoComposite(gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
   97|      0|      splashOut->startDoc(doc->getXRef());
   98|      0|      doc->displayPages(splashOut, 1, doc->getNumPages(), hdpi, vdpi, rotate, useMediaBox, crop, printing, NULL, NULL);
   99|      0|      (void)splashOut->getBitmap();
  100|       |
  101|      0|      delete splashOut;
  102|      0|    }
  103|    122|  } catch (...) {
  104|      0|  }
  105|       |
  106|    122|  delete doc; // Fixed: Delete the allocated PDFDoc object
  107|       |
  108|    122|  delete globalParams;
  109|       |
  110|    122|  return 0;
  111|    122|}

_ZN5GHashC2Ei:
   34|  1.34k|GHash::GHash(GBool deleteKeysA) {
   35|  1.34k|  int h;
   36|       |
   37|  1.34k|  deleteKeys = deleteKeysA;
   38|  1.34k|  size = 7;
   39|  1.34k|  tab = (GHashBucket **)gmallocn(size, sizeof(GHashBucket *));
   40|  10.7k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (40:15): [True: 9.39k, False: 1.34k]
  ------------------
   41|  9.39k|    tab[h] = NULL;
   42|  9.39k|  }
   43|  1.34k|  len = 0;
   44|  1.34k|}
_ZN5GHashD2Ev:
   46|  1.34k|GHash::~GHash() {
   47|  1.34k|  GHashBucket *p;
   48|  1.34k|  int h;
   49|       |
   50|  10.7k|  for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (50:15): [True: 9.39k, False: 1.34k]
  ------------------
   51|  10.2k|    while (tab[h]) {
  ------------------
  |  Branch (51:12): [True: 854, False: 9.39k]
  ------------------
   52|    854|      p = tab[h];
   53|    854|      tab[h] = p->next;
   54|    854|      if (deleteKeys) {
  ------------------
  |  Branch (54:11): [True: 122, False: 732]
  ------------------
   55|    122|	delete p->key;
   56|    122|      }
   57|    854|      delete p;
   58|    854|    }
   59|  9.39k|  }
   60|  1.34k|  gfree(tab);
   61|  1.34k|}
_ZN5GHash3addEP7GStringPv:
   63|    854|void GHash::add(GString *key, void *val) {
   64|    854|  GHashBucket *p;
   65|    854|  int h;
   66|       |
   67|       |  // expand the table if necessary
   68|    854|  if (len >= size) {
  ------------------
  |  Branch (68:7): [True: 0, False: 854]
  ------------------
   69|      0|    expand();
   70|      0|  }
   71|       |
   72|       |  // add the new symbol
   73|    854|  p = new GHashBucket;
   74|    854|  p->key = key;
   75|    854|  p->val.p = val;
   76|    854|  h = hash(key);
   77|    854|  p->next = tab[h];
   78|    854|  tab[h] = p;
   79|    854|  ++len;
   80|    854|}
_ZN5GHash6lookupEPKc:
  149|  5.61k|void *GHash::lookup(const char *key) {
  150|  5.61k|  GHashBucket *p;
  151|  5.61k|  int h;
  152|       |
  153|  5.61k|  if (!(p = find(key, &h))) {
  ------------------
  |  Branch (153:7): [True: 5.61k, False: 0]
  ------------------
  154|  5.61k|    return NULL;
  155|  5.61k|  }
  156|      0|  return p->val.p;
  157|  5.61k|}
_ZN5GHash9startIterEPP9GHashIter:
  261|  1.22k|void GHash::startIter(GHashIter **iter) {
  262|  1.22k|  *iter = new GHashIter;
  263|  1.22k|  (*iter)->h = -1;
  264|  1.22k|  (*iter)->p = NULL;
  265|  1.22k|}
_ZN5GHash7getNextEPP9GHashIterPP7GStringPPv:
  267|  2.07k|GBool GHash::getNext(GHashIter **iter, GString **key, void **val) {
  268|  2.07k|  if (!*iter) {
  ------------------
  |  Branch (268:7): [True: 0, False: 2.07k]
  ------------------
  269|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  270|      0|  }
  271|  2.07k|  if ((*iter)->p) {
  ------------------
  |  Branch (271:7): [True: 854, False: 1.22k]
  ------------------
  272|    854|    (*iter)->p = (*iter)->p->next;
  273|    854|  }
  274|  10.6k|  while (!(*iter)->p) {
  ------------------
  |  Branch (274:10): [True: 9.76k, False: 854]
  ------------------
  275|  9.76k|    if (++(*iter)->h == size) {
  ------------------
  |  Branch (275:9): [True: 1.22k, False: 8.54k]
  ------------------
  276|  1.22k|      delete *iter;
  277|  1.22k|      *iter = NULL;
  278|  1.22k|      return gFalse;
  ------------------
  |  |   18|  1.22k|#define gFalse 0
  ------------------
  279|  1.22k|    }
  280|  8.54k|    (*iter)->p = tab[(*iter)->h];
  281|  8.54k|  }
  282|    854|  *key = (*iter)->p->key;
  283|    854|  *val = (*iter)->p->val.p;
  284|    854|  return gTrue;
  ------------------
  |  |   17|    854|#define gTrue 1
  ------------------
  285|  2.07k|}
_ZN5GHash4findEPKcPi:
  348|  5.61k|GHashBucket *GHash::find(const char *key, int *h) {
  349|  5.61k|  GHashBucket *p;
  350|       |
  351|  5.61k|  *h = hash(key);
  352|  5.61k|  for (p = tab[*h]; p; p = p->next) {
  ------------------
  |  Branch (352:21): [True: 0, False: 5.61k]
  ------------------
  353|      0|    if (!p->key->cmp(key)) {
  ------------------
  |  Branch (353:9): [True: 0, False: 0]
  ------------------
  354|      0|      return p;
  355|      0|    }
  356|      0|  }
  357|  5.61k|  return NULL;
  358|  5.61k|}
_ZN5GHash4hashEP7GString:
  360|    854|int GHash::hash(GString *key) {
  361|    854|  const char *p;
  362|    854|  unsigned int h;
  363|    854|  int i;
  364|       |
  365|    854|  h = 0;
  366|  6.58k|  for (p = key->getCString(), i = 0; i < key->getLength(); ++p, ++i) {
  ------------------
  |  Branch (366:38): [True: 5.73k, False: 854]
  ------------------
  367|  5.73k|    h = 17 * h + (int)(*p & 0xff);
  368|  5.73k|  }
  369|    854|  return (int)(h % size);
  370|    854|}
_ZN5GHash4hashEPKc:
  372|  5.61k|int GHash::hash(const char *key) {
  373|  5.61k|  const char *p;
  374|  5.61k|  unsigned int h;
  375|       |
  376|  5.61k|  h = 0;
  377|  76.9k|  for (p = key; *p; ++p) {
  ------------------
  |  Branch (377:17): [True: 71.3k, False: 5.61k]
  ------------------
  378|  71.3k|    h = 17 * h + (int)(*p & 0xff);
  379|  71.3k|  }
  380|  5.61k|  return (int)(h % size);
  381|  5.61k|}

_ZN5GListC2Ev:
   21|  8.41k|GList::GList() {
   22|  8.41k|  size = 8;
   23|  8.41k|  data = (void **)gmallocn(size, sizeof(void*));
   24|  8.41k|  length = 0;
   25|  8.41k|  inc = 0;
   26|  8.41k|}
_ZN5GListD2Ev:
   35|  8.41k|GList::~GList() {
   36|  8.41k|  gfree(data);
   37|  8.41k|}
_ZN5GList6appendEPv:
   49|  16.4k|void GList::append(void *p) {
   50|  16.4k|  if (length >= size) {
  ------------------
  |  Branch (50:7): [True: 488, False: 15.9k]
  ------------------
   51|    488|    expand();
   52|    488|  }
   53|  16.4k|  data[length++] = p;
   54|  16.4k|}
_ZN5GList6expandEv:
  116|    488|void GList::expand() {
  117|    488|  size += (inc > 0) ? inc : size;
  ------------------
  |  Branch (117:11): [True: 0, False: 488]
  ------------------
  118|    488|  data = (void **)greallocn(data, size, sizeof(void*));
  119|    488|}

_ZN5GList9getLengthEv:
   35|  24.8k|  int getLength() { return length; }
_ZN5GList3getEi:
   44|  16.4k|  void *get(int i) { return data[i]; }

_ZN7GStringC2Ev:
  129|  4.63k|GString::GString() {
  130|  4.63k|  s = NULL;
  131|  4.63k|  resize(length = 0);
  132|  4.63k|  s[0] = '\0';
  133|  4.63k|}
_ZN7GStringC2EPKc:
  135|  21.9k|GString::GString(const char *sA) {
  136|  21.9k|  int n = (int)strlen(sA);
  137|       |
  138|  21.9k|  s = NULL;
  139|  21.9k|  resize(length = n);
  140|  21.9k|  memcpy(s, sA, n + 1);
  141|  21.9k|}
_ZN7GString7formatvEPKcP13__va_list_tag:
  196|  2.31k|GString *GString::formatv(const char *fmt, va_list argList) {
  197|  2.31k|  GString *s;
  198|       |
  199|  2.31k|  s = new GString();
  200|  2.31k|  s->appendfv(fmt, argList);
  201|  2.31k|  return s;
  202|  2.31k|}
_ZN7GStringD2Ev:
  204|  26.5k|GString::~GString() {
  205|  26.5k|  delete[] s;
  206|  26.5k|}
_ZN7GString6appendEc:
  214|  92.1k|GString *GString::append(char c) {
  215|  92.1k|  if (length > INT_MAX - 1) {
  ------------------
  |  Branch (215:7): [True: 0, False: 92.1k]
  ------------------
  216|      0|    gMemError("Integer overflow in GString::append()");
  217|      0|  }
  218|  92.1k|  resize(length + 1);
  219|  92.1k|  s[length++] = c;
  220|  92.1k|  s[length] = '\0';
  221|  92.1k|  return this;
  222|  92.1k|}
_ZN7GString6appendEPKc:
  236|  9.15k|GString *GString::append(const char *str) {
  237|  9.15k|  int n = (int)strlen(str);
  238|       |
  239|  9.15k|  if (length > INT_MAX - n) {
  ------------------
  |  Branch (239:7): [True: 0, False: 9.15k]
  ------------------
  240|      0|    gMemError("Integer overflow in GString::append()");
  241|      0|  }
  242|  9.15k|  resize(length + n);
  243|  9.15k|  memcpy(s + length, str, n + 1);
  244|  9.15k|  length += n;
  245|  9.15k|  return this;
  246|  9.15k|}
_ZN7GString6appendEPKci:
  248|  19.3k|GString *GString::append(const char *str, int lengthA) {
  249|  19.3k|  if (lengthA < 0 || length > INT_MAX - lengthA) {
  ------------------
  |  Branch (249:7): [True: 0, False: 19.3k]
  |  Branch (249:22): [True: 0, False: 19.3k]
  ------------------
  250|      0|    gMemError("Integer overflow in GString::append()");
  251|      0|  }
  252|  19.3k|  resize(length + lengthA);
  253|  19.3k|  memcpy(s + length, str, lengthA);
  254|  19.3k|  length += lengthA;
  255|  19.3k|  s[length] = '\0';
  256|  19.3k|  return this;
  257|  19.3k|}
_ZN7GString7appendfEPKcz:
  259|  4.48k|GString *GString::appendf(const char *fmt, ...) {
  260|  4.48k|  va_list argList;
  261|       |
  262|  4.48k|  va_start(argList, fmt);
  263|  4.48k|  appendfv(fmt, argList);
  264|  4.48k|  va_end(argList);
  265|  4.48k|  return this;
  266|  4.48k|}
_ZN7GString8appendfvEPKcP13__va_list_tag:
  268|  6.80k|GString *GString::appendfv(const char *fmt, va_list argList) {
  269|  6.80k|  GStringFormatArg *args;
  270|  6.80k|  int argsLen, argsSize;
  271|  6.80k|  GStringFormatArg arg;
  272|  6.80k|  int idx, width, prec;
  273|  6.80k|  GBool reverseAlign, zeroFill;
  274|  6.80k|  GStringFormatType ft;
  275|  6.80k|  char buf[65];
  276|  6.80k|  int len, i;
  277|  6.80k|  const char *p0, *p1;
  278|  6.80k|  const char *str;
  279|       |
  280|  6.80k|  argsLen = 0;
  281|  6.80k|  argsSize = 8;
  282|  6.80k|  args = (GStringFormatArg *)gmallocn(argsSize, sizeof(GStringFormatArg));
  283|       |
  284|  6.80k|  p0 = fmt;
  285|  26.1k|  while (*p0) {
  ------------------
  |  Branch (285:10): [True: 19.3k, False: 6.80k]
  ------------------
  286|  19.3k|    if (*p0 == '{') {
  ------------------
  |  Branch (286:9): [True: 6.27k, False: 13.0k]
  ------------------
  287|  6.27k|      ++p0;
  288|  6.27k|      if (*p0 == '{') {
  ------------------
  |  Branch (288:11): [True: 0, False: 6.27k]
  ------------------
  289|      0|	++p0;
  290|      0|	append('{');
  291|  6.27k|      } else {
  292|       |
  293|       |	// parse the format string
  294|  6.27k|	if (!(*p0 >= '0' && *p0 <= '9')) {
  ------------------
  |  Branch (294:8): [True: 6.27k, False: 0]
  |  Branch (294:22): [True: 6.27k, False: 0]
  ------------------
  295|      0|	  break;
  296|      0|	}
  297|  6.27k|	idx = *p0 - '0';
  298|  6.27k|	for (++p0; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (298:13): [True: 6.27k, False: 0]
  |  Branch (298:27): [True: 0, False: 6.27k]
  ------------------
  299|      0|	  idx = 10 * idx + (*p0 - '0');
  300|      0|	}
  301|  6.27k|	if (*p0 != ':') {
  ------------------
  |  Branch (301:6): [True: 0, False: 6.27k]
  ------------------
  302|      0|	  break;
  303|      0|	}
  304|  6.27k|	++p0;
  305|  6.27k|	if (*p0 == '-') {
  ------------------
  |  Branch (305:6): [True: 0, False: 6.27k]
  ------------------
  306|      0|	  reverseAlign = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  307|      0|	  ++p0;
  308|  6.27k|	} else {
  309|  6.27k|	  reverseAlign = gFalse;
  ------------------
  |  |   18|  6.27k|#define gFalse 0
  ------------------
  310|  6.27k|	}
  311|  6.27k|	width = 0;
  312|  6.27k|	zeroFill = *p0 == '0';
  313|  15.2k|	for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (313:9): [True: 15.2k, False: 0]
  |  Branch (313:23): [True: 8.97k, False: 6.27k]
  ------------------
  314|  8.97k|	  width = 10 * width + (*p0 - '0');
  315|  8.97k|	}
  316|  6.27k|	if (width < 0) {
  ------------------
  |  Branch (316:6): [True: 0, False: 6.27k]
  ------------------
  317|      0|	  width = 0;
  318|      0|	}
  319|  6.27k|	if (*p0 == '.') {
  ------------------
  |  Branch (319:6): [True: 0, False: 6.27k]
  ------------------
  320|      0|	  ++p0;
  321|      0|	  prec = 0;
  322|      0|	  for (; *p0 >= '0' && *p0 <= '9'; ++p0) {
  ------------------
  |  Branch (322:11): [True: 0, False: 0]
  |  Branch (322:25): [True: 0, False: 0]
  ------------------
  323|      0|	    prec = 10 * prec + (*p0 - '0');
  324|      0|	  }
  325|  6.27k|	} else {
  326|  6.27k|	  prec = 0;
  327|  6.27k|	}
  328|  6.27k|	for (ft = (GStringFormatType)0;
  329|  58.9k|	     formatStrings[ft];
  ------------------
  |  Branch (329:7): [True: 58.9k, False: 0]
  ------------------
  330|  58.9k|	     ft = (GStringFormatType)(ft + 1)) {
  331|  58.9k|	  if (!strncmp(p0, formatStrings[ft], strlen(formatStrings[ft]))) {
  ------------------
  |  Branch (331:8): [True: 6.27k, False: 52.7k]
  ------------------
  332|  6.27k|	    break;
  333|  6.27k|	  }
  334|  58.9k|	}
  335|  6.27k|	if (!formatStrings[ft]) {
  ------------------
  |  Branch (335:6): [True: 0, False: 6.27k]
  ------------------
  336|      0|	  break;
  337|      0|	}
  338|  6.27k|	p0 += strlen(formatStrings[ft]);
  339|  6.27k|	if (*p0 != '}') {
  ------------------
  |  Branch (339:6): [True: 0, False: 6.27k]
  ------------------
  340|      0|	  break;
  341|      0|	}
  342|  6.27k|	++p0;
  343|       |
  344|       |	// fetch the argument
  345|  6.27k|	if (idx > argsLen) {
  ------------------
  |  Branch (345:6): [True: 0, False: 6.27k]
  ------------------
  346|      0|	  break;
  347|      0|	}
  348|  6.27k|	if (idx == argsLen) {
  ------------------
  |  Branch (348:6): [True: 6.27k, False: 0]
  ------------------
  349|  6.27k|	  if (argsLen == argsSize) {
  ------------------
  |  Branch (349:8): [True: 0, False: 6.27k]
  ------------------
  350|      0|	    argsSize *= 2;
  351|      0|	    args = (GStringFormatArg *)greallocn(args, argsSize,
  352|      0|						 sizeof(GStringFormatArg));
  353|      0|	  }
  354|  6.27k|	  switch (ft) {
  ------------------
  |  Branch (354:12): [True: 0, False: 6.27k]
  ------------------
  355|      0|	  case fmtIntDecimal:
  ------------------
  |  Branch (355:4): [True: 0, False: 6.27k]
  ------------------
  356|  4.48k|	  case fmtIntHex:
  ------------------
  |  Branch (356:4): [True: 4.48k, False: 1.78k]
  ------------------
  357|  4.48k|	  case fmtIntOctal:
  ------------------
  |  Branch (357:4): [True: 0, False: 6.27k]
  ------------------
  358|  4.48k|	  case fmtIntBinary:
  ------------------
  |  Branch (358:4): [True: 0, False: 6.27k]
  ------------------
  359|  4.48k|	  case fmtSpace:
  ------------------
  |  Branch (359:4): [True: 0, False: 6.27k]
  ------------------
  360|  4.48k|	    args[argsLen].i = va_arg(argList, int);
  361|  4.48k|	    break;
  362|      0|	  case fmtUIntDecimal:
  ------------------
  |  Branch (362:4): [True: 0, False: 6.27k]
  ------------------
  363|      0|	  case fmtUIntHex:
  ------------------
  |  Branch (363:4): [True: 0, False: 6.27k]
  ------------------
  364|      0|	  case fmtUIntOctal:
  ------------------
  |  Branch (364:4): [True: 0, False: 6.27k]
  ------------------
  365|      0|	  case fmtUIntBinary:
  ------------------
  |  Branch (365:4): [True: 0, False: 6.27k]
  ------------------
  366|      0|	    args[argsLen].ui = va_arg(argList, Guint);
  367|      0|	    break;
  368|      0|	  case fmtLongDecimal:
  ------------------
  |  Branch (368:4): [True: 0, False: 6.27k]
  ------------------
  369|      0|	  case fmtLongHex:
  ------------------
  |  Branch (369:4): [True: 0, False: 6.27k]
  ------------------
  370|      0|	  case fmtLongOctal:
  ------------------
  |  Branch (370:4): [True: 0, False: 6.27k]
  ------------------
  371|      0|	  case fmtLongBinary:
  ------------------
  |  Branch (371:4): [True: 0, False: 6.27k]
  ------------------
  372|      0|	    args[argsLen].l = va_arg(argList, long);
  373|      0|	    break;
  374|      0|	  case fmtULongDecimal:
  ------------------
  |  Branch (374:4): [True: 0, False: 6.27k]
  ------------------
  375|      0|	  case fmtULongHex:
  ------------------
  |  Branch (375:4): [True: 0, False: 6.27k]
  ------------------
  376|      0|	  case fmtULongOctal:
  ------------------
  |  Branch (376:4): [True: 0, False: 6.27k]
  ------------------
  377|      0|	  case fmtULongBinary:
  ------------------
  |  Branch (377:4): [True: 0, False: 6.27k]
  ------------------
  378|      0|	    args[argsLen].ul = va_arg(argList, Gulong);
  379|      0|	    break;
  380|      0|#ifdef LLONG_MAX
  381|      0|	  case fmtLongLongDecimal:
  ------------------
  |  Branch (381:4): [True: 0, False: 6.27k]
  ------------------
  382|      0|	  case fmtLongLongHex:
  ------------------
  |  Branch (382:4): [True: 0, False: 6.27k]
  ------------------
  383|      0|	  case fmtLongLongOctal:
  ------------------
  |  Branch (383:4): [True: 0, False: 6.27k]
  ------------------
  384|      0|	  case fmtLongLongBinary:
  ------------------
  |  Branch (384:4): [True: 0, False: 6.27k]
  ------------------
  385|      0|	    args[argsLen].ll = va_arg(argList, long long);
  386|      0|	    break;
  387|      0|#endif
  388|      0|#ifdef ULLONG_MAX
  389|      0|	  case fmtULongLongDecimal:
  ------------------
  |  Branch (389:4): [True: 0, False: 6.27k]
  ------------------
  390|      0|	  case fmtULongLongHex:
  ------------------
  |  Branch (390:4): [True: 0, False: 6.27k]
  ------------------
  391|      0|	  case fmtULongLongOctal:
  ------------------
  |  Branch (391:4): [True: 0, False: 6.27k]
  ------------------
  392|      0|	  case fmtULongLongBinary:
  ------------------
  |  Branch (392:4): [True: 0, False: 6.27k]
  ------------------
  393|      0|	    args[argsLen].ull = va_arg(argList, unsigned long long);
  394|      0|	    break;
  395|      0|#endif
  396|      0|	  case fmtDouble:
  ------------------
  |  Branch (396:4): [True: 0, False: 6.27k]
  ------------------
  397|      0|	  case fmtDoubleTrim:
  ------------------
  |  Branch (397:4): [True: 0, False: 6.27k]
  ------------------
  398|      0|	    args[argsLen].f = va_arg(argList, double);
  399|      0|	    break;
  400|      0|	  case fmtChar:
  ------------------
  |  Branch (400:4): [True: 0, False: 6.27k]
  ------------------
  401|      0|	    args[argsLen].c = (char)va_arg(argList, int);
  402|      0|	    break;
  403|  1.78k|	  case fmtString:
  ------------------
  |  Branch (403:4): [True: 1.78k, False: 4.48k]
  ------------------
  404|  1.78k|	    args[argsLen].s = va_arg(argList, char *);
  405|  1.78k|	    break;
  406|      0|	  case fmtGString:
  ------------------
  |  Branch (406:4): [True: 0, False: 6.27k]
  ------------------
  407|      0|	    args[argsLen].gs = va_arg(argList, GString *);
  408|      0|	    break;
  409|  6.27k|	  }
  410|  6.27k|	  ++argsLen;
  411|  6.27k|	}
  412|       |
  413|       |	// format the argument
  414|  6.27k|	arg = args[idx];
  415|  6.27k|	str = NULL;
  416|  6.27k|	len = 0;
  417|  6.27k|	switch (ft) {
  ------------------
  |  Branch (417:10): [True: 0, False: 6.27k]
  ------------------
  418|      0|	case fmtIntDecimal:
  ------------------
  |  Branch (418:2): [True: 0, False: 6.27k]
  ------------------
  419|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  420|      0|	  break;
  421|  4.48k|	case fmtIntHex:
  ------------------
  |  Branch (421:2): [True: 4.48k, False: 1.78k]
  ------------------
  422|  4.48k|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  423|  4.48k|	  break;
  424|      0|	case fmtIntOctal:
  ------------------
  |  Branch (424:2): [True: 0, False: 6.27k]
  ------------------
  425|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  426|      0|	  break;
  427|      0|	case fmtIntBinary:
  ------------------
  |  Branch (427:2): [True: 0, False: 6.27k]
  ------------------
  428|      0|	  formatInt(arg.i, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  429|      0|	  break;
  430|      0|	case fmtUIntDecimal:
  ------------------
  |  Branch (430:2): [True: 0, False: 6.27k]
  ------------------
  431|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 10,
  432|      0|		     &str, &len);
  433|      0|	  break;
  434|      0|	case fmtUIntHex:
  ------------------
  |  Branch (434:2): [True: 0, False: 6.27k]
  ------------------
  435|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 16,
  436|      0|		     &str, &len);
  437|      0|	  break;
  438|      0|	case fmtUIntOctal:
  ------------------
  |  Branch (438:2): [True: 0, False: 6.27k]
  ------------------
  439|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  440|      0|	  break;
  441|      0|	case fmtUIntBinary:
  ------------------
  |  Branch (441:2): [True: 0, False: 6.27k]
  ------------------
  442|      0|	  formatUInt(arg.ui, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  443|      0|	  break;
  444|      0|	case fmtLongDecimal:
  ------------------
  |  Branch (444:2): [True: 0, False: 6.27k]
  ------------------
  445|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  446|      0|	  break;
  447|      0|	case fmtLongHex:
  ------------------
  |  Branch (447:2): [True: 0, False: 6.27k]
  ------------------
  448|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  449|      0|	  break;
  450|      0|	case fmtLongOctal:
  ------------------
  |  Branch (450:2): [True: 0, False: 6.27k]
  ------------------
  451|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  452|      0|	  break;
  453|      0|	case fmtLongBinary:
  ------------------
  |  Branch (453:2): [True: 0, False: 6.27k]
  ------------------
  454|      0|	  formatInt(arg.l, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  455|      0|	  break;
  456|      0|	case fmtULongDecimal:
  ------------------
  |  Branch (456:2): [True: 0, False: 6.27k]
  ------------------
  457|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 10,
  458|      0|		     &str, &len);
  459|      0|	  break;
  460|      0|	case fmtULongHex:
  ------------------
  |  Branch (460:2): [True: 0, False: 6.27k]
  ------------------
  461|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 16,
  462|      0|		     &str, &len);
  463|      0|	  break;
  464|      0|	case fmtULongOctal:
  ------------------
  |  Branch (464:2): [True: 0, False: 6.27k]
  ------------------
  465|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  466|      0|	  break;
  467|      0|	case fmtULongBinary:
  ------------------
  |  Branch (467:2): [True: 0, False: 6.27k]
  ------------------
  468|      0|	  formatUInt(arg.ul, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  469|      0|	  break;
  470|      0|#ifdef LLONG_MAX
  471|      0|	case fmtLongLongDecimal:
  ------------------
  |  Branch (471:2): [True: 0, False: 6.27k]
  ------------------
  472|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 10, &str, &len);
  473|      0|	  break;
  474|      0|	case fmtLongLongHex:
  ------------------
  |  Branch (474:2): [True: 0, False: 6.27k]
  ------------------
  475|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 16, &str, &len);
  476|      0|	  break;
  477|      0|	case fmtLongLongOctal:
  ------------------
  |  Branch (477:2): [True: 0, False: 6.27k]
  ------------------
  478|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 8, &str, &len);
  479|      0|	  break;
  480|      0|	case fmtLongLongBinary:
  ------------------
  |  Branch (480:2): [True: 0, False: 6.27k]
  ------------------
  481|      0|	  formatInt(arg.ll, buf, sizeof(buf), zeroFill, width, 2, &str, &len);
  482|      0|	  break;
  483|      0|#endif
  484|      0|#ifdef ULLONG_MAX
  485|      0|	case fmtULongLongDecimal:
  ------------------
  |  Branch (485:2): [True: 0, False: 6.27k]
  ------------------
  486|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 10,
  487|      0|		     &str, &len);
  488|      0|	  break;
  489|      0|	case fmtULongLongHex:
  ------------------
  |  Branch (489:2): [True: 0, False: 6.27k]
  ------------------
  490|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 16,
  491|      0|		     &str, &len);
  492|      0|	  break;
  493|      0|	case fmtULongLongOctal:
  ------------------
  |  Branch (493:2): [True: 0, False: 6.27k]
  ------------------
  494|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 8,
  495|      0|		     &str, &len);
  496|      0|	  break;
  497|      0|	case fmtULongLongBinary:
  ------------------
  |  Branch (497:2): [True: 0, False: 6.27k]
  ------------------
  498|      0|	  formatUInt(arg.ull, buf, sizeof(buf), zeroFill, width, 2,
  499|      0|		     &str, &len);
  500|      0|	  break;
  501|      0|#endif
  502|      0|	case fmtDouble:
  ------------------
  |  Branch (502:2): [True: 0, False: 6.27k]
  ------------------
  503|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gFalse, &str, &len);
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  504|      0|	  break;
  505|      0|	case fmtDoubleTrim:
  ------------------
  |  Branch (505:2): [True: 0, False: 6.27k]
  ------------------
  506|      0|	  formatDouble(arg.f, buf, sizeof(buf), prec, gTrue, &str, &len);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  507|      0|	  break;
  508|      0|	case fmtChar:
  ------------------
  |  Branch (508:2): [True: 0, False: 6.27k]
  ------------------
  509|      0|	  buf[0] = arg.c;
  510|      0|	  str = buf;
  511|      0|	  len = 1;
  512|      0|	  reverseAlign = !reverseAlign;
  513|      0|	  break;
  514|  1.78k|	case fmtString:
  ------------------
  |  Branch (514:2): [True: 1.78k, False: 4.48k]
  ------------------
  515|  1.78k|	  if (arg.s) {
  ------------------
  |  Branch (515:8): [True: 1.78k, False: 0]
  ------------------
  516|  1.78k|	    str = arg.s;
  517|  1.78k|	    len = (int)strlen(str);
  518|  1.78k|	  } else {
  519|      0|	    str = "(null)";
  520|      0|	    len = 6;
  521|      0|	  }
  522|  1.78k|	  reverseAlign = !reverseAlign;
  523|  1.78k|	  break;
  524|      0|	case fmtGString:
  ------------------
  |  Branch (524:2): [True: 0, False: 6.27k]
  ------------------
  525|      0|	  if (arg.gs) {
  ------------------
  |  Branch (525:8): [True: 0, False: 0]
  ------------------
  526|      0|	    str = arg.gs->getCString();
  527|      0|	    len = arg.gs->getLength();
  528|      0|	  } else {
  529|      0|	    str = "(null)";
  530|      0|	    len = 6;
  531|      0|	  }
  532|      0|	  reverseAlign = !reverseAlign;
  533|      0|	  break;
  534|      0|	case fmtSpace:
  ------------------
  |  Branch (534:2): [True: 0, False: 6.27k]
  ------------------
  535|      0|	  str = buf;
  536|      0|	  len = 0;
  537|      0|	  width = arg.i;
  538|      0|	  break;
  539|  6.27k|	}
  540|       |
  541|       |	// append the formatted arg, handling width and alignment
  542|  6.27k|	if (!reverseAlign && len < width) {
  ------------------
  |  Branch (542:6): [True: 4.48k, False: 1.78k]
  |  Branch (542:23): [True: 0, False: 4.48k]
  ------------------
  543|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (543:18): [True: 0, False: 0]
  ------------------
  544|      0|	    append(' ');
  545|      0|	  }
  546|      0|	}
  547|  6.27k|	append(str, len);
  548|  6.27k|	if (reverseAlign && len < width) {
  ------------------
  |  Branch (548:6): [True: 1.78k, False: 4.48k]
  |  Branch (548:22): [True: 0, False: 1.78k]
  ------------------
  549|      0|	  for (i = len; i < width; ++i) {
  ------------------
  |  Branch (549:18): [True: 0, False: 0]
  ------------------
  550|      0|	    append(' ');
  551|      0|	  }
  552|      0|	}
  553|  6.27k|      }
  554|       |
  555|  13.0k|    } else if (*p0 == '}') {
  ------------------
  |  Branch (555:16): [True: 0, False: 13.0k]
  ------------------
  556|      0|      ++p0;
  557|      0|      if (*p0 == '}') {
  ------------------
  |  Branch (557:11): [True: 0, False: 0]
  ------------------
  558|      0|	++p0;
  559|      0|      }
  560|      0|      append('}');
  561|       |      
  562|  13.0k|    } else {
  563|  69.4k|      for (p1 = p0 + 1; *p1 && *p1 != '{' && *p1 != '}'; ++p1) ;
  ------------------
  |  Branch (563:25): [True: 62.6k, False: 6.80k]
  |  Branch (563:32): [True: 56.3k, False: 6.27k]
  |  Branch (563:46): [True: 56.3k, False: 0]
  ------------------
  564|  13.0k|      append(p0, (int)(p1 - p0));
  565|  13.0k|      p0 = p1;
  566|  13.0k|    }
  567|  19.3k|  }
  568|       |
  569|  6.80k|  gfree(args);
  570|  6.80k|  return this;
  571|  6.80k|}
_ZN7GString9formatIntExPciiiiPPKcPi:
  576|  4.48k|			const char **p, int *len) {
  577|       |#else
  578|       |void GString::formatInt(long x, char *buf, int bufSize,
  579|       |			GBool zeroFill, int width, int base,
  580|       |			const char **p, int *len) {
  581|       |#endif
  582|  4.48k|  static char vals[17] = "0123456789abcdef";
  583|  4.48k|  GBool neg;
  584|  4.48k|  int start, i, j;
  585|       |
  586|  4.48k|  i = bufSize;
  587|  4.48k|  if ((neg = x < 0)) {
  ------------------
  |  Branch (587:7): [True: 0, False: 4.48k]
  ------------------
  588|      0|    x = -x;
  589|      0|  }
  590|  4.48k|  start = neg ? 1 : 0;
  ------------------
  |  Branch (590:11): [True: 0, False: 4.48k]
  ------------------
  591|  4.48k|  if (x == 0) {
  ------------------
  |  Branch (591:7): [True: 0, False: 4.48k]
  ------------------
  592|      0|    buf[--i] = '0';
  593|  4.48k|  } else {
  594|  13.4k|    while (i > start && x) {
  ------------------
  |  Branch (594:12): [True: 13.4k, False: 0]
  |  Branch (594:25): [True: 8.94k, False: 4.48k]
  ------------------
  595|  8.94k|      buf[--i] = vals[x % base];
  596|  8.94k|      x /= base;
  597|  8.94k|    }
  598|  4.48k|  }
  599|  4.48k|  if (zeroFill) {
  ------------------
  |  Branch (599:7): [True: 4.48k, False: 0]
  ------------------
  600|  4.51k|    for (j = bufSize - i; i > start && j < width - start; ++j) {
  ------------------
  |  Branch (600:27): [True: 4.51k, False: 0]
  |  Branch (600:40): [True: 26, False: 4.48k]
  ------------------
  601|     26|      buf[--i] = '0';
  602|     26|    }
  603|  4.48k|  }
  604|  4.48k|  if (neg) {
  ------------------
  |  Branch (604:7): [True: 0, False: 4.48k]
  ------------------
  605|      0|    buf[--i] = '-';
  606|      0|  }
  607|  4.48k|  *p = buf + i;
  608|  4.48k|  *len = bufSize - i;
  609|  4.48k|}
_ZN7GString6resizeEi:
  108|   147k|inline void GString::resize(int length1) {
  109|   147k|  char *s1;
  110|       |
  111|   147k|  if (length1 < 0) {
  ------------------
  |  Branch (111:7): [True: 0, False: 147k]
  ------------------
  112|      0|    gMemError("GString::resize() with negative length");
  113|      0|  }
  114|   147k|  if (!s) {
  ------------------
  |  Branch (114:7): [True: 26.5k, False: 120k]
  ------------------
  115|  26.5k|    s = new char[size(length1)];
  116|   120k|  } else if (size(length1) != size(length)) {
  ------------------
  |  Branch (116:14): [True: 15.9k, False: 104k]
  ------------------
  117|  15.9k|    s1 = new char[size(length1)];
  118|  15.9k|    if (length1 < length) {
  ------------------
  |  Branch (118:9): [True: 0, False: 15.9k]
  ------------------
  119|      0|      memcpy(s1, s, length1);
  120|      0|      s1[length1] = '\0';
  121|  15.9k|    } else {
  122|  15.9k|      memcpy(s1, s, length + 1);
  123|  15.9k|    }
  124|  15.9k|    delete[] s;
  125|  15.9k|    s = s1;
  126|  15.9k|  }
  127|   147k|}
GString.cc:_ZL4sizei:
   98|   283k|static inline int size(int len) {
   99|   283k|  int delta;
  100|   860k|  for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
  ------------------
  |  Branch (100:19): [True: 576k, False: 283k]
  |  Branch (100:34): [True: 576k, False: 0]
  ------------------
  101|   283k|  if (len > INT_MAX - delta) {
  ------------------
  |  Branch (101:7): [True: 0, False: 283k]
  ------------------
  102|      0|    gMemError("Integer overflow in GString::size()");
  103|      0|  }
  104|       |  // this is ((len + 1) + (delta - 1)) & ~(delta - 1)
  105|   283k|  return (len + delta) & ~(delta - 1);
  106|   283k|}

_ZN7GString10getCStringEv:
   79|  11.9k|  char *getCString() { return s; }
_ZN7GString9getLengthEv:
   76|   114k|  int getLength() { return length; }
_ZN7GString7getCharEi:
   82|  96.6k|  char getChar(int i) { return s[i]; }

_Z10getHomeDirv:
   49|    610|GString *getHomeDir() {
   50|       |#ifdef VMS
   51|       |  //---------- VMS ----------
   52|       |  return new GString("SYS$LOGIN:");
   53|       |
   54|       |#elif defined(_WIN32)
   55|       |  //---------- Win32 ----------
   56|       |  char *s;
   57|       |  GString *ret;
   58|       |
   59|       |  if ((s = getenv("USERPROFILE")))
   60|       |    ret = new GString(s);
   61|       |  else
   62|       |    ret = new GString(".");
   63|       |  return ret;
   64|       |
   65|       |#elif defined(__EMX__)
   66|       |  //---------- OS/2+EMX ----------
   67|       |  char *s;
   68|       |  GString *ret;
   69|       |
   70|       |  if ((s = getenv("HOME")))
   71|       |    ret = new GString(s);
   72|       |  else
   73|       |    ret = new GString(".");
   74|       |  return ret;
   75|       |
   76|       |#elif defined(ACORN)
   77|       |  //---------- RISCOS ----------
   78|       |  return new GString("@");
   79|       |
   80|       |#else
   81|       |  //---------- Unix ----------
   82|    610|  char *s;
   83|    610|  struct passwd *pw;
   84|    610|  GString *ret;
   85|       |
   86|    610|  if ((s = getenv("HOME"))) {
  ------------------
  |  Branch (86:7): [True: 610, False: 0]
  ------------------
   87|    610|    ret = new GString(s);
   88|    610|  } else {
   89|      0|    if ((s = getenv("USER")))
  ------------------
  |  Branch (89:9): [True: 0, False: 0]
  ------------------
   90|      0|      pw = getpwnam(s);
   91|      0|    else
   92|      0|      pw = getpwuid(getuid());
   93|      0|    if (pw)
  ------------------
  |  Branch (93:9): [True: 0, False: 0]
  ------------------
   94|      0|      ret = new GString(pw->pw_dir);
   95|      0|    else
   96|      0|      ret = new GString(".");
   97|      0|  }
   98|    610|  return ret;
   99|    610|#endif
  100|    610|}
_Z12appendToPathP7GStringPKc:
  118|  9.15k|GString *appendToPath(GString *path, const char *fileName) {
  119|       |#if defined(VMS)
  120|       |  //---------- VMS ----------
  121|       |  //~ this should handle everything necessary for file
  122|       |  //~ requesters, but it's certainly not complete
  123|       |  char *p0, *p1, *p2;
  124|       |  char *q1;
  125|       |
  126|       |  p0 = path->getCString();
  127|       |  p1 = p0 + path->getLength() - 1;
  128|       |  if (!strcmp(fileName, "-")) {
  129|       |    if (*p1 == ']') {
  130|       |      for (p2 = p1; p2 > p0 && *p2 != '.' && *p2 != '['; --p2) ;
  131|       |      if (*p2 == '[')
  132|       |	++p2;
  133|       |      path->del(p2 - p0, p1 - p2);
  134|       |    } else if (*p1 == ':') {
  135|       |      path->append("[-]");
  136|       |    } else {
  137|       |      path->clear();
  138|       |      path->append("[-]");
  139|       |    }
  140|       |  } else if ((q1 = strrchr(fileName, '.')) && !strncmp(q1, ".DIR;", 5)) {
  141|       |    if (*p1 == ']') {
  142|       |      path->insert(p1 - p0, '.');
  143|       |      path->insert(p1 - p0 + 1, fileName, q1 - fileName);
  144|       |    } else if (*p1 == ':') {
  145|       |      path->append('[');
  146|       |      path->append(']');
  147|       |      path->append(fileName, q1 - fileName);
  148|       |    } else {
  149|       |      path->clear();
  150|       |      path->append(fileName, q1 - fileName);
  151|       |    }
  152|       |  } else {
  153|       |    if (*p1 != ']' && *p1 != ':')
  154|       |      path->clear();
  155|       |    path->append(fileName);
  156|       |  }
  157|       |  return path;
  158|       |
  159|       |#elif defined(_WIN32)
  160|       |  //---------- Win32 ----------
  161|       |  GString *tmp;
  162|       |  char buf[256];
  163|       |  char *fp;
  164|       |
  165|       |  tmp = new GString(path);
  166|       |  tmp->append('/');
  167|       |  tmp->append(fileName);
  168|       |  GetFullPathNameA(tmp->getCString(), sizeof(buf), buf, &fp);
  169|       |  delete tmp;
  170|       |  path->clear();
  171|       |  path->append(buf);
  172|       |  return path;
  173|       |
  174|       |#elif defined(ACORN)
  175|       |  //---------- RISCOS ----------
  176|       |  char *p;
  177|       |  int i;
  178|       |
  179|       |  path->append(".");
  180|       |  i = path->getLength();
  181|       |  path->append(fileName);
  182|       |  for (p = path->getCString() + i; *p; ++p) {
  183|       |    if (*p == '/') {
  184|       |      *p = '.';
  185|       |    } else if (*p == '.') {
  186|       |      *p = '/';
  187|       |    }
  188|       |  }
  189|       |  return path;
  190|       |
  191|       |#elif defined(__EMX__)
  192|       |  //---------- OS/2+EMX ----------
  193|       |  int i;
  194|       |
  195|       |  // appending "." does nothing
  196|       |  if (!strcmp(fileName, "."))
  197|       |    return path;
  198|       |
  199|       |  // appending ".." goes up one directory
  200|       |  if (!strcmp(fileName, "..")) {
  201|       |    for (i = path->getLength() - 2; i >= 0; --i) {
  202|       |      if (path->getChar(i) == '/' || path->getChar(i) == '\\' ||
  203|       |	  path->getChar(i) == ':')
  204|       |	break;
  205|       |    }
  206|       |    if (i <= 0) {
  207|       |      if (path->getChar(0) == '/' || path->getChar(0) == '\\') {
  208|       |	path->del(1, path->getLength() - 1);
  209|       |      } else if (path->getLength() >= 2 && path->getChar(1) == ':') {
  210|       |	path->del(2, path->getLength() - 2);
  211|       |      } else {
  212|       |	path->clear();
  213|       |	path->append("..");
  214|       |      }
  215|       |    } else {
  216|       |      if (path->getChar(i-1) == ':')
  217|       |	++i;
  218|       |      path->del(i, path->getLength() - i);
  219|       |    }
  220|       |    return path;
  221|       |  }
  222|       |
  223|       |  // otherwise, append "/" and new path component
  224|       |  if (path->getLength() > 0 &&
  225|       |      path->getChar(path->getLength() - 1) != '/' &&
  226|       |      path->getChar(path->getLength() - 1) != '\\')
  227|       |    path->append('/');
  228|       |  path->append(fileName);
  229|       |  return path;
  230|       |
  231|       |#else
  232|       |  //---------- Unix ----------
  233|  9.15k|  int i;
  234|       |
  235|       |  // appending "." does nothing
  236|  9.15k|  if (!strcmp(fileName, "."))
  ------------------
  |  Branch (236:7): [True: 0, False: 9.15k]
  ------------------
  237|      0|    return path;
  238|       |
  239|       |  // appending ".." goes up one directory
  240|  9.15k|  if (!strcmp(fileName, "..")) {
  ------------------
  |  Branch (240:7): [True: 0, False: 9.15k]
  ------------------
  241|      0|    for (i = path->getLength() - 2; i >= 0; --i) {
  ------------------
  |  Branch (241:37): [True: 0, False: 0]
  ------------------
  242|      0|      if (path->getChar(i) == '/')
  ------------------
  |  Branch (242:11): [True: 0, False: 0]
  ------------------
  243|      0|	break;
  244|      0|    }
  245|      0|    if (i <= 0) {
  ------------------
  |  Branch (245:9): [True: 0, False: 0]
  ------------------
  246|      0|      if (path->getChar(0) == '/') {
  ------------------
  |  Branch (246:11): [True: 0, False: 0]
  ------------------
  247|      0|	path->del(1, path->getLength() - 1);
  248|      0|      } else {
  249|      0|	path->clear();
  250|      0|	path->append("..");
  251|      0|      }
  252|      0|    } else {
  253|      0|      path->del(i, path->getLength() - i);
  254|      0|    }
  255|      0|    return path;
  256|      0|  }
  257|       |
  258|       |  // otherwise, append "/" and new path component
  259|  9.15k|  if (path->getLength() > 0 &&
  ------------------
  |  Branch (259:7): [True: 9.15k, False: 0]
  ------------------
  260|  9.15k|      path->getChar(path->getLength() - 1) != '/')
  ------------------
  |  Branch (260:7): [True: 9.15k, False: 0]
  ------------------
  261|  9.15k|    path->append('/');
  262|  9.15k|  path->append(fileName);
  263|  9.15k|  return path;
  264|  9.15k|#endif
  265|  9.15k|}

_Z7gmalloci:
  139|   565k|void *gmalloc(int size) GMEM_EXCEP {
  140|   565k|  void *p;
  141|       |
  142|   565k|  if (size < 0) {
  ------------------
  |  Branch (142:7): [True: 0, False: 565k]
  ------------------
  143|      0|    gMemError("Invalid memory allocation size");
  144|      0|  }
  145|   565k|  if (size == 0) {
  ------------------
  |  Branch (145:7): [True: 0, False: 565k]
  ------------------
  146|      0|    return NULL;
  147|      0|  }
  148|   565k|  if (!(p = malloc(size))) {
  ------------------
  |  Branch (148:7): [True: 0, False: 565k]
  ------------------
  149|      0|    gMemError("Out of memory");
  150|      0|  }
  151|   565k|  return p;
  152|   565k|}
_Z8greallocPvi:
  155|    488|void *grealloc(void *p, int size) GMEM_EXCEP {
  156|       |#ifdef DEBUG_MEM
  157|       |  GMemHdr *hdr;
  158|       |  void *q;
  159|       |  int oldSize;
  160|       |
  161|       |  if (size < 0) {
  162|       |    gMemError("Invalid memory allocation size");
  163|       |  }
  164|       |  if (size == 0) {
  165|       |    if (p) {
  166|       |      gfree(p);
  167|       |    }
  168|       |    return NULL;
  169|       |  }
  170|       |  if (p) {
  171|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  172|       |    oldSize = (int)hdr->size;
  173|       |    q = gmalloc(size);
  174|       |    memcpy(q, p, size < oldSize ? size : oldSize);
  175|       |    gfree(p);
  176|       |  } else {
  177|       |    q = gmalloc(size);
  178|       |  }
  179|       |  return q;
  180|       |#else
  181|    488|  void *q;
  182|       |
  183|    488|  if (size < 0) {
  ------------------
  |  Branch (183:7): [True: 0, False: 488]
  ------------------
  184|      0|    gMemError("Invalid memory allocation size");
  185|      0|  }
  186|    488|  if (size == 0) {
  ------------------
  |  Branch (186:7): [True: 0, False: 488]
  ------------------
  187|      0|    if (p) {
  ------------------
  |  Branch (187:9): [True: 0, False: 0]
  ------------------
  188|      0|      free(p);
  189|      0|    }
  190|      0|    return NULL;
  191|      0|  }
  192|    488|  if (p) {
  ------------------
  |  Branch (192:7): [True: 488, False: 0]
  ------------------
  193|    488|    q = realloc(p, size);
  194|    488|  } else {
  195|      0|    q = malloc(size);
  196|      0|  }
  197|    488|  if (!q) {
  ------------------
  |  Branch (197:7): [True: 0, False: 488]
  ------------------
  198|      0|    gMemError("Out of memory");
  199|      0|  }
  200|    488|  return q;
  201|    488|#endif
  202|    488|}
_Z8gmallocnii:
  204|  20.3k|void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
  205|  20.3k|  int n;
  206|       |
  207|  20.3k|  if (nObjs == 0) {
  ------------------
  |  Branch (207:7): [True: 0, False: 20.3k]
  ------------------
  208|      0|    return NULL;
  209|      0|  }
  210|  20.3k|  n = nObjs * objSize;
  211|  20.3k|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (211:7): [True: 0, False: 20.3k]
  |  Branch (211:23): [True: 0, False: 20.3k]
  |  Branch (211:36): [True: 0, False: 20.3k]
  ------------------
  212|      0|    gMemError("Bogus memory allocation size");
  213|      0|  }
  214|  20.3k|  return gmalloc(n);
  215|  20.3k|}
_Z9greallocnPvii:
  291|    488|void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
  292|    488|  int n;
  293|       |
  294|    488|  if (nObjs == 0) {
  ------------------
  |  Branch (294:7): [True: 0, False: 488]
  ------------------
  295|      0|    if (p) {
  ------------------
  |  Branch (295:9): [True: 0, False: 0]
  ------------------
  296|      0|      gfree(p);
  297|      0|    }
  298|      0|    return NULL;
  299|      0|  }
  300|    488|  n = nObjs * objSize;
  301|    488|  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
  ------------------
  |  Branch (301:7): [True: 0, False: 488]
  |  Branch (301:23): [True: 0, False: 488]
  |  Branch (301:36): [True: 0, False: 488]
  ------------------
  302|      0|    gMemError("Bogus memory allocation size");
  303|      0|  }
  304|    488|  return grealloc(p, n);
  305|    488|}
_Z5gfreePv:
  307|   565k|void gfree(void *p) {
  308|       |#ifdef DEBUG_MEM
  309|       |  size_t size;
  310|       |  GMemHdr *hdr;
  311|       |  unsigned long *trl, *clr;
  312|       |
  313|       |  if (p) {
  314|       |    hdr = (GMemHdr *)((char *)p - gMemHdrSize);
  315|       |    gMemLock;
  316|       |    if (hdr->magic == gMemMagic &&
  317|       |	((hdr->prev == NULL) == (hdr == gMemHead)) &&
  318|       |	((hdr->next == NULL) == (hdr == gMemTail))) {
  319|       |      if (hdr->prev) {
  320|       |	hdr->prev->next = hdr->next;
  321|       |      } else {
  322|       |	gMemHead = hdr->next;
  323|       |      }
  324|       |      if (hdr->next) {
  325|       |	hdr->next->prev = hdr->prev;
  326|       |      } else {
  327|       |	gMemTail = hdr->prev;
  328|       |      }
  329|       |      --gMemAlloc;
  330|       |      gMemInUse -= hdr->size;
  331|       |      gMemUnlock;
  332|       |      size = gMemDataSize64(hdr->size);
  333|       |      trl = (unsigned long *)((char *)hdr + gMemHdrSize + size);
  334|       |      if (*trl != gMemDeadVal) {
  335|       |	fprintf(stderr, "Overwrite past end of block %d at address %p\n",
  336|       |		hdr->index, p);
  337|       |      }
  338|       |      for (clr = (unsigned long *)hdr; clr <= trl; ++clr) {
  339|       |	*clr = gMemDeadVal;
  340|       |      }
  341|       |      free(hdr);
  342|       |    } else {
  343|       |      gMemUnlock;
  344|       |      fprintf(stderr, "Attempted to free bad address %p\n", p);
  345|       |    }
  346|       |  }
  347|       |#else
  348|   565k|  if (p) {
  ------------------
  |  Branch (348:7): [True: 565k, False: 488]
  ------------------
  349|   565k|    free(p);
  350|   565k|  }
  351|   565k|#endif
  352|   565k|}
_Z10copyStringPKc:
  390|   544k|char *copyString(const char *s) {
  391|   544k|  char *s1;
  392|       |
  393|   544k|  s1 = (char *)gmalloc((int)strlen(s) + 1);
  394|   544k|  strcpy(s1, s);
  395|   544k|  return s1;
  396|   544k|}

_ZN17BuiltinFontWidthsC2EP16BuiltinFontWidthi:
   20|  1.70k|BuiltinFontWidths::BuiltinFontWidths(BuiltinFontWidth *widths, int sizeA) {
   21|  1.70k|  int i, h;
   22|       |
   23|  1.70k|  size = sizeA;
   24|  1.70k|  tab = (BuiltinFontWidth **)gmallocn(size, sizeof(BuiltinFontWidth *));
   25|   510k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (25:15): [True: 509k, False: 1.70k]
  ------------------
   26|   509k|    tab[i] = NULL;
   27|   509k|  }
   28|   510k|  for (i = 0; i < sizeA; ++i) {
  ------------------
  |  Branch (28:15): [True: 509k, False: 1.70k]
  ------------------
   29|   509k|    h = hash(widths[i].name);
   30|   509k|    widths[i].next = tab[h];
   31|   509k|    tab[h] = &widths[i];
   32|   509k|  }
   33|  1.70k|}
_ZN17BuiltinFontWidthsD2Ev:
   35|  1.70k|BuiltinFontWidths::~BuiltinFontWidths() {
   36|  1.70k|  gfree(tab);
   37|  1.70k|}
_ZN17BuiltinFontWidths4hashEPKc:
   54|   509k|int BuiltinFontWidths::hash(const char *name) {
   55|   509k|  const char *p;
   56|   509k|  unsigned int h;
   57|       |
   58|   509k|  h = 0;
   59|  3.78M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (59:18): [True: 3.27M, False: 509k]
  ------------------
   60|  3.27M|    h = 17 * h + (int)(*p & 0xff);
   61|  3.27M|  }
   62|   509k|  return (int)(h % size);
   63|   509k|}

_Z21initBuiltinFontTablesv:
 4262|    122|void initBuiltinFontTables() {
 4263|    122|  builtinFonts[0].widths = new BuiltinFontWidths(courierWidthsTab, 315);
 4264|    122|  builtinFonts[1].widths = new BuiltinFontWidths(courierBoldWidthsTab, 315);
 4265|    122|  builtinFonts[2].widths = new BuiltinFontWidths(courierBoldObliqueWidthsTab, 315);
 4266|    122|  builtinFonts[3].widths = new BuiltinFontWidths(courierObliqueWidthsTab, 315);
 4267|    122|  builtinFonts[4].widths = new BuiltinFontWidths(helveticaWidthsTab, 315);
 4268|    122|  builtinFonts[5].widths = new BuiltinFontWidths(helveticaBoldWidthsTab, 316);
 4269|    122|  builtinFonts[6].widths = new BuiltinFontWidths(helveticaBoldObliqueWidthsTab, 315);
 4270|    122|  builtinFonts[7].widths = new BuiltinFontWidths(helveticaObliqueWidthsTab, 315);
 4271|    122|  builtinFonts[8].widths = new BuiltinFontWidths(symbolWidthsTab, 190);
 4272|    122|  builtinFonts[9].widths = new BuiltinFontWidths(timesBoldWidthsTab, 315);
 4273|    122|  builtinFonts[10].widths = new BuiltinFontWidths(timesBoldItalicWidthsTab, 315);
 4274|    122|  builtinFonts[11].widths = new BuiltinFontWidths(timesItalicWidthsTab, 315);
 4275|    122|  builtinFonts[12].widths = new BuiltinFontWidths(timesRomanWidthsTab, 315);
 4276|    122|  builtinFonts[13].widths = new BuiltinFontWidths(zapfDingbatsWidthsTab, 202);
 4277|    122|}
_Z21freeBuiltinFontTablesv:
 4279|    122|void freeBuiltinFontTables() {
 4280|    122|  int i;
 4281|       |
 4282|  1.83k|  for (i = 0; i < 14; ++i) {
  ------------------
  |  Branch (4282:15): [True: 1.70k, False: 122]
  ------------------
 4283|  1.70k|    delete builtinFonts[i].widths;
 4284|  1.70k|  }
 4285|    122|}

_ZN9CMapCacheC2Ev:
  387|    122|CMapCache::CMapCache() {
  388|    122|  int i;
  389|       |
  390|    610|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    610|#define cMapCacheSize 4
  ------------------
  |  Branch (390:15): [True: 488, False: 122]
  ------------------
  391|    488|    cache[i] = NULL;
  392|    488|  }
  393|    122|}
_ZN9CMapCacheD2Ev:
  395|    122|CMapCache::~CMapCache() {
  396|    122|  int i;
  397|       |
  398|    610|  for (i = 0; i < cMapCacheSize; ++i) {
  ------------------
  |  |   92|    610|#define cMapCacheSize 4
  ------------------
  |  Branch (398:15): [True: 488, False: 122]
  ------------------
  399|    488|    if (cache[i]) {
  ------------------
  |  Branch (399:9): [True: 0, False: 488]
  ------------------
  400|      0|      cache[i]->decRefCnt();
  401|      0|    }
  402|    488|  }
  403|    122|}

_ZN22CharCodeToUnicodeCacheC2Ei:
  709|    244|CharCodeToUnicodeCache::CharCodeToUnicodeCache(int sizeA) {
  710|    244|  int i;
  711|       |
  712|    244|  size = sizeA;
  713|    244|  cache = (CharCodeToUnicode **)gmallocn(size, sizeof(CharCodeToUnicode *));
  714|  1.22k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (714:15): [True: 976, False: 244]
  ------------------
  715|    976|    cache[i] = NULL;
  716|    976|  }
  717|    244|}
_ZN22CharCodeToUnicodeCacheD2Ev:
  719|    244|CharCodeToUnicodeCache::~CharCodeToUnicodeCache() {
  720|    244|  int i;
  721|       |
  722|  1.22k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (722:15): [True: 976, False: 244]
  ------------------
  723|    976|    if (cache[i]) {
  ------------------
  |  Branch (723:9): [True: 0, False: 976]
  ------------------
  724|      0|      cache[i]->decRefCnt();
  725|      0|    }
  726|    976|  }
  727|    244|  gfree(cache);
  728|    244|}

_Z5error13ErrorCategorylPKcz:
   46|  2.31k|		 const char *msg, ...) {
   47|  2.31k|  va_list args;
   48|  2.31k|  GString *s, *sanitized;
   49|  2.31k|  char c;
   50|  2.31k|  int i;
   51|       |
   52|       |  // NB: this can be called before the globalParams object is created
   53|  2.31k|  if (!errorCbk && globalParams && globalParams->getErrQuiet()) {
  ------------------
  |  Branch (53:7): [True: 2.31k, False: 0]
  |  Branch (53:20): [True: 0, False: 2.31k]
  |  Branch (53:36): [True: 0, False: 0]
  ------------------
   54|      0|    return;
   55|      0|  }
   56|  2.31k|  va_start(args, msg);
   57|  2.31k|  s = GString::formatv(msg, args);
   58|  2.31k|  va_end(args);
   59|       |
   60|       |  // remove non-printable characters, just in case they might cause
   61|       |  // problems for the terminal program
   62|  2.31k|  sanitized = new GString();
   63|  89.8k|  for (i = 0; i < s->getLength(); ++i) {
  ------------------
  |  Branch (63:15): [True: 87.4k, False: 2.31k]
  ------------------
   64|  87.4k|    c = s->getChar(i);
   65|  87.4k|    if (c >= 0x20 && c <= 0x7e) {
  ------------------
  |  Branch (65:9): [True: 83.0k, False: 4.48k]
  |  Branch (65:22): [True: 83.0k, False: 2]
  ------------------
   66|  83.0k|      sanitized->append(c);
   67|  83.0k|    } else {
   68|  4.48k|      sanitized->appendf("<{0:02x}>", c & 0xff);
   69|  4.48k|    }
   70|  87.4k|  }
   71|       |
   72|  2.31k|  if (errorCbk) {
  ------------------
  |  Branch (72:7): [True: 0, False: 2.31k]
  ------------------
   73|      0|    (*errorCbk)(errorCbkData, category, (int)pos, sanitized->getCString());
   74|  2.31k|  } else {
   75|  2.31k|    fflush(stdout);
   76|  2.31k|    if (pos >= 0) {
  ------------------
  |  Branch (76:9): [True: 0, False: 2.31k]
  ------------------
   77|      0|      fprintf(stderr, "%s (%d): %s\n",
   78|      0|	      errorCategoryNames[category], (int)pos, sanitized->getCString());
   79|  2.31k|    } else {
   80|  2.31k|      fprintf(stderr, "%s: %s\n",
   81|  2.31k|	      errorCategoryNames[category], sanitized->getCString());
   82|  2.31k|    }
   83|  2.31k|    fflush(stderr);
   84|  2.31k|  }
   85|       |
   86|  2.31k|  delete s;
   87|  2.31k|  delete sanitized;
   88|  2.31k|}

_ZN11SysFontListC2Ev:
  374|    122|SysFontList::SysFontList() {
  375|    122|  fonts = new GList();
  376|    122|}
_ZN11SysFontListD2Ev:
  378|    122|SysFontList::~SysFontList() {
  379|    122|  deleteGList(fonts, SysFontInfo);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  380|    122|}
_ZN10KeyBindingC2EiiiPKc:
  560|  7.44k|KeyBinding::KeyBinding(int codeA, int modsA, int contextA, const char *cmd0) {
  561|  7.44k|  code = codeA;
  562|  7.44k|  mods = modsA;
  563|  7.44k|  context = contextA;
  564|  7.44k|  cmds = new GList();
  565|  7.44k|  cmds->append(new GString(cmd0));
  566|  7.44k|}
_ZN10KeyBindingD2Ev:
  585|  7.44k|KeyBinding::~KeyBinding() {
  586|  7.44k|  deleteGList(cmds, GString);
  ------------------
  |  |   94|  7.44k|  do {                                              \
  |  |   95|  7.44k|    GList *_list = (list);                          \
  |  |   96|  7.44k|    {                                               \
  |  |   97|  7.44k|      int _i;                                       \
  |  |   98|  14.8k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 7.44k, False: 7.44k]
  |  |  ------------------
  |  |   99|  7.44k|        delete (T*)_list->get(_i);                  \
  |  |  100|  7.44k|      }                                             \
  |  |  101|  7.44k|      delete _list;                                 \
  |  |  102|  7.44k|    }                                               \
  |  |  103|  7.44k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  587|  7.44k|}
_ZN12GlobalParamsC2EPKc:
  607|    122|GlobalParams::GlobalParams(const char *cfgFileName) {
  608|    122|  UnicodeMap *map;
  609|    122|  GString *fileName;
  610|    122|  FILE *f;
  611|    122|  int i;
  612|       |
  613|    122|#if MULTITHREADED
  614|    122|  gInitMutex(&mutex);
  ------------------
  |  |   51|    122|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  615|    122|  gInitMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   51|    122|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  616|    122|  gInitMutex(&cMapCacheMutex);
  ------------------
  |  |   51|    122|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  617|    122|#endif
  618|       |
  619|       |#ifdef _WIN32
  620|       |  tlsWin32ErrorInfo = TlsAlloc();
  621|       |#endif
  622|       |
  623|    122|  initBuiltinFontTables();
  624|       |
  625|       |  // scan the encoding in reverse because we want the lowest-numbered
  626|       |  // index for each char name ('space' is encoded twice)
  627|    122|  macRomanReverseMap = new NameToCharCode();
  628|  31.3k|  for (i = 255; i >= 0; --i) {
  ------------------
  |  Branch (628:17): [True: 31.2k, False: 122]
  ------------------
  629|  31.2k|    if (macRomanEncoding[i]) {
  ------------------
  |  Branch (629:9): [True: 27.2k, False: 4.02k]
  ------------------
  630|  27.2k|      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);
  631|  27.2k|    }
  632|  31.2k|  }
  633|       |
  634|       |#ifdef _WIN32
  635|       |  // baseDir will be set by a call to setBaseDir
  636|       |  baseDir = new GString();
  637|       |#else
  638|    122|  baseDir = appendToPath(getHomeDir(), ".xpdf");
  639|    122|#endif
  640|    122|  configFileVars = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  641|    122|  setDataDirVar();
  642|    122|  nameToUnicode = new NameToCharCode();
  643|    122|  cidToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  644|    122|  unicodeToUnicodes = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  645|    122|  residentUnicodeMaps = new GHash();
  646|    122|  unicodeMaps = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  647|    122|  cMapDirs = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  648|    122|  toUnicodeDirs = new GList();
  649|    122|  unicodeRemapping = new UnicodeRemapping();
  650|    122|  fontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  651|    122|  fontDirs = new GList();
  652|    122|  ccFontFiles = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  653|    122|  base14SysFonts = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  654|    122|  sysFonts = new SysFontList();
  655|       |#if HAVE_PAPER_H
  656|       |  const char *paperName;
  657|       |  const struct paper *paperType;
  658|       |  paperinit();
  659|       |  if ((paperName = systempapername())) {
  660|       |    paperType = paperinfo(paperName);
  661|       |    psPaperWidth = (int)paperpswidth(paperType);
  662|       |    psPaperHeight = (int)paperpsheight(paperType);
  663|       |  } else {
  664|       |    error(errConfig, -1, "No paper information available - using defaults");
  665|       |    psPaperWidth = defPaperWidth;
  666|       |    psPaperHeight = defPaperHeight;
  667|       |  }
  668|       |  paperdone();
  669|       |#else
  670|    122|  psPaperWidth = defPaperWidth;
  ------------------
  |  |   46|    122|#define defPaperWidth  612    // American letter (8.5x11")
  ------------------
  671|    122|  psPaperHeight = defPaperHeight;
  ------------------
  |  |   47|    122|#define defPaperHeight 792
  ------------------
  672|    122|#endif
  673|    122|  psImageableLLX = psImageableLLY = 0;
  674|    122|  psImageableURX = psPaperWidth;
  675|    122|  psImageableURY = psPaperHeight;
  676|    122|  psCrop = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  677|    122|  psUseCropBoxAsPage = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  678|    122|  psExpandSmaller = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  679|    122|  psShrinkLarger = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  680|    122|  psCenter = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  681|    122|  psDuplex = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  682|    122|  psLevel = psLevel2;
  683|    122|  psResidentFonts = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  684|    122|  psResidentFonts16 = new GList();
  685|    122|  psResidentFontsCC = new GList();
  686|    122|  psEmbedType1 = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  687|    122|  psEmbedTrueType = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  688|    122|  psEmbedCIDPostScript = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  689|    122|  psEmbedCIDTrueType = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  690|    122|  psFontPassthrough = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  691|    122|  psPreload = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  692|    122|  psOPI = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  693|    122|  psASCIIHex = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  694|    122|  psLZW = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  695|    122|  psUncompressPreloadedImages = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  696|    122|  psMinLineWidth = 0;
  697|    122|  psRasterResolution = 300;
  698|    122|  psRasterMono = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  699|    122|  psRasterSliceSize = 20000000;
  700|    122|  psAlwaysRasterize = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  701|    122|  psNeverRasterize = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  702|    122|  textEncoding = new GString(defaultTextEncoding);
  703|       |#if defined(_WIN32)
  704|       |  textEOL = eolDOS;
  705|       |#else
  706|    122|  textEOL = eolUnix;
  707|    122|#endif
  708|    122|  textPageBreaks = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  709|    122|  textKeepTinyChars = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  710|    122|  initialZoom = new GString("125");
  711|    122|  defaultFitZoom = 0;
  712|    122|  zoomScaleFactor = 1;
  713|    122|  zoomValues = new GList();
  714|    122|  zoomValues->append(new GString("25"));
  715|    122|  zoomValues->append(new GString("50"));
  716|    122|  zoomValues->append(new GString("75"));
  717|    122|  zoomValues->append(new GString("100"));
  718|    122|  zoomValues->append(new GString("110"));
  719|    122|  zoomValues->append(new GString("125"));
  720|    122|  zoomValues->append(new GString("150"));
  721|    122|  zoomValues->append(new GString("175"));
  722|    122|  zoomValues->append(new GString("200"));
  723|    122|  zoomValues->append(new GString("300"));
  724|    122|  zoomValues->append(new GString("400"));
  725|    122|  zoomValues->append(new GString("600"));
  726|    122|  zoomValues->append(new GString("800"));
  727|    122|  initialDisplayMode = new GString("continuous");
  728|    122|  initialToolbarState = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  729|    122|  initialSidebarState = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  730|    122|  initialSidebarWidth = 0;
  731|    122|  initialSelectMode = new GString("linear");
  732|    122|  maxTileWidth = 1500;
  733|    122|  maxTileHeight = 1500;
  734|    122|  tileCacheSize = 10;
  735|    122|  workerThreads = 1;
  736|    122|  enableFreeType = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  737|    122|  disableFreeTypeHinting = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  738|    122|  antialias = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  739|    122|  vectorAntialias = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  740|    122|  imageMaskAntialias = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  741|    122|  antialiasPrinting = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  742|    122|  strokeAdjust = strokeAdjustNormal;
  743|    122|  screenType = screenUnset;
  744|    122|  screenSize = -1;
  745|    122|  screenDotRadius = -1;
  746|    122|  screenGamma = 1.0;
  747|    122|  screenBlackThreshold = 0.0;
  748|    122|  screenWhiteThreshold = 1.0;
  749|    122|  minLineWidth = 0.0;
  750|    122|  enablePathSimplification = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  751|    122|  drawAnnotations = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  752|    122|  drawFormFields = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  753|    122|  enableXFA = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  754|    122|  overprintPreview = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  755|    122|  paperColor = new GString("#ffffff");
  756|    122|  matteColor = new GString("#808080");
  757|    122|  fullScreenMatteColor = new GString("#000000");
  758|    122|  selectionColor = new GString("#8080ff");
  759|    122|  reverseVideoInvertImages = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  760|    122|  allowLinksToChangeZoom = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  761|    122|  launchCommand = NULL;
  762|    122|  movieCommand = NULL;
  763|    122|  defaultPrinter = NULL;
  764|    122|  mapNumericCharNames = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  765|    122|  mapUnknownCharNames = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  766|    122|  mapExtTrueTypeFontsViaUnicode = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  767|    122|  useTrueTypeUnicodeMapping = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  768|    122|  ignoreWrongSizeToUnicode = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  769|    122|  droppedFonts = new GHash(gTrue);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  770|    122|  separateRotatedText = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  771|    122|  createDefaultKeyBindings();
  772|    122|  popupMenuCmds = new GList();
  773|    122|  initStateFilePaths();
  774|    122|  saveSessionOnQuit = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  775|    122|  savePageNumbers = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  776|    122|  printCommands = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  777|    122|  printStatusInfo = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  778|    122|  errQuiet = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  779|    122|  debugLogFile = NULL;
  780|       |
  781|    122|  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);
  ------------------
  |  |   71|    122|#define cidToUnicodeCacheSize     4
  ------------------
  782|    122|  unicodeToUnicodeCache =
  783|    122|      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);
  ------------------
  |  |   72|    122|#define unicodeToUnicodeCacheSize 4
  ------------------
  784|    122|  unicodeMapCache = new UnicodeMapCache();
  785|    122|  cMapCache = new CMapCache();
  786|       |
  787|       |  // set up the initial nameToUnicode table
  788|   517k|  for (i = 0; nameToUnicodeTab[i].name; ++i) {
  ------------------
  |  Branch (788:15): [True: 517k, False: 122]
  ------------------
  789|   517k|    nameToUnicode->add(nameToUnicodeTab[i].name, nameToUnicodeTab[i].u);
  790|   517k|  }
  791|       |
  792|       |  // set up the residentUnicodeMaps table
  793|    122|  map = new UnicodeMap("Latin1", gFalse,
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  794|    122|		       latin1UnicodeMapRanges, latin1UnicodeMapLen);
  ------------------
  |  |   71|    122|#define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  795|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  796|    122|  map = new UnicodeMap("ASCII7", gFalse,
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  797|    122|		       ascii7UnicodeMapRanges, ascii7UnicodeMapLen);
  ------------------
  |  |  207|    122|#define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  798|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  799|    122|  map = new UnicodeMap("Symbol", gFalse,
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  800|    122|		       symbolUnicodeMapRanges, symbolUnicodeMapLen);
  ------------------
  |  |  332|    122|#define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  801|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  802|    122|  map = new UnicodeMap("ZapfDingbats", gFalse, zapfDingbatsUnicodeMapRanges,
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  803|    122|		       zapfDingbatsUnicodeMapLen);
  ------------------
  |  |  366|    122|#define zapfDingbatsUnicodeMapLen (sizeof(zapfDingbatsUnicodeMapRanges) / sizeof(UnicodeMapRange))
  ------------------
  804|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  805|    122|  map = new UnicodeMap("UTF-8", gTrue, &mapUTF8);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  806|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  807|    122|  map = new UnicodeMap("UCS-2", gTrue, &mapUCS2);
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  808|    122|  residentUnicodeMaps->add(map->getEncodingName(), map);
  809|       |
  810|       |  // look for a user config file, then a system-wide config file
  811|    122|  f = NULL;
  812|    122|  fileName = NULL;
  813|    122|  if (cfgFileName && cfgFileName[0]) {
  ------------------
  |  Branch (813:7): [True: 0, False: 122]
  |  Branch (813:22): [True: 0, False: 0]
  ------------------
  814|      0|    fileName = new GString(cfgFileName);
  815|      0|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (815:9): [True: 0, False: 0]
  ------------------
  816|      0|      delete fileName;
  817|      0|    }
  818|      0|  }
  819|    122|  if (!f) {
  ------------------
  |  Branch (819:7): [True: 122, False: 0]
  ------------------
  820|    122|    fileName = appendToPath(getHomeDir(), xpdfUserConfigFile);
  ------------------
  |  |   58|    122|#define xpdfUserConfigFile ".xpdfrc"
  ------------------
  821|    122|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (821:9): [True: 122, False: 0]
  ------------------
  822|    122|      delete fileName;
  823|    122|    }
  824|    122|  }
  825|    122|  if (!f) {
  ------------------
  |  Branch (825:7): [True: 122, False: 0]
  ------------------
  826|       |#ifdef _WIN32
  827|       |    char buf[512];
  828|       |    i = GetModuleFileNameA(NULL, buf, sizeof(buf));
  829|       |    if (i <= 0 || i >= sizeof(buf)) {
  830|       |      // error or path too long for buffer - just use the current dir
  831|       |      buf[0] = '\0';
  832|       |    }
  833|       |    fileName = grabPath(buf);
  834|       |    appendToPath(fileName, xpdfSysConfigFile);
  835|       |#else
  836|    122|    fileName = new GString(xpdfSysConfigFile);
  ------------------
  |  |   69|    122|#define xpdfSysConfigFile "/etc/xpdfrc"
  ------------------
  837|    122|#endif
  838|    122|    if (!(f = fopen(fileName->getCString(), "r"))) {
  ------------------
  |  Branch (838:9): [True: 122, False: 0]
  ------------------
  839|    122|      delete fileName;
  840|    122|    }
  841|    122|  }
  842|    122|  if (f) {
  ------------------
  |  Branch (842:7): [True: 0, False: 122]
  ------------------
  843|      0|    parseFile(fileName, f);
  844|      0|    delete fileName;
  845|      0|    fclose(f);
  846|      0|  }
  847|    122|}
_ZN12GlobalParams13setDataDirVarEv:
  849|    122|void GlobalParams::setDataDirVar() {
  850|    122|  GString *dir;
  851|       |
  852|       |#if defined(XPDFRC_DATADIR)
  853|       |  dir = new GString(XPDFRC_DATADIR);
  854|       |#elif defined(_WIN32)
  855|       |  wchar_t buf[512];
  856|       |  DWORD n = GetModuleFileNameW(NULL, buf, sizeof(buf) / sizeof(wchar_t));
  857|       |  if (n <= 0 || n >= sizeof(buf)) {
  858|       |    // error or path too long for buffer - just use the current dir
  859|       |    buf[0] = L'\0';
  860|       |  }
  861|       |  GString *path = fileNameToUTF8(buf);
  862|       |  dir = grabPath(path->getCString());
  863|       |  delete path;
  864|       |  appendToPath(dir, "data");
  865|       |#else
  866|       |  //~ may be useful to allow the options of using the install dir
  867|       |  //~   and/or the user's home dir (?)
  868|    122|  dir = new GString("./data");
  869|    122|#endif
  870|       |
  871|    122|  configFileVars->add(new GString("DATADIR"), dir);
  872|    122|}
_ZN12GlobalParams24createDefaultKeyBindingsEv:
  874|    122|void GlobalParams::createDefaultKeyBindings() {
  875|    122|  keyBindings = new GList();
  876|       |
  877|       |  //----- mouse buttons
  878|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  147|    122|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  879|    122|				     xpdfKeyContextAny, "startSelection"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  880|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  147|    122|#define xpdfKeyCodeMousePress1        0x2001
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress1, xpdfKeyModShift,
  ------------------
  |  |  193|    122|#define xpdfKeyModShift           (1 << 0)
  ------------------
  881|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  882|    122|				     "startExtendedSelection"));
  883|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  156|    122|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  884|    122|				     xpdfKeyContextAny, "endSelection"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  885|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  156|    122|#define xpdfKeyCodeMouseRelease1      0x2101
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease1, xpdfKeyModShift,
  ------------------
  |  |  193|    122|#define xpdfKeyModShift           (1 << 0)
  ------------------
  886|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  887|    122|				     "endSelection"));
  888|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseDoubleClick1,
  ------------------
  |  |  174|    122|#define xpdfKeyCodeMouseDoubleClick1  0x2301
  ------------------
  889|    122|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  890|    122|				     "selectWord"));
  891|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseTripleClick1,
  ------------------
  |  |  183|    122|#define xpdfKeyCodeMouseTripleClick1  0x2401
  ------------------
  892|    122|				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
              				     xpdfKeyModNone, xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  893|    122|				     "selectLine"));
  894|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  165|    122|#define xpdfKeyCodeMouseClick1        0x2201
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick1, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  895|    122|				     xpdfKeyContextAny, "followLinkNoSel"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  896|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  166|    122|#define xpdfKeyCodeMouseClick2        0x2202
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseClick2, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  897|    122|				     xpdfKeyContextOverLink,
  ------------------
  |  |  201|    122|#define xpdfKeyContextOverLink    (1 << 4)
  ------------------
  898|    122|				     "followLinkInNewTab"));
  899|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  148|    122|#define xpdfKeyCodeMousePress2        0x2002
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress2, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  900|    122|				     xpdfKeyContextAny, "startPan"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  901|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  157|    122|#define xpdfKeyCodeMouseRelease2      0x2102
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMouseRelease2, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  902|    122|				     xpdfKeyContextAny, "endPan"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  903|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  149|    122|#define xpdfKeyCodeMousePress3        0x2003
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress3, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  904|    122|				     xpdfKeyContextAny, "postPopupMenu"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  905|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  150|    122|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  906|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  907|    122|				     "scrollUpPrevPage(16)"));
  908|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  151|    122|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  909|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  910|    122|				     "scrollDownNextPage(16)"));
  911|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  152|    122|#define xpdfKeyCodeMousePress6        0x2006
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress6, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  912|    122|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  913|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  153|    122|#define xpdfKeyCodeMousePress7        0x2007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress7, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  914|    122|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  915|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  150|    122|#define xpdfKeyCodeMousePress4        0x2004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress4, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  916|    122|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  917|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  151|    122|#define xpdfKeyCodeMousePress5        0x2005
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeMousePress5, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  918|    122|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  919|       |
  920|       |  //----- control keys
  921|    122|  keyBindings->append(new KeyBinding('o', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  922|    122|				     xpdfKeyContextAny, "open"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  923|    122|  keyBindings->append(new KeyBinding('r', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  924|    122|				     xpdfKeyContextAny, "reload"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  925|    122|  keyBindings->append(new KeyBinding('f', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  926|    122|				     xpdfKeyContextAny, "find"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  927|    122|  keyBindings->append(new KeyBinding('g', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  928|    122|				     xpdfKeyContextAny, "findNext"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  929|    122|  keyBindings->append(new KeyBinding('c', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  930|    122|				     xpdfKeyContextAny, "copy"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  931|    122|  keyBindings->append(new KeyBinding('p', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  932|    122|				     xpdfKeyContextAny, "print"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  933|    122|  keyBindings->append(new KeyBinding('0', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  934|    122|				     xpdfKeyContextAny, "zoomPercent(125)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  935|    122|  keyBindings->append(new KeyBinding('+', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  936|    122|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  937|    122|  keyBindings->append(new KeyBinding('=', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  938|    122|				     xpdfKeyContextAny, "zoomIn"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  939|    122|  keyBindings->append(new KeyBinding('-', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  940|    122|				     xpdfKeyContextAny, "zoomOut"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  941|    122|  keyBindings->append(new KeyBinding('s', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  942|    122|				     xpdfKeyContextAny, "saveAs"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  943|    122|  keyBindings->append(new KeyBinding('t', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  944|    122|				     xpdfKeyContextAny, "newTab"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  945|    122|  keyBindings->append(new KeyBinding('n', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  946|    122|				     xpdfKeyContextAny, "newWindow"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  947|    122|  keyBindings->append(new KeyBinding('w', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  948|    122|				     xpdfKeyContextAny, "closeTabOrQuit"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  949|    122|  keyBindings->append(new KeyBinding('l', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  950|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  951|    122|				     "toggleFullScreenMode"));
  952|    122|  keyBindings->append(new KeyBinding('q', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  953|    122|				     xpdfKeyContextAny, "quit"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  954|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  130|    122|#define xpdfKeyCodeTab                0x1000
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeTab, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  955|    122|				     xpdfKeyContextAny, "nextTab"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  956|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeTab,
  ------------------
  |  |  130|    122|#define xpdfKeyCodeTab                0x1000
  ------------------
  957|    122|				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  193|    122|#define xpdfKeyModShift           (1 << 0)
  ------------------
              				     xpdfKeyModShift | xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  958|    122|				     xpdfKeyContextAny, "prevTab"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  959|    122|  keyBindings->append(new KeyBinding('?', xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  960|    122|				     xpdfKeyContextAny, "help"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  961|       |
  962|       |  //----- alt keys
  963|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  141|    122|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModAlt,
  ------------------
  |  |  195|    122|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  964|    122|				     xpdfKeyContextAny, "goBackward"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  965|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  142|    122|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModAlt,
  ------------------
  |  |  195|    122|#define xpdfKeyModAlt             (1 << 2)
  ------------------
  966|    122|				     xpdfKeyContextAny, "goForward"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  967|       |
  968|       |  //----- home/end keys
  969|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  137|    122|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  970|    122|				     xpdfKeyContextAny, "gotoPage(1)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  971|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  137|    122|#define xpdfKeyCodeHome               0x1007
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeHome, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  972|    122|				     xpdfKeyContextAny, "scrollToTopLeft"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  973|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  138|    122|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  974|    122|				     xpdfKeyContextAny, "gotoLastPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  975|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  138|    122|#define xpdfKeyCodeEnd                0x1008
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEnd, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  976|    122|				     xpdfKeyContextAny,
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  977|    122|				     "scrollToBottomRight"));
  978|       |
  979|       |  //----- pgup/pgdn keys
  980|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  139|    122|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  981|    122|				     xpdfKeyContextAny, "pageUp"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  982|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  140|    122|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  983|    122|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  984|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    122|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  985|    122|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  986|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    122|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  987|    122|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
  988|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  139|    122|#define xpdfKeyCodePgUp               0x1009
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  989|    122|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    122|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  990|    122|				     "prevPageNoScroll"));
  991|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  140|    122|#define xpdfKeyCodePgDn               0x100a
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodePgDn, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
  992|    122|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    122|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
  993|    122|				     "nextPageNoScroll"));
  994|       |
  995|       |  //----- esc key
  996|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  134|    122|#define xpdfKeyCodeEsc                0x1004
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeEsc, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
  997|    122|				     xpdfKeyContextFullScreen,
  ------------------
  |  |  197|    122|#define xpdfKeyContextFullScreen  (1 << 0)
  ------------------
  998|    122|				     "windowMode"));
  999|       |
 1000|       |  //----- arrow keys
 1001|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  141|    122|#define xpdfKeyCodeLeft               0x100b
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeLeft, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1002|    122|				     xpdfKeyContextAny, "scrollLeft(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1003|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  142|    122|#define xpdfKeyCodeRight              0x100c
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeRight, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1004|    122|				     xpdfKeyContextAny, "scrollRight(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1005|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  143|    122|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1006|    122|				     xpdfKeyContextAny, "scrollUp(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1007|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  144|    122|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1008|    122|				     xpdfKeyContextAny, "scrollDown(16)"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1009|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    122|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1010|    122|				     xpdfKeyContextAny, "prevPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1011|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    122|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1012|    122|				     xpdfKeyContextAny, "nextPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1013|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  143|    122|#define xpdfKeyCodeUp                 0x100d
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeUp, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1014|    122|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    122|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1015|    122|				     "prevPageNoScroll"));
 1016|    122|  keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  144|    122|#define xpdfKeyCodeDown               0x100e
  ------------------
                keyBindings->append(new KeyBinding(xpdfKeyCodeDown, xpdfKeyModCtrl,
  ------------------
  |  |  194|    122|#define xpdfKeyModCtrl            (1 << 1)
  ------------------
 1017|    122|				     xpdfKeyContextScrLockOn,
  ------------------
  |  |  205|    122|#define xpdfKeyContextScrLockOn   (1 << 8)
  ------------------
 1018|    122|				     "nextPageNoScroll"));
 1019|       |
 1020|       |  //----- letter keys
 1021|    122|  keyBindings->append(new KeyBinding(' ', xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1022|    122|				     xpdfKeyContextAny, "pageDown"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1023|    122|  keyBindings->append(new KeyBinding('g', xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1024|    122|				     xpdfKeyContextAny, "focusToPageNum"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1025|    122|  keyBindings->append(new KeyBinding('z', xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1026|    122|				     xpdfKeyContextAny, "zoomFitPage"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1027|    122|  keyBindings->append(new KeyBinding('w', xpdfKeyModNone,
  ------------------
  |  |  192|    122|#define xpdfKeyModNone            0
  ------------------
 1028|    122|				     xpdfKeyContextAny, "zoomFitWidth"));
  ------------------
  |  |  196|    122|#define xpdfKeyContextAny         0
  ------------------
 1029|    122|}
_ZN12GlobalParams18initStateFilePathsEv:
 1031|    122|void GlobalParams::initStateFilePaths() {
 1032|       |#ifdef _WIN32
 1033|       |  char path[MAX_PATH];
 1034|       |  if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL,
 1035|       |		       SHGFP_TYPE_CURRENT, path) != S_OK) {
 1036|       |    return;
 1037|       |  }
 1038|       |  GString *dir = appendToPath(new GString(path), "xpdf");
 1039|       |  CreateDirectoryA(dir->getCString(), NULL);
 1040|       |  pagesFile = appendToPath(dir->copy(), "xpdf.pages");
 1041|       |  tabStateFile = appendToPath(dir->copy(), "xpdf.tab-state");
 1042|       |  sessionFile = appendToPath(dir, "xpdf.session");
 1043|       |#else
 1044|    122|  pagesFile = appendToPath(getHomeDir(), ".xpdf.pages");
 1045|    122|  tabStateFile = appendToPath(getHomeDir(), ".xpdf.tab-state");
 1046|    122|  sessionFile = appendToPath(getHomeDir(), ".xpdf.session");
 1047|    122|#endif
 1048|    122|}
_ZN12GlobalParams11parseYesNo2EPcPi:
 2092|    122|GBool GlobalParams::parseYesNo2(char *token, GBool *flag) {
 2093|    122|  if (!strcmp(token, "yes")) {
  ------------------
  |  Branch (2093:7): [True: 122, False: 0]
  ------------------
 2094|    122|    *flag = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
 2095|    122|  } else if (!strcmp(token, "no")) {
  ------------------
  |  Branch (2095:14): [True: 0, False: 0]
  ------------------
 2096|      0|    *flag = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2097|      0|  } else {
 2098|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
 2099|      0|  }
 2100|    122|  return gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
 2101|    122|}
_ZN12GlobalParamsD2Ev:
 2179|    122|GlobalParams::~GlobalParams() {
 2180|    122|  GHashIter *iter;
 2181|    122|  GString *key;
 2182|    122|  GList *list;
 2183|       |
 2184|    122|  freeBuiltinFontTables();
 2185|       |
 2186|    122|  delete macRomanReverseMap;
 2187|       |
 2188|    122|  delete baseDir;
 2189|    122|  deleteGHash(configFileVars, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    244|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 122, False: 122]
  |  |  ------------------
  |  |   68|    122|        delete (T*)_p;                             \
  |  |   69|    122|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2190|    122|  delete nameToUnicode;
 2191|    122|  deleteGHash(cidToUnicodes, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2192|    122|  deleteGHash(unicodeToUnicodes, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2193|    122|  deleteGHash(residentUnicodeMaps, UnicodeMap);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    854|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 732, False: 122]
  |  |  ------------------
  |  |   68|    732|        delete (T*)_p;                             \
  |  |   69|    732|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2194|    122|  deleteGHash(unicodeMaps, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2195|    122|  deleteGList(toUnicodeDirs, GString);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2196|    122|  delete unicodeRemapping;
 2197|    122|  deleteGHash(fontFiles, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2198|    122|  deleteGList(fontDirs, GString);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2199|    122|  deleteGHash(ccFontFiles, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2200|    122|  deleteGHash(base14SysFonts, Base14FontInfo);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2201|    122|  delete sysFonts;
 2202|    122|  deleteGHash(psResidentFonts, GString);
  ------------------
  |  |   60|    122|  do {                                             \
  |  |   61|    122|    GHash *_hash = (hash);                         \
  |  |   62|    122|    {                                              \
  |  |   63|    122|      GHashIter *_iter;                            \
  |  |   64|    122|      GString *_key;                               \
  |  |   65|    122|      void *_p;                                    \
  |  |   66|    122|      _hash->startIter(&_iter);                    \
  |  |   67|    122|      while (_hash->getNext(&_iter, &_key, &_p)) { \
  |  |  ------------------
  |  |  |  Branch (67:14): [True: 0, False: 122]
  |  |  ------------------
  |  |   68|      0|        delete (T*)_p;                             \
  |  |   69|      0|      }                                            \
  |  |   70|    122|      delete _hash;                                \
  |  |   71|    122|    }                                              \
  |  |   72|    122|  } while(0)
  |  |  ------------------
  |  |  |  Branch (72:11): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2203|    122|  deleteGList(psResidentFonts16, PSFontParam16);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2204|    122|  deleteGList(psResidentFontsCC, PSFontParam16);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2205|    122|  delete textEncoding;
 2206|    122|  delete initialZoom;
 2207|    122|  deleteGList(zoomValues, GString);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|  1.70k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 1.58k, False: 122]
  |  |  ------------------
  |  |   99|  1.58k|        delete (T*)_list->get(_i);                  \
  |  |  100|  1.58k|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2208|    122|  delete initialDisplayMode;
 2209|    122|  delete initialSelectMode;
 2210|    122|  if (paperColor) {
  ------------------
  |  Branch (2210:7): [True: 122, False: 0]
  ------------------
 2211|    122|    delete paperColor;
 2212|    122|  }
 2213|    122|  if (matteColor) {
  ------------------
  |  Branch (2213:7): [True: 122, False: 0]
  ------------------
 2214|    122|    delete matteColor;
 2215|    122|  }
 2216|    122|  if (fullScreenMatteColor) {
  ------------------
  |  Branch (2216:7): [True: 122, False: 0]
  ------------------
 2217|    122|    delete fullScreenMatteColor;
 2218|    122|  }
 2219|    122|  if (selectionColor) {
  ------------------
  |  Branch (2219:7): [True: 122, False: 0]
  ------------------
 2220|    122|    delete selectionColor;
 2221|    122|  }
 2222|    122|  if (launchCommand) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 122]
  ------------------
 2223|      0|    delete launchCommand;
 2224|      0|  }
 2225|    122|  if (movieCommand) {
  ------------------
  |  Branch (2225:7): [True: 0, False: 122]
  ------------------
 2226|      0|    delete movieCommand;
 2227|      0|  }
 2228|    122|  if (defaultPrinter) {
  ------------------
  |  Branch (2228:7): [True: 0, False: 122]
  ------------------
 2229|      0|    delete defaultPrinter;
 2230|      0|  }
 2231|    122|  delete droppedFonts;
 2232|    122|  deleteGList(keyBindings, KeyBinding);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|  7.56k|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 7.44k, False: 122]
  |  |  ------------------
  |  |   99|  7.44k|        delete (T*)_list->get(_i);                  \
  |  |  100|  7.44k|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2233|    122|  deleteGList(popupMenuCmds, PopupMenuCmd);
  ------------------
  |  |   94|    122|  do {                                              \
  |  |   95|    122|    GList *_list = (list);                          \
  |  |   96|    122|    {                                               \
  |  |   97|    122|      int _i;                                       \
  |  |   98|    122|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 122]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|    122|      delete _list;                                 \
  |  |  102|    122|    }                                               \
  |  |  103|    122|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2234|    122|  delete pagesFile;
 2235|    122|  delete tabStateFile;
 2236|    122|  delete sessionFile;
 2237|    122|  delete debugLogFile;
 2238|       |
 2239|    122|  cMapDirs->startIter(&iter);
 2240|    122|  while (cMapDirs->getNext(&iter, &key, (void **)&list)) {
  ------------------
  |  Branch (2240:10): [True: 0, False: 122]
  ------------------
 2241|      0|    deleteGList(list, GString);
  ------------------
  |  |   94|      0|  do {                                              \
  |  |   95|      0|    GList *_list = (list);                          \
  |  |   96|      0|    {                                               \
  |  |   97|      0|      int _i;                                       \
  |  |   98|      0|      for (_i = 0; _i < _list->getLength(); ++_i) { \
  |  |  ------------------
  |  |  |  Branch (98:20): [True: 0, False: 0]
  |  |  ------------------
  |  |   99|      0|        delete (T*)_list->get(_i);                  \
  |  |  100|      0|      }                                             \
  |  |  101|      0|      delete _list;                                 \
  |  |  102|      0|    }                                               \
  |  |  103|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (103:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2242|      0|  }
 2243|    122|  delete cMapDirs;
 2244|       |
 2245|    122|  delete cidToUnicodeCache;
 2246|    122|  delete unicodeToUnicodeCache;
 2247|    122|  delete unicodeMapCache;
 2248|    122|  delete cMapCache;
 2249|       |
 2250|    122|#if MULTITHREADED
 2251|    122|  gDestroyMutex(&mutex);
  ------------------
  |  |   52|    122|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2252|    122|  gDestroyMutex(&unicodeMapCacheMutex);
  ------------------
  |  |   52|    122|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2253|    122|  gDestroyMutex(&cMapCacheMutex);
  ------------------
  |  |   52|    122|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
 2254|    122|#endif
 2255|    122|}
_ZN12GlobalParams14setupBaseFontsEPKc:
 2347|    122|void GlobalParams::setupBaseFonts(const char *dir) {
 2348|    122|  GString *fontName;
 2349|    122|  GString *fileName;
 2350|    122|  int fontNum;
 2351|    122|  const char *s;
 2352|    122|  Base14FontInfo *base14;
 2353|       |#ifdef _WIN32
 2354|       |  char winFontDir[MAX_PATH];
 2355|       |#endif
 2356|       |#ifdef __APPLE__
 2357|       |  static const char *macFontExts[3] = { "dfont", "ttc", "ttf" };
 2358|       |  GList *dfontFontNames;
 2359|       |  GBool found;
 2360|       |  int k;
 2361|       |#endif
 2362|    122|  FILE *f;
 2363|    122|  int i, j;
 2364|       |
 2365|       |#ifdef _WIN32
 2366|       |  getWinFontDir(winFontDir);
 2367|       |#endif
 2368|       |#ifdef __APPLE__
 2369|       |  dfontFontNames = NULL;
 2370|       |#endif
 2371|  1.83k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2371:15): [True: 1.70k, False: 122]
  ------------------
 2372|  1.70k|    if (fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 1.70k]
  ------------------
 2373|      0|      continue;
 2374|      0|    }
 2375|  1.70k|    fontName = new GString(displayFontTab[i].name);
 2376|  1.70k|    fileName = NULL;
 2377|  1.70k|    fontNum = 0;
 2378|  1.70k|    if (dir) {
  ------------------
  |  Branch (2378:9): [True: 0, False: 1.70k]
  ------------------
 2379|      0|      fileName = appendToPath(new GString(dir), displayFontTab[i].t1FileName);
 2380|      0|      if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2380:11): [True: 0, False: 0]
  ------------------
 2381|      0|	fclose(f);
 2382|      0|      } else {
 2383|      0|	delete fileName;
 2384|      0|	fileName = NULL;
 2385|      0|      }
 2386|      0|    }
 2387|       |#ifdef _WIN32
 2388|       |    if (!fileName && winFontDir[0] && displayFontTab[i].ttFileName) {
 2389|       |      fileName = appendToPath(new GString(winFontDir),
 2390|       |			      displayFontTab[i].ttFileName);
 2391|       |      if ((f = fopen(fileName->getCString(), "rb"))) {
 2392|       |	fclose(f);
 2393|       |      } else {
 2394|       |	delete fileName;
 2395|       |	fileName = NULL;
 2396|       |      }
 2397|       |    }
 2398|       |#endif
 2399|       |#ifdef __APPLE__
 2400|       |    // Check for Mac OS X system fonts.
 2401|       |    s = displayFontTab[i].macFileName;
 2402|       |    if (dfontFontNames && i > 0 &&
 2403|       |	(!s || strcmp(s, displayFontTab[i-1].macFileName))) {
 2404|       |      deleteGList(dfontFontNames, GString);
 2405|       |      dfontFontNames = NULL;
 2406|       |    }
 2407|       |    if (!fileName && s) {
 2408|       |      for (j = 0; j < 3; ++j) {
 2409|       |	fileName = GString::format("{0:s}/{1:s}.{2:s}",
 2410|       |				   macSystemFontPath, s, macFontExts[j]);
 2411|       |	if (!(f = fopen(fileName->getCString(), "rb"))) {
 2412|       |	  delete fileName;
 2413|       |	  fileName = NULL;
 2414|       |	} else {
 2415|       |	  fclose(f);
 2416|       |	  found = gFalse;
 2417|       |	  // for .dfont or .ttc, we need to scan the font list
 2418|       |	  if (j < 2) {
 2419|       |	    if (!dfontFontNames) {
 2420|       |	      dfontFontNames =
 2421|       |	          FoFiIdentifier::getFontList(fileName->getCString());
 2422|       |	    }
 2423|       |	    if (dfontFontNames) {
 2424|       |	      for (k = 0; k < dfontFontNames->getLength(); ++k) {
 2425|       |		if (macFontNameMatches((GString *)dfontFontNames->get(k),
 2426|       |				       displayFontTab[i].macFontName)) {
 2427|       |		  fontNum = k;
 2428|       |		  found = gTrue;
 2429|       |		  break;
 2430|       |		}
 2431|       |	      }
 2432|       |	    }
 2433|       |	  // for .ttf, we just use the font
 2434|       |	  } else {
 2435|       |	    found = gTrue;
 2436|       |	  }
 2437|       |	  if (!found) {
 2438|       |	    delete fileName;
 2439|       |	    fileName = NULL;
 2440|       |	  }
 2441|       |	  break;
 2442|       |	}
 2443|       |      }
 2444|       |    }
 2445|       |#endif // __APPLE__
 2446|       |    // On Linux, this checks the "standard" ghostscript font
 2447|       |    // directories.  On Windows, it checks the "standard" system font
 2448|       |    // directories (because SHGetSpecialFolderPath(CSIDL_FONTS)
 2449|       |    // doesn't work on Win 2k Server or Win2003 Server, or with older
 2450|       |    // versions of shell32.dll).
 2451|       |#ifdef _WIN32
 2452|       |    s = displayFontTab[i].ttFileName;
 2453|       |#else
 2454|  1.70k|    s = displayFontTab[i].t1FileName;
 2455|  1.70k|#endif
 2456|  1.70k|    if (!fileName && s) {
  ------------------
  |  Branch (2456:9): [True: 1.70k, False: 0]
  |  Branch (2456:22): [True: 1.70k, False: 0]
  ------------------
 2457|  10.2k|      for (j = 0; !fileName && displayFontDirs[j]; ++j) {
  ------------------
  |  Branch (2457:19): [True: 10.2k, False: 0]
  |  Branch (2457:32): [True: 8.54k, False: 1.70k]
  ------------------
 2458|  8.54k|	fileName = appendToPath(new GString(displayFontDirs[j]), s);
 2459|  8.54k|	if ((f = fopen(fileName->getCString(), "rb"))) {
  ------------------
  |  Branch (2459:6): [True: 0, False: 8.54k]
  ------------------
 2460|      0|	  fclose(f);
 2461|  8.54k|	} else {
 2462|  8.54k|	  delete fileName;
 2463|  8.54k|	  fileName = NULL;
 2464|  8.54k|	}
 2465|  8.54k|      }
 2466|  1.70k|    }
 2467|  1.70k|    if (!fileName) {
  ------------------
  |  Branch (2467:9): [True: 1.70k, False: 0]
  ------------------
 2468|  1.70k|      delete fontName;
 2469|  1.70k|      continue;
 2470|  1.70k|    }
 2471|      0|    base14SysFonts->add(fontName, new Base14FontInfo(fileName, fontNum, 0));
 2472|      0|  }
 2473|       |#ifdef __APPLE__
 2474|       |  if (dfontFontNames) {
 2475|       |    deleteGList(dfontFontNames, GString);
 2476|       |  }
 2477|       |#endif
 2478|  1.83k|  for (i = 0; displayFontTab[i].name; ++i) {
  ------------------
  |  Branch (2478:15): [True: 1.70k, False: 122]
  ------------------
 2479|  1.70k|    if (!base14SysFonts->lookup(displayFontTab[i].name) &&
  ------------------
  |  Branch (2479:9): [True: 1.70k, False: 0]
  ------------------
 2480|  1.70k|	!fontFiles->lookup(displayFontTab[i].name)) {
  ------------------
  |  Branch (2480:2): [True: 1.70k, False: 0]
  ------------------
 2481|  1.70k|      if (displayFontTab[i].obliqueFont &&
  ------------------
  |  Branch (2481:11): [True: 488, False: 1.22k]
  ------------------
 2482|  1.70k|	  ((base14 = (Base14FontInfo *)base14SysFonts
  ------------------
  |  Branch (2482:4): [True: 0, False: 488]
  ------------------
 2483|    488|	                 ->lookup(displayFontTab[i].obliqueFont)))) {
 2484|      0|	base14SysFonts->add(
 2485|      0|	        new GString(displayFontTab[i].name),
 2486|      0|		new Base14FontInfo(base14->fileName->copy(),
 2487|      0|				   base14->fontNum,
 2488|      0|				   displayFontTab[i].obliqueFactor));
 2489|  1.70k|      } else {
 2490|  1.70k|	error(errConfig, -1, "No display font for '{0:s}'",
 2491|  1.70k|	      displayFontTab[i].name);
 2492|  1.70k|      }
 2493|  1.70k|    }
 2494|  1.70k|  }
 2495|       |#ifdef _WIN32
 2496|       |  if (winFontDir[0]) {
 2497|       |    sysFonts->scanWindowsFonts(winFontDir);
 2498|       |  }
 2499|       |#endif
 2500|       |#if HAVE_FONTCONFIG
 2501|       |  sysFonts->scanFontconfigFonts();
 2502|       |#endif
 2503|    122|}
_ZN12GlobalParams17setEnableFreeTypeEPc:
 3888|    122|GBool GlobalParams::setEnableFreeType(char *s) {
 3889|    122|  GBool ok;
 3890|       |
 3891|    122|  lockGlobalParams;
  ------------------
  |  |   50|    122|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    122|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 3892|    122|  ok = parseYesNo2(s, &enableFreeType);
 3893|    122|  unlockGlobalParams;
  ------------------
  |  |   53|    122|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    122|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 3894|    122|  return ok;
 3895|    122|}
_ZN12GlobalParams11setErrQuietEi:
 4010|    244|void GlobalParams::setErrQuiet(GBool errQuietA) {
 4011|    244|  lockGlobalParams;
  ------------------
  |  |   50|    244|#  define lockGlobalParams            gLockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   53|    244|#define gLockMutex(m) pthread_mutex_lock(m)
  |  |  ------------------
  ------------------
 4012|    244|  errQuiet = errQuietA;
 4013|    244|  unlockGlobalParams;
  ------------------
  |  |   53|    244|#  define unlockGlobalParams          gUnlockMutex(&mutex)
  |  |  ------------------
  |  |  |  |   54|    244|#define gUnlockMutex(m) pthread_mutex_unlock(m)
  |  |  ------------------
  ------------------
 4014|    244|}

_ZN5Lexer7isSpaceEi:
  552|  17.6k|GBool Lexer::isSpace(int c) {
  553|  17.6k|  return c >= 0 && c <= 0xff && specialChars[c] == 1;
  ------------------
  |  Branch (553:10): [True: 17.6k, False: 0]
  |  Branch (553:20): [True: 17.6k, False: 0]
  |  Branch (553:33): [True: 5.25k, False: 12.4k]
  ------------------
  554|  17.6k|}

_ZN14NameToCharCodeC2Ev:
   25|    244|NameToCharCode::NameToCharCode() {
   26|    244|  int i;
   27|       |
   28|    244|  size = 31;
   29|    244|  len = 0;
   30|    244|  tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   31|  7.80k|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (31:15): [True: 7.56k, False: 244]
  ------------------
   32|  7.56k|    tab[i].name = NULL;
   33|  7.56k|  }
   34|    244|}
_ZN14NameToCharCodeD2Ev:
   36|    244|NameToCharCode::~NameToCharCode() {
   37|    244|  int i;
   38|       |
   39|  2.06M|  for (i = 0; i < size; ++i) {
  ------------------
  |  Branch (39:15): [True: 2.06M, False: 244]
  ------------------
   40|  2.06M|    if (tab[i].name) {
  ------------------
  |  Branch (40:9): [True: 544k, False: 1.51M]
  ------------------
   41|   544k|      gfree(tab[i].name);
   42|   544k|    }
   43|  2.06M|  }
   44|    244|  gfree(tab);
   45|    244|}
_ZN14NameToCharCode3addEPKcj:
   47|   544k|void NameToCharCode::add(const char *name, CharCode c) {
   48|   544k|  NameToCharCodeEntry *oldTab;
   49|   544k|  int h, i, oldSize;
   50|       |
   51|       |  // expand the table if necessary
   52|   544k|  if (len >= size / 2) {
  ------------------
  |  Branch (52:7): [True: 1.58k, False: 543k]
  ------------------
   53|  1.58k|    oldSize = size;
   54|  1.58k|    oldTab = tab;
   55|  1.58k|    size = 2*size + 1;
   56|  1.58k|    tab = (NameToCharCodeEntry *)gmallocn(size, sizeof(NameToCharCodeEntry));
   57|  4.10M|    for (h = 0; h < size; ++h) {
  ------------------
  |  Branch (57:17): [True: 4.10M, False: 1.58k]
  ------------------
   58|  4.10M|      tab[h].name = NULL;
   59|  4.10M|    }
   60|  2.05M|    for (i = 0; i < oldSize; ++i) {
  ------------------
  |  Branch (60:17): [True: 2.05M, False: 1.58k]
  ------------------
   61|  2.05M|      if (oldTab[i].name) {
  ------------------
  |  Branch (61:11): [True: 1.02M, False: 1.02M]
  ------------------
   62|  1.02M|	h = hash(oldTab[i].name);
   63|  1.49M|	while (tab[h].name) {
  ------------------
  |  Branch (63:9): [True: 472k, False: 1.02M]
  ------------------
   64|   472k|	  if (++h == size) {
  ------------------
  |  Branch (64:8): [True: 0, False: 472k]
  ------------------
   65|      0|	    h = 0;
   66|      0|	  }
   67|   472k|	}
   68|  1.02M|	tab[h] = oldTab[i];
   69|  1.02M|      }
   70|  2.05M|    }
   71|  1.58k|    gfree(oldTab);
   72|  1.58k|  }
   73|       |
   74|       |  // add the new name
   75|   544k|  h = hash(name);
   76|  2.26M|  while (tab[h].name && strcmp(tab[h].name, name)) {
  ------------------
  |  Branch (76:10): [True: 1.71M, False: 544k]
  |  Branch (76:25): [True: 1.71M, False: 122]
  ------------------
   77|  1.71M|    if (++h == size) {
  ------------------
  |  Branch (77:9): [True: 366, False: 1.71M]
  ------------------
   78|    366|      h = 0;
   79|    366|    }
   80|  1.71M|  }
   81|   544k|  if (!tab[h].name) {
  ------------------
  |  Branch (81:7): [True: 544k, False: 122]
  ------------------
   82|   544k|    tab[h].name = copyString(name);
   83|   544k|  }
   84|   544k|  tab[h].c = c;
   85|       |
   86|   544k|  ++len;
   87|   544k|}
_ZN14NameToCharCode4hashEPKc:
  104|  1.57M|int NameToCharCode::hash(const char *name) {
  105|  1.57M|  const char *p;
  106|  1.57M|  unsigned int h;
  107|       |
  108|  1.57M|  h = 0;
  109|  18.4M|  for (p = name; *p; ++p) {
  ------------------
  |  Branch (109:18): [True: 16.8M, False: 1.57M]
  ------------------
  110|  16.8M|    h = 17 * h + (int)(*p & 0xff);
  111|  16.8M|  }
  112|  1.57M|  return (int)(h % size);
  113|  1.57M|}

_ZN6Object4freeEv:
  115|    366|void Object::free() {
  116|    366|  switch (type) {
  117|      0|  case objString:
  ------------------
  |  Branch (117:3): [True: 0, False: 366]
  ------------------
  118|      0|    delete string;
  119|      0|    break;
  120|      0|  case objName:
  ------------------
  |  Branch (120:3): [True: 0, False: 366]
  ------------------
  121|      0|    gfree(name);
  122|      0|    break;
  123|      0|  case objArray:
  ------------------
  |  Branch (123:3): [True: 0, False: 366]
  ------------------
  124|      0|    if (!array->decRef()) {
  ------------------
  |  Branch (124:9): [True: 0, False: 0]
  ------------------
  125|      0|      delete array;
  126|      0|    }
  127|      0|    break;
  128|      0|  case objDict:
  ------------------
  |  Branch (128:3): [True: 0, False: 366]
  ------------------
  129|      0|    if (!dict->decRef()) {
  ------------------
  |  Branch (129:9): [True: 0, False: 0]
  ------------------
  130|      0|      delete dict;
  131|      0|    }
  132|      0|    break;
  133|      0|  case objStream:
  ------------------
  |  Branch (133:3): [True: 0, False: 366]
  ------------------
  134|      0|    delete stream;
  135|      0|    break;
  136|      0|  case objCmd:
  ------------------
  |  Branch (136:3): [True: 0, False: 366]
  ------------------
  137|      0|    gfree(cmd);
  138|      0|    break;
  139|    366|  default:
  ------------------
  |  Branch (139:3): [True: 366, False: 0]
  ------------------
  140|    366|    break;
  141|    366|  }
  142|       |#ifdef DEBUG_OBJECT_MEM
  143|       |#if MULTITHREADED
  144|       |  gAtomicDecrement(&numAlloc[type]);
  145|       |#else
  146|       |  --numAlloc[type];
  147|       |#endif
  148|       |#endif
  149|    366|  type = objNone;
  150|    366|}

_ZN6ObjectC2Ev:
   85|  4.88k|    type(objNone) {}
_ZN6Object8initNullEv:
   99|    122|    { initObj(objNull); return this; }
  ------------------
  |  |   77|    122|#define initObj(t) type = t
  ------------------

_ZN6PDFDocC2EP10BaseStreamP7GStringS3_P7PDFCore:
  219|    122|	       GString *userPassword, PDFCore *coreA) {
  220|       |#ifdef _WIN32
  221|       |  int n, i;
  222|       |#endif
  223|       |
  224|    122|  init(coreA);
  225|       |
  226|    122|  if (strA->getFileName()) {
  ------------------
  |  Branch (226:7): [True: 0, False: 122]
  ------------------
  227|      0|    fileName = strA->getFileName()->copy();
  228|       |#ifdef _WIN32
  229|       |    n = fileName->getLength();
  230|       |    fileNameU = (wchar_t *)gmallocn(n + 1, sizeof(wchar_t));
  231|       |    for (i = 0; i < n; ++i) {
  232|       |      fileNameU[i] = (wchar_t)(fileName->getChar(i) & 0xff);
  233|       |    }
  234|       |    fileNameU[n] = L'\0';
  235|       |#endif
  236|    122|  } else {
  237|    122|    fileName = NULL;
  238|       |#ifdef _WIN32
  239|       |    fileNameU = NULL;
  240|       |#endif
  241|    122|  }
  242|    122|  str = strA;
  243|    122|  ok = setup(ownerPassword, userPassword);
  244|    122|}
_ZN6PDFDoc4initEP7PDFCore:
  246|    122|void PDFDoc::init(PDFCore *coreA) {
  247|    122|  ok = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  248|    122|  errCode = errNone;
  ------------------
  |  |   12|    122|#define errNone             0	// no error
  ------------------
  249|    122|  core = coreA;
  250|    122|  file = NULL;
  251|    122|  str = NULL;
  252|    122|  xref = NULL;
  253|    122|  catalog = NULL;
  254|    122|  annots = NULL;
  255|    122|#ifndef DISABLE_OUTLINE
  256|    122|  outline = NULL;
  257|    122|#endif
  258|    122|  optContent = NULL;
  259|    122|}
_ZN6PDFDoc5setupEP7GStringS1_:
  261|    122|GBool PDFDoc::setup(GString *ownerPassword, GString *userPassword) {
  262|       |
  263|    122|  str->reset();
  264|       |
  265|       |  // check header
  266|    122|  checkHeader();
  267|       |
  268|       |  // read the xref and catalog
  269|    122|  if (!PDFDoc::setup2(ownerPassword, userPassword, gFalse)) {
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  |  Branch (269:7): [True: 122, False: 0]
  ------------------
  270|    122|    if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   18|    244|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
                  if (errCode == errDamaged || errCode == errBadCatalog) {
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  |  Branch (270:9): [True: 122, False: 0]
  |  Branch (270:34): [True: 0, False: 0]
  ------------------
  271|       |      // try repairing the xref table
  272|    122|      error(errSyntaxWarning, -1,
  273|    122|	    "PDF file is damaged - attempting to reconstruct xref table...");
  274|    122|      if (!PDFDoc::setup2(ownerPassword, userPassword, gTrue)) {
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  |  Branch (274:11): [True: 122, False: 0]
  ------------------
  275|    122|	return gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  276|    122|      }
  277|    122|    } else {
  278|      0|      return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  279|      0|    }
  280|    122|  }
  281|       |
  282|      0|#ifndef DISABLE_OUTLINE
  283|       |  // read outline
  284|      0|  outline = new Outline(catalog->getOutline(), xref);
  285|      0|#endif
  286|       |
  287|       |  // read the optional content info
  288|      0|  optContent = new OptionalContent(this);
  289|       |
  290|       |
  291|       |  // done
  292|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  293|    122|}
_ZN6PDFDoc6setup2EP7GStringS1_i:
  296|    244|		     GBool repairXRef) {
  297|       |  // read xref table
  298|    244|  xref = new XRef(str, repairXRef);
  299|    244|  if (!xref->isOk()) {
  ------------------
  |  Branch (299:7): [True: 244, False: 0]
  ------------------
  300|    244|    error(errSyntaxError, -1, "Couldn't read xref table");
  301|    244|    errCode = xref->getErrorCode();
  302|    244|    delete xref;
  303|    244|    xref = NULL;
  304|    244|    return gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  305|    244|  }
  306|       |
  307|       |  // check for encryption
  308|      0|  if (!checkEncryption(ownerPassword, userPassword)) {
  ------------------
  |  Branch (308:7): [True: 0, False: 0]
  ------------------
  309|      0|    errCode = errEncrypted;
  ------------------
  |  |   21|      0|#define errEncrypted        4	// file was encrypted and password was
  ------------------
  310|      0|    delete xref;
  311|      0|    xref = NULL;
  312|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  313|      0|  }
  314|       |
  315|       |  // read catalog
  316|      0|  catalog = new Catalog(this);
  317|      0|  if (!catalog->isOk()) {
  ------------------
  |  Branch (317:7): [True: 0, False: 0]
  ------------------
  318|      0|    error(errSyntaxError, -1, "Couldn't read page catalog");
  319|      0|    errCode = errBadCatalog;
  ------------------
  |  |   16|      0|#define errBadCatalog       2	// couldn't read the page catalog
  ------------------
  320|      0|    delete catalog;
  321|      0|    catalog = NULL;
  322|      0|    delete xref;
  323|      0|    xref = NULL;
  324|      0|    return gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  325|      0|  }
  326|       |
  327|       |  // initialize the Annots object
  328|      0|  annots = new Annots(this);
  329|       |
  330|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  331|      0|}
_ZN6PDFDocD2Ev:
  333|    122|PDFDoc::~PDFDoc() {
  334|    122|  if (optContent) {
  ------------------
  |  Branch (334:7): [True: 0, False: 122]
  ------------------
  335|      0|    delete optContent;
  336|      0|  }
  337|    122|#ifndef DISABLE_OUTLINE
  338|    122|  if (outline) {
  ------------------
  |  Branch (338:7): [True: 0, False: 122]
  ------------------
  339|      0|    delete outline;
  340|      0|  }
  341|    122|#endif
  342|    122|  if (annots) {
  ------------------
  |  Branch (342:7): [True: 0, False: 122]
  ------------------
  343|      0|    delete annots;
  344|      0|  }
  345|    122|  if (catalog) {
  ------------------
  |  Branch (345:7): [True: 0, False: 122]
  ------------------
  346|      0|    delete catalog;
  347|      0|  }
  348|    122|  if (xref) {
  ------------------
  |  Branch (348:7): [True: 0, False: 122]
  ------------------
  349|      0|    delete xref;
  350|      0|  }
  351|    122|  if (str) {
  ------------------
  |  Branch (351:7): [True: 122, False: 0]
  ------------------
  352|    122|    delete str;
  353|    122|  }
  354|    122|  if (file) {
  ------------------
  |  Branch (354:7): [True: 0, False: 122]
  ------------------
  355|      0|    fclose(file);
  356|      0|  }
  357|    122|  if (fileName) {
  ------------------
  |  Branch (357:7): [True: 0, False: 122]
  ------------------
  358|      0|    delete fileName;
  359|      0|  }
  360|       |#ifdef _WIN32
  361|       |  if (fileNameU) {
  362|       |    gfree(fileNameU);
  363|       |  }
  364|       |#endif
  365|    122|}
_ZN6PDFDoc11checkHeaderEv:
  369|    122|void PDFDoc::checkHeader() {
  370|    122|  char hdrBuf[headerSearchSize+1];
  371|    122|  char *p;
  372|    122|  int i;
  373|       |
  374|    122|  pdfVersion = 0;
  375|    122|  memset(hdrBuf, 0, headerSearchSize + 1);
  ------------------
  |  |   44|    122|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  376|    122|  str->getBlock(hdrBuf, headerSearchSize);
  ------------------
  |  |   44|    122|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  377|  86.4k|  for (i = 0; i < headerSearchSize - 5; ++i) {
  ------------------
  |  |   44|  86.4k|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (377:15): [True: 86.3k, False: 82]
  ------------------
  378|  86.3k|    if (!strncmp(&hdrBuf[i], "%PDF-", 5)) {
  ------------------
  |  Branch (378:9): [True: 40, False: 86.3k]
  ------------------
  379|     40|      break;
  380|     40|    }
  381|  86.3k|  }
  382|    122|  if (i >= headerSearchSize - 5) {
  ------------------
  |  |   44|    122|#define headerSearchSize 1024	// read this many bytes at beginning of
  ------------------
  |  Branch (382:7): [True: 82, False: 40]
  ------------------
  383|     82|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  384|     82|    return;
  385|     82|  }
  386|     40|  str->moveStart(i);
  387|     40|  if (!(p = strtok(&hdrBuf[i+5], " \t\n\r"))) {
  ------------------
  |  Branch (387:7): [True: 1, False: 39]
  ------------------
  388|      1|    error(errSyntaxWarning, -1, "May not be a PDF file (continuing anyway)");
  389|      1|    return;
  390|      1|  }
  391|     39|  pdfVersion = atof(p);
  392|     39|  if (!(hdrBuf[i+5] >= '0' && hdrBuf[i+5] <= '9') ||
  ------------------
  |  Branch (392:9): [True: 4, False: 35]
  |  Branch (392:31): [True: 0, False: 4]
  ------------------
  393|     39|      pdfVersion > supportedPDFVersionNum + 0.0001) {
  ------------------
  |  |   28|      0|#define supportedPDFVersionNum 2.0
  ------------------
  |  Branch (393:7): [True: 0, False: 0]
  ------------------
  394|     39|    error(errSyntaxWarning, -1,
  395|     39|	  "PDF version {0:s} -- xpdf supports version {1:s} (continuing anyway)",
  396|     39|	  p, supportedPDFVersionStr);
  ------------------
  |  |   27|     39|#define supportedPDFVersionStr "2.0"
  ------------------
  397|     39|  }
  398|     39|}

_ZN6PDFDoc4isOkEv:
   57|    122|  GBool isOk() { return ok; }

_ZN6StreamC2Ev:
   62|    122|Stream::Stream() {
   63|    122|}
_ZN6StreamD2Ev:
   65|    122|Stream::~Stream() {
   66|    122|}
_ZN10BaseStreamC2EP6Object:
  325|    122|BaseStream::BaseStream(Object *dictA) {
  326|    122|  dict = *dictA;
  327|    122|}
_ZN10BaseStreamD2Ev:
  329|    122|BaseStream::~BaseStream() {
  330|    122|  dict.free();
  331|    122|}
_ZN9MemStreamC2EPcjjP6Object:
  873|    122|    BaseStream(dictA) {
  874|    122|  buf = bufA;
  875|    122|  start = startA;
  876|    122|  length = lengthA;
  877|    122|  bufEnd = buf + start + length;
  878|    122|  bufPtr = buf + start;
  879|    122|  needFree = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  880|    122|}
_ZN9MemStreamD2Ev:
  882|    122|MemStream::~MemStream() {
  883|    122|  if (needFree) {
  ------------------
  |  Branch (883:7): [True: 0, False: 122]
  ------------------
  884|      0|    gfree(buf);
  885|      0|  }
  886|    122|}
_ZN9MemStream5resetEv:
  916|    244|void MemStream::reset() {
  917|    244|  bufPtr = buf + start;
  918|    244|}
_ZN9MemStream8getBlockEPci:
  923|    366|int MemStream::getBlock(char *blk, int size) {
  924|    366|  int n;
  925|       |
  926|    366|  if (size <= 0) {
  ------------------
  |  Branch (926:7): [True: 0, False: 366]
  ------------------
  927|      0|    return 0;
  928|      0|  }
  929|    366|  if (bufEnd - bufPtr < size) {
  ------------------
  |  Branch (929:7): [True: 365, False: 1]
  ------------------
  930|    365|    n = (int)(bufEnd - bufPtr);
  931|    365|  } else {
  932|      1|    n = size;
  933|      1|  }
  934|    366|  memcpy(blk, bufPtr, n);
  935|    366|  bufPtr += n;
  936|    366|  return n;
  937|    366|}
_ZN9MemStream6setPosEli:
  939|    122|void MemStream::setPos(GFileOffset pos, int dir) {
  940|    122|  Guint i;
  941|       |
  942|    122|  if (dir >= 0) {
  ------------------
  |  Branch (942:7): [True: 0, False: 122]
  ------------------
  943|      0|    i = (Guint)pos;
  944|    122|  } else {
  945|    122|    if (pos > start + length) {
  ------------------
  |  Branch (945:9): [True: 121, False: 1]
  ------------------
  946|    121|      i = 0;
  947|    121|    } else {
  948|      1|      i = (Guint)(start + length - pos);
  949|      1|    }
  950|    122|  }
  951|    122|  if (i < start) {
  ------------------
  |  Branch (951:7): [True: 40, False: 82]
  ------------------
  952|     40|    i = start;
  953|     82|  } else if (i > start + length) {
  ------------------
  |  Branch (953:14): [True: 0, False: 82]
  ------------------
  954|      0|    i = start + length;
  955|      0|  }
  956|    122|  bufPtr = buf + i;
  957|    122|}
_ZN9MemStream9moveStartEi:
  959|     40|void MemStream::moveStart(int delta) {
  960|     40|  start += delta;
  961|     40|  length -= delta;
  962|     40|  bufPtr = buf + start;
  963|     40|}

_ZN10BaseStream11getFileNameEv:
  180|    122|  virtual GString *getFileName() { return NULL; }
_ZN9MemStream6getPosEv:
  369|      5|  virtual GFileOffset getPos() { return (GFileOffset)(bufPtr - buf); }
_ZN9MemStream8getStartEv:
  371|    244|  virtual GFileOffset getStart() { return start; }

_ZN10UnicodeMapC2EPKciP15UnicodeMapRangei:
  122|    488|		       UnicodeMapRange *rangesA, int lenA) {
  123|    488|  encodingName = new GString(encodingNameA);
  124|    488|  unicodeOut = unicodeOutA;
  125|    488|  kind = unicodeMapResident;
  126|    488|  ranges = rangesA;
  127|    488|  len = lenA;
  128|    488|  eMaps = NULL;
  129|    488|  eMapsLen = 0;
  130|    488|  refCnt = 1;
  131|    488|}
_ZN10UnicodeMapC2EPKciPFijPciE:
  134|    244|		       UnicodeMapFunc funcA) {
  135|    244|  encodingName = new GString(encodingNameA);
  136|    244|  unicodeOut = unicodeOutA;
  137|    244|  kind = unicodeMapFunc;
  138|    244|  func = funcA;
  139|    244|  eMaps = NULL;
  140|    244|  eMapsLen = 0;
  141|    244|  refCnt = 1;
  142|    244|}
_ZN10UnicodeMapD2Ev:
  144|    732|UnicodeMap::~UnicodeMap() {
  145|    732|  delete encodingName;
  146|    732|  if (kind == unicodeMapUser && ranges) {
  ------------------
  |  Branch (146:7): [True: 0, False: 732]
  |  Branch (146:33): [True: 0, False: 0]
  ------------------
  147|      0|    gfree(ranges);
  148|      0|  }
  149|    732|  if (eMaps) {
  ------------------
  |  Branch (149:7): [True: 0, False: 732]
  ------------------
  150|      0|    gfree(eMaps);
  151|      0|  }
  152|    732|}
_ZN15UnicodeMapCacheC2Ev:
  228|    122|UnicodeMapCache::UnicodeMapCache() {
  229|    122|  int i;
  230|       |
  231|    610|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    610|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (231:15): [True: 488, False: 122]
  ------------------
  232|    488|    cache[i] = NULL;
  233|    488|  }
  234|    122|}
_ZN15UnicodeMapCacheD2Ev:
  236|    122|UnicodeMapCache::~UnicodeMapCache() {
  237|    122|  int i;
  238|       |
  239|    610|  for (i = 0; i < unicodeMapCacheSize; ++i) {
  ------------------
  |  |  102|    610|#define unicodeMapCacheSize 4
  ------------------
  |  Branch (239:15): [True: 488, False: 122]
  ------------------
  240|    488|    if (cache[i]) {
  ------------------
  |  Branch (240:9): [True: 0, False: 488]
  ------------------
  241|      0|      cache[i]->decRefCnt();
  242|      0|    }
  243|    488|  }
  244|    122|}

_ZN10UnicodeMap15getEncodingNameEv:
   65|    732|  GString *getEncodingName() { return encodingName; }

_ZN16UnicodeRemappingC2Ev:
   69|    122|UnicodeRemapping::UnicodeRemapping() {
   70|  31.3k|  for (int i = 0; i < 256; ++i) {
  ------------------
  |  Branch (70:19): [True: 31.2k, False: 122]
  ------------------
   71|  31.2k|    page0[i] = (Unicode)i;
   72|  31.2k|  }
   73|    122|  sMap = NULL;
   74|    122|  sMapLen = sMapSize = 0;
   75|    122|}
_ZN16UnicodeRemappingD2Ev:
   77|    122|UnicodeRemapping::~UnicodeRemapping() {
   78|    122|  gfree(sMap);
   79|    122|}

_ZN4XRefC2EP10BaseStreami:
  289|    244|XRef::XRef(BaseStream *strA, GBool repair) {
  290|    244|  GFileOffset pos;
  291|    244|  Object obj;
  292|    244|  XRefPosSet *posSet;
  293|    244|  int i;
  294|       |
  295|    244|  ok = gTrue;
  ------------------
  |  |   17|    244|#define gTrue 1
  ------------------
  296|    244|  errCode = errNone;
  ------------------
  |  |   12|    244|#define errNone             0	// no error
  ------------------
  297|    244|  repaired = gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  298|    244|  size = 0;
  299|    244|  last = -1;
  300|    244|  entries = NULL;
  301|    244|  lastStartxrefPos = 0;
  302|    244|  xrefTablePos = NULL;
  303|    244|  xrefTablePosLen = 0;
  304|    244|  streamEnds = NULL;
  305|    244|  streamEndsLen = 0;
  306|  31.4k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  31.4k|#define objStrCacheSize 128
  ------------------
  |  Branch (306:15): [True: 31.2k, False: 244]
  ------------------
  307|  31.2k|    objStrs[i] = NULL;
  308|  31.2k|    objStrLastUse[i] = 0;
  309|  31.2k|  }
  310|    244|  objStrCacheLength = 0;
  311|    244|  objStrTime = 0;
  312|       |
  313|    244|  encrypted = gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  314|    244|  permFlags = defPermFlags;
  ------------------
  |  |   41|    244|#define defPermFlags 0xfffc
  ------------------
  315|    244|  ownerPasswordOk = gFalse;
  ------------------
  |  |   18|    244|#define gFalse 0
  ------------------
  316|       |
  317|  4.14k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  4.14k|#define xrefCacheSize 16
  ------------------
  |  Branch (317:15): [True: 3.90k, False: 244]
  ------------------
  318|  3.90k|    cache[i].num = -1;
  319|  3.90k|  }
  320|       |
  321|    244|#if MULTITHREADED
  322|    244|  gInitMutex(&objStrsMutex);
  ------------------
  |  |   51|    244|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  323|    244|  gInitMutex(&cacheMutex);
  ------------------
  |  |   51|    244|#define gInitMutex(m) pthread_mutex_init(m, NULL)
  ------------------
  324|    244|#endif
  325|       |
  326|    244|  str = strA;
  327|    244|  start = str->getStart();
  328|       |
  329|       |  // if the 'repair' flag is set, try to reconstruct the xref table
  330|    244|  if (repair) {
  ------------------
  |  Branch (330:7): [True: 122, False: 122]
  ------------------
  331|    122|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (331:9): [True: 122, False: 0]
  ------------------
  332|    122|      errCode = errDamaged;
  ------------------
  |  |   18|    122|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  333|    122|      return;
  334|    122|    }
  335|      0|    repaired = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  336|       |
  337|       |  // if the 'repair' flag is not set, read the xref table
  338|    122|  } else {
  339|       |
  340|       |    // read the trailer
  341|    122|    pos = getStartXref();
  342|    122|    if (pos == 0) {
  ------------------
  |  Branch (342:9): [True: 122, False: 0]
  ------------------
  343|    122|      errCode = errDamaged;
  ------------------
  |  |   18|    122|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  344|    122|      ok = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  345|    122|      return;
  346|    122|    }
  347|       |
  348|       |    // read the xref table
  349|      0|    posSet = new XRefPosSet();
  350|      0|    while (readXRef(&pos, posSet, gFalse)) ;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  |  Branch (350:12): [True: 0, False: 0]
  ------------------
  351|      0|    xrefTablePosLen = posSet->getLength();
  352|      0|    xrefTablePos = (GFileOffset *)gmallocn(xrefTablePosLen,
  353|      0|					   sizeof(GFileOffset));
  354|      0|    for (i = 0; i < xrefTablePosLen; ++i)  {
  ------------------
  |  Branch (354:17): [True: 0, False: 0]
  ------------------
  355|      0|      xrefTablePos[i] = posSet->get(i);
  356|      0|    }
  357|      0|    delete posSet;
  358|      0|    if (!ok) {
  ------------------
  |  Branch (358:9): [True: 0, False: 0]
  ------------------
  359|      0|      errCode = errDamaged;
  ------------------
  |  |   18|      0|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  360|      0|      return;
  361|      0|    }
  362|      0|  }
  363|       |
  364|       |  // get the root dictionary (catalog) object
  365|      0|  trailerDict.dictLookupNF("Root", &obj);
  366|      0|  if (obj.isRef()) {
  ------------------
  |  Branch (366:7): [True: 0, False: 0]
  ------------------
  367|      0|    rootNum = obj.getRefNum();
  368|      0|    rootGen = obj.getRefGen();
  369|      0|    obj.free();
  370|      0|  } else {
  371|      0|    obj.free();
  372|      0|    if (!(ok = constructXRef())) {
  ------------------
  |  Branch (372:9): [True: 0, False: 0]
  ------------------
  373|      0|      errCode = errDamaged;
  ------------------
  |  |   18|      0|#define errDamaged          3	// PDF file was damaged and couldn't be
  ------------------
  374|      0|      return;
  375|      0|    }
  376|      0|  }
  377|       |
  378|       |  // now set the trailer dictionary's xref pointer so we can fetch
  379|       |  // indirect objects from it
  380|      0|  trailerDict.getDict()->setXRef(this);
  381|      0|}
_ZN4XRefD2Ev:
  383|    244|XRef::~XRef() {
  384|    244|  int i;
  385|       |
  386|  4.14k|  for (i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  4.14k|#define xrefCacheSize 16
  ------------------
  |  Branch (386:15): [True: 3.90k, False: 244]
  ------------------
  387|  3.90k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (387:9): [True: 0, False: 3.90k]
  ------------------
  388|      0|      cache[i].obj.free();
  389|      0|    }
  390|  3.90k|  }
  391|    244|  gfree(entries);
  392|    244|  trailerDict.free();
  393|    244|  if (xrefTablePos) {
  ------------------
  |  Branch (393:7): [True: 0, False: 244]
  ------------------
  394|      0|    gfree(xrefTablePos);
  395|      0|  }
  396|    244|  if (streamEnds) {
  ------------------
  |  Branch (396:7): [True: 0, False: 244]
  ------------------
  397|      0|    gfree(streamEnds);
  398|      0|  }
  399|  31.4k|  for (i = 0; i < objStrCacheSize; ++i) {
  ------------------
  |  |   51|  31.4k|#define objStrCacheSize 128
  ------------------
  |  Branch (399:15): [True: 31.2k, False: 244]
  ------------------
  400|  31.2k|    if (objStrs[i]) {
  ------------------
  |  Branch (400:9): [True: 0, False: 31.2k]
  ------------------
  401|      0|      delete objStrs[i];
  402|      0|    }
  403|  31.2k|  }
  404|    244|#if MULTITHREADED
  405|    244|  gDestroyMutex(&objStrsMutex);
  ------------------
  |  |   52|    244|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  406|    244|  gDestroyMutex(&cacheMutex);
  ------------------
  |  |   52|    244|#define gDestroyMutex(m) pthread_mutex_destroy(m)
  ------------------
  407|    244|#endif
  408|    244|}
_ZN4XRef12getStartXrefEv:
  411|    122|GFileOffset XRef::getStartXref() {
  412|    122|  char buf[xrefSearchSize+1];
  413|    122|  char *p;
  414|    122|  int n, i;
  415|       |
  416|       |  // read last xrefSearchSize bytes
  417|    122|  str->setPos(xrefSearchSize, -1);
  ------------------
  |  |   30|    122|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  418|    122|  n = str->getBlock(buf, xrefSearchSize);
  ------------------
  |  |   30|    122|#define xrefSearchSize 1024	// read this many bytes at end of file
  ------------------
  419|    122|  buf[n] = '\0';
  420|       |
  421|       |  // find startxref
  422|  18.2k|  for (i = n - 9; i >= 0; --i) {
  ------------------
  |  Branch (422:19): [True: 18.0k, False: 117]
  ------------------
  423|  18.0k|    if (!strncmp(&buf[i], "startxref", 9)) {
  ------------------
  |  Branch (423:9): [True: 5, False: 18.0k]
  ------------------
  424|      5|      break;
  425|      5|    }
  426|  18.0k|  }
  427|    122|  if (i < 0) {
  ------------------
  |  Branch (427:7): [True: 117, False: 5]
  ------------------
  428|    117|    return 0;
  429|    117|  }
  430|      9|  for (p = &buf[i+9]; isspace(*p & 0xff); ++p) ;
  ------------------
  |  Branch (430:23): [True: 4, False: 5]
  ------------------
  431|      5|  lastXRefPos = strToFileOffset(p);
  432|      5|  lastStartxrefPos = str->getPos() - n + i;
  433|       |
  434|      5|  return lastXRefPos;
  435|    122|}
_ZN4XRef13constructXRefEv:
  864|    122|GBool XRef::constructXRef() {
  865|    122|  int *streamObjNums = NULL;
  866|    122|  int streamObjNumsLen = 0;
  867|    122|  int streamObjNumsSize = 0;
  868|    122|  int lastObjNum = -1;
  869|    122|  rootNum = -1;
  870|    122|  int streamEndsSize = 0;
  871|    122|  streamEndsLen = 0;
  872|    122|  char buf[4096 + 1];
  873|    122|  str->reset();
  874|    122|  GFileOffset bufPos = start;
  875|    122|  char *p = buf;
  876|    122|  char *end = buf;
  877|    122|  GBool startOfLine = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  878|    122|  GBool space = gTrue;
  ------------------
  |  |   17|    122|#define gTrue 1
  ------------------
  879|    122|  GBool eof = gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  880|  18.8k|  while (1) {
  ------------------
  |  Branch (880:10): [Folded - Ignored]
  ------------------
  881|  18.8k|    if (end - p < 256 && !eof) {
  ------------------
  |  Branch (881:9): [True: 14.7k, False: 4.06k]
  |  Branch (881:26): [True: 122, False: 14.6k]
  ------------------
  882|    122|      memcpy(buf, p, end - p);
  883|    122|      bufPos += p - buf;
  884|    122|      p = buf + (end - p);
  885|    122|      int n = (int)(buf + 4096 - p);
  886|    122|      int m = str->getBlock(p, n);
  887|    122|      end = p + m;
  888|    122|      *end = '\0';
  889|    122|      p = buf;
  890|    122|      eof = m < n;
  891|    122|    }
  892|  18.8k|    if (p == end && eof) {
  ------------------
  |  Branch (892:9): [True: 122, False: 18.7k]
  |  Branch (892:21): [True: 122, False: 0]
  ------------------
  893|    122|      break;
  894|    122|    }
  895|  18.7k|    if (startOfLine && !strncmp(p, "trailer", 7)) {
  ------------------
  |  Branch (895:9): [True: 1.52k, False: 17.2k]
  |  Branch (895:24): [True: 0, False: 1.52k]
  ------------------
  896|      0|      constructTrailerDict((GFileOffset)(bufPos + (p + 7 - buf)));
  897|      0|      p += 7;
  898|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  899|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  900|  18.7k|    } else if (startOfLine && !strncmp(p, "endstream", 9)) {
  ------------------
  |  Branch (900:16): [True: 1.52k, False: 17.2k]
  |  Branch (900:31): [True: 0, False: 1.52k]
  ------------------
  901|      0|      if (streamEndsLen == streamEndsSize) {
  ------------------
  |  Branch (901:11): [True: 0, False: 0]
  ------------------
  902|      0|	streamEndsSize += 64;
  903|      0|	streamEnds = (GFileOffset *)greallocn(streamEnds, streamEndsSize,
  904|      0|					      sizeof(GFileOffset));
  905|      0|      }
  906|      0|      streamEnds[streamEndsLen++] = (GFileOffset)(bufPos + (p - buf));
  907|      0|      p += 9;
  908|      0|      startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  909|      0|      space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  910|  18.7k|    } else if (space && *p >= '0' && *p <= '9') {
  ------------------
  |  Branch (910:16): [True: 6.32k, False: 12.4k]
  |  Branch (910:25): [True: 197, False: 6.12k]
  |  Branch (910:38): [True: 38, False: 159]
  ------------------
  911|     38|      p = constructObjectEntry(p, (GFileOffset)(bufPos + (p - buf)),
  912|     38|			       &lastObjNum);
  913|     38|      startOfLine = gFalse;
  ------------------
  |  |   18|     38|#define gFalse 0
  ------------------
  914|     38|      space = gFalse;
  ------------------
  |  |   18|     38|#define gFalse 0
  ------------------
  915|  18.7k|    } else if (p[0] == '>' && p[1] == '>') {
  ------------------
  |  Branch (915:16): [True: 32, False: 18.6k]
  |  Branch (915:31): [True: 21, False: 11]
  ------------------
  916|     21|      p += 2;
  917|     21|      startOfLine = gFalse;
  ------------------
  |  |   18|     21|#define gFalse 0
  ------------------
  918|     21|      space = gFalse;
  ------------------
  |  |   18|     21|#define gFalse 0
  ------------------
  919|       |      // skip any PDF whitespace except for '\0'
  920|     21|      while (*p == '\t' || *p == '\n' || *p == '\x0c' ||
  ------------------
  |  Branch (920:14): [True: 0, False: 21]
  |  Branch (920:28): [True: 0, False: 21]
  |  Branch (920:42): [True: 0, False: 21]
  ------------------
  921|     21|	     *p == '\r' || *p == ' ') {
  ------------------
  |  Branch (921:7): [True: 0, False: 21]
  |  Branch (921:21): [True: 0, False: 21]
  ------------------
  922|      0|	if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (922:6): [True: 0, False: 0]
  |  Branch (922:20): [True: 0, False: 0]
  ------------------
  923|      0|	  startOfLine = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  924|      0|	}
  925|      0|	space = gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  926|      0|	++p;
  927|      0|      }
  928|     21|      if (!strncmp(p, "stream", 6)) {
  ------------------
  |  Branch (928:11): [True: 0, False: 21]
  ------------------
  929|      0|	if (lastObjNum >= 0) {
  ------------------
  |  Branch (929:6): [True: 0, False: 0]
  ------------------
  930|      0|	  if (streamObjNumsLen == streamObjNumsSize) {
  ------------------
  |  Branch (930:8): [True: 0, False: 0]
  ------------------
  931|      0|	    streamObjNumsSize += 64;
  932|      0|	    streamObjNums = (int *)greallocn(streamObjNums, streamObjNumsSize,
  933|      0|					     sizeof(int));
  934|      0|	  }
  935|      0|	  streamObjNums[streamObjNumsLen++] = lastObjNum;
  936|      0|	}
  937|      0|	p += 6;
  938|      0|	startOfLine = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  939|      0|	space = gFalse;
  ------------------
  |  |   18|      0|#define gFalse 0
  ------------------
  940|      0|      }
  941|  18.6k|    } else {
  942|  18.6k|      if (*p == '\n' || *p == '\r') {
  ------------------
  |  Branch (942:11): [True: 820, False: 17.8k]
  |  Branch (942:25): [True: 194, False: 17.6k]
  ------------------
  943|  1.01k|	startOfLine = gTrue;
  ------------------
  |  |   17|  1.01k|#define gTrue 1
  ------------------
  944|  1.01k|	space = gTrue;
  ------------------
  |  |   17|  1.01k|#define gTrue 1
  ------------------
  945|  17.6k|      } else if (Lexer::isSpace(*p & 0xff)) {
  ------------------
  |  Branch (945:18): [True: 5.25k, False: 12.4k]
  ------------------
  946|  5.25k|	space = gTrue;
  ------------------
  |  |   17|  5.25k|#define gTrue 1
  ------------------
  947|  12.4k|      } else {
  948|  12.4k|	startOfLine = gFalse;
  ------------------
  |  |   18|  12.4k|#define gFalse 0
  ------------------
  949|  12.4k|	space = gFalse;
  ------------------
  |  |   18|  12.4k|#define gFalse 0
  ------------------
  950|  12.4k|      }
  951|  18.6k|      ++p;
  952|  18.6k|    }
  953|  18.7k|  }
  954|       |
  955|       |  // read each stream object, check for xref or object stream
  956|    122|  for (int i = 0; i < streamObjNumsLen; ++i) {
  ------------------
  |  Branch (956:19): [True: 0, False: 122]
  ------------------
  957|      0|    Object obj;
  958|      0|    fetch(streamObjNums[i], entries[streamObjNums[i]].gen, &obj);
  959|      0|    if (obj.isStream()) {
  ------------------
  |  Branch (959:9): [True: 0, False: 0]
  ------------------
  960|      0|      Dict *dict = obj.streamGetDict();
  961|      0|      Object type;
  962|      0|      dict->lookup("Type", &type);
  963|      0|      if (type.isName("XRef")) {
  ------------------
  |  Branch (963:11): [True: 0, False: 0]
  ------------------
  964|      0|	saveTrailerDict(dict, gTrue);
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  965|      0|      } else if (type.isName("ObjStm")) {
  ------------------
  |  Branch (965:18): [True: 0, False: 0]
  ------------------
  966|      0|	constructObjectStreamEntries(&obj, streamObjNums[i]);
  967|      0|      }
  968|      0|      type.free();
  969|      0|    }
  970|      0|    obj.free();
  971|      0|  }
  972|       |
  973|    122|  gfree(streamObjNums);
  974|       |
  975|       |  // if the file is encrypted, then any objects fetched here will be
  976|       |  // incorrect (because decryption is not yet enabled), so clear the
  977|       |  // cache to avoid that problem
  978|  2.07k|  for (int i = 0; i < xrefCacheSize; ++i) {
  ------------------
  |  |   49|  2.07k|#define xrefCacheSize 16
  ------------------
  |  Branch (978:19): [True: 1.95k, False: 122]
  ------------------
  979|  1.95k|    if (cache[i].num >= 0) {
  ------------------
  |  Branch (979:9): [True: 0, False: 1.95k]
  ------------------
  980|      0|      cache[i].obj.free();
  981|      0|      cache[i].num = -1;
  982|      0|    }
  983|  1.95k|  }
  984|       |
  985|    122|  if (rootNum < 0) {
  ------------------
  |  Branch (985:7): [True: 122, False: 0]
  ------------------
  986|    122|    error(errSyntaxError, -1, "Couldn't find trailer dictionary");
  987|    122|    return gFalse;
  ------------------
  |  |   18|    122|#define gFalse 0
  ------------------
  988|    122|  }
  989|      0|  return gTrue;
  ------------------
  |  |   17|      0|#define gTrue 1
  ------------------
  990|    122|}
_ZN4XRef20constructObjectEntryEPclPi:
 1032|     38|char *XRef::constructObjectEntry(char *p, GFileOffset pos, int *objNum) {
 1033|       |  // we look for non-end-of-line space characters here, to deal with
 1034|       |  // situations like:
 1035|       |  //    nnn          <-- garbage digits on a line
 1036|       |  //    nnn nnn obj  <-- actual object
 1037|       |  // and we also ignore '\0' (because it's used to terminate the
 1038|       |  // buffer in this damage-scanning code)
 1039|     38|  int num = 0;
 1040|    271|  do {
 1041|    271|    num = (num * 10) + (*p - '0');
 1042|    271|    ++p;
 1043|    271|  } while (*p >= '0' && *p <= '9' && num < 100000000);
  ------------------
  |  Branch (1043:12): [True: 261, False: 10]
  |  Branch (1043:25): [True: 258, False: 3]
  |  Branch (1043:38): [True: 233, False: 25]
  ------------------
 1044|     38|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1044:7): [True: 37, False: 1]
  |  Branch (1044:21): [True: 37, False: 0]
  |  Branch (1044:37): [True: 37, False: 0]
  ------------------
 1045|     37|    return p;
 1046|     37|  }
 1047|      1|  do {
 1048|      1|    ++p;
 1049|      1|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1049:12): [True: 0, False: 1]
  |  Branch (1049:26): [True: 0, False: 1]
  |  Branch (1049:42): [True: 0, False: 1]
  ------------------
 1050|      1|  if (!(*p >= '0' && *p <= '9')) {
  ------------------
  |  Branch (1050:9): [True: 1, False: 0]
  |  Branch (1050:22): [True: 1, False: 0]
  ------------------
 1051|      0|    return p;
 1052|      0|  }
 1053|      1|  int gen = 0;
 1054|      9|  do {
 1055|      9|    gen = (gen * 10) + (*p - '0');
 1056|      9|    ++p;
 1057|      9|  } while (*p >= '0' && *p <= '9' && gen < 100000000);
  ------------------
  |  Branch (1057:12): [True: 9, False: 0]
  |  Branch (1057:25): [True: 9, False: 0]
  |  Branch (1057:38): [True: 8, False: 1]
  ------------------
 1058|      1|  if (*p != '\t' && *p != '\x0c' && *p != ' ') {
  ------------------
  |  Branch (1058:7): [True: 1, False: 0]
  |  Branch (1058:21): [True: 1, False: 0]
  |  Branch (1058:37): [True: 1, False: 0]
  ------------------
 1059|      1|    return p;
 1060|      1|  }
 1061|      0|  do {
 1062|      0|    ++p;
 1063|      0|  } while (*p == '\t' || *p == '\x0c' || *p == ' ');
  ------------------
  |  Branch (1063:12): [True: 0, False: 0]
  |  Branch (1063:26): [True: 0, False: 0]
  |  Branch (1063:42): [True: 0, False: 0]
  ------------------
 1064|      0|  if (strncmp(p, "obj", 3)) {
  ------------------
  |  Branch (1064:7): [True: 0, False: 0]
  ------------------
 1065|      0|    return p;
 1066|      0|  }
 1067|       |
 1068|      0|  if (constructXRefEntry(num, gen, pos - start, xrefEntryUncompressed)) {
  ------------------
  |  Branch (1068:7): [True: 0, False: 0]
  ------------------
 1069|      0|    *objNum = num;
 1070|      0|  }
 1071|       |
 1072|      0|  return p;
 1073|      0|}
_ZN4XRef15strToFileOffsetEPc:
 1435|      5|GFileOffset XRef::strToFileOffset(char *s) {
 1436|      5|  GFileOffset x, d;
 1437|      5|  char *p;
 1438|       |
 1439|      5|  x = 0;
 1440|      5|  for (p = s; *p && isdigit(*p & 0xff); ++p) {
  ------------------
  |  Branch (1440:15): [True: 4, False: 1]
  |  Branch (1440:21): [True: 0, False: 4]
  ------------------
 1441|      0|    d = *p - '0';
 1442|      0|    if (x > (GFILEOFFSET_MAX - d) / 10) {
  ------------------
  |  |  128|      0|#define GFILEOFFSET_MAX 0x7fffffffffffffffLL
  ------------------
  |  Branch (1442:9): [True: 0, False: 0]
  ------------------
 1443|      0|      break;
 1444|      0|    }
 1445|      0|    x = 10 * x + d;
 1446|      0|  }
 1447|      5|  return x;
 1448|      5|}

_ZN4XRef4isOkEv:
   64|    244|  GBool isOk() { return ok; }
_ZN4XRef12getErrorCodeEv:
   67|    244|  int getErrorCode() { return errCode; }

