{
    "samples": [

    {
        "benchmark": "output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <stdint.h>\\n#include <stdlib.h>\\n#include <fuzzer/FuzzedDataProvider.h>\\n\\n#include <Object.h>\\n#include <Stream.h>\\n#include <GfxState.h>\\n#include <SplashBitmap.h>\\n#include <SplashOutputDev.h>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  FuzzedDataProvider fuzz_data(data, size);\\n  \\n  if (size < sizeof(int)*3 + sizeof(double)*6 + sizeof(bool)*3) {\\n    return 0;\\n  }\\n\\n  PDFRectangle pdfRect;\\n  auto context = new GfxState(72, 72, &pdfRect, 0, true);\\n  SplashColor splashColor;\\n  auto dev = new SplashOutputDev(splashModeRGB8, 4, false, splashColor);\\n\\n  double x = fuzz_data.ConsumeFloatingPoint<double>();\\n  double y = fuzz_data.ConsumeFloatingPoint<double>();\\n  double dx = fuzz_data.ConsumeFloatingPoint<double>();\\n  double dy = fuzz_data.ConsumeFloatingPoint<double>();\\n  double originX = fuzz_data.ConsumeFloatingPoint<double>();\\n  double originY = fuzz_data.ConsumeFloatingPoint<double>();\\n  CharCode code = fuzz_data.ConsumeIntegral<CharCode>();\\n  int nBytes = fuzz_data.ConsumeIntegralInRange(0, 4); // Limit nBytes to be within practical range\\n  int uLen;\\n  if (nBytes > 0)\\n    uLen = fuzz_data.ConsumeIntegralInRange(0, 3); // Limit Unicode size for practicality\\n  else\\n    uLen = 0;\\n  Unicode u[uLen];\\n  for(int i = 0; i < uLen; i++)\\n    u[i] = fuzz_data.ConsumeIntegral<Unicode>();\\n\\n  bool is_copy = fuzz_data.ConsumeBool();\\n  bool is_last = fuzz_data.ConsumeBool();\\n  bool is_true = fuzz_data.ConsumeBool();\\n\\n  dev->drawChar(context, x, y, dx, dy, originX, originY, code, nBytes, u, uLen, is_copy, is_last, is_true);\\n\\n  delete dev;\\n  delete context;\\n\\n  return 0;\\n\\n}",
        "model": ""
    },

    {
        "benchmark": "output-xpdf-_zn15splashoutputdev8drawcharep8gfxstateddddddjipjiiii",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <stdint.h>\\n#include <stdio.h>\\n\\n#include \"Object.h\"\\n#include \"/src/xpdf-4.05/xpdf/XRef.h\"\\n#include \"Dict.h\"\\n\\n#include \"SplashOutputDev.h\"\\n#include \"/src/xpdf-4.05/xpdf/SplashOutputDev.h\"\\n#include \"splash/SplashBitmap.h\"\\n#include \"GfxState.h\"\\n\\n#include \"/src/xpdf-4.05/fofi/FoFiTrueType.h\"\\n#include \"/src/xpdf-4.05/xpdf/FoFiType1C.h\"\\n#include \"/src/xpdf-4.05/xpdf/FoFiType1.h\"\\n#include \"/src/xpdf-4.05/xpdf/FoFiIdentifier.h\"\\n\\n#include <fuzzer/FuzzedDataProvider.h>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  if (size < 2) {\\n    return 0;\\n  }\\n\\n  FuzzedDataProvider fdp(data, size);\\n\\n  SplashColor white;\\n  white[0] = 255;\\n  white[1] = 255;\\n  white[2] = 255;\\n  white[3] = 255;\\n\\n  SplashOutputDev splash_out(splashModeBGR8, 4, gFalse, white);\\n  splash_out.startDoc(NULL);\\n\\n  GfxState *gfxState = new GfxState(72, 72, nullptr, 0, gFalse);\\n  double x = fdp.ConsumeFloatingPoint<double>();\\n  double y = fdp.ConsumeFloatingPoint<double>();\\n  double dx = fdp.ConsumeFloatingPoint<double>();\\n  double dy = fdp.ConsumeFloatingPoint<double>();\\n  double originX = fdp.ConsumeFloatingPoint<double>();\\n  double originY = fdp.ConsumeFloatingPoint<double>();\\n \\n  CharCode code = fdp.ConsumeIntegral<CharCode>();\\n  int nBytes = fdp.ConsumeIntegralInRange<int>(1, 10);\\n  GBool composing = fdp.ConsumeBool();\\n  GBool horizontal = fdp.ConsumeBool();\\n\\n  Unicode *u = nullptr;\\n  if (nBytes > 0) {\\n    u = new Unicode[nBytes];\\n    for (int i = 0; i < nBytes; i++) {\\n      u[i] = fdp.ConsumeIntegral<Unicode>();\\n    }\\n  }\\n\\n  splash_out.drawChar(gfxState, x, y, dx, dy, originX, originY, code, \\n                      nBytes, u, nBytes, composing, gFalse, horizontal);\\n\\n  delete gfxState;\\n  delete[] u;\\n\\n  return 0;\\n}",
        "model": ""
    }

    ]
}